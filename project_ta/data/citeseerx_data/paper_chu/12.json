{"user_name":" CURE: An Efficient Clustering Algorithm for Large Databases ","user_timeline":[{"aspect":"abstract","tweet":" Abstract Clustering, in data mining, is useful for discovering groups and identifying interesting distributions in the underlying data. Traditional clustering algorithms either favor clusters with spherical shapes and similar sizes, or are very frag- ile in the presence of outliers. We propose a new cluster- ing algorithm called CURE that is more robust to outliers, and identifies clusters having non-spherical shapes and wide variances in size. CURE achieves this by representing each cluster by a certain fixed number of points that are gen- erated by selecting well scattered points from the cluster and then shrinking them toward the center of the cluster by a specified fraction. Having more than one representa- tive point per cluster allows CURE to adjust well to the geometry of non-spherical shapes and the shrinking helps to dampen the effects of outliers. To handle large databases, CURE employs a combination of random sampling and par- titioning. A random sample drawn from the data set is first partitioned and each partition is partially clustered. The partial clusters are then clustered in a second pass to yield the desired clusters. Our experimental results confirm that the quality of clusters produced by CURE is much better than those found by existing algorithms. Furthermore, they demonstrate that random sampling and partitioning enable CURE to not only outperform existing algorithms but also to scale well for large databases without sacrificing cluster- ing quality. "},{"aspect":"expanalysis","tweet":" 6 Concluding Remarks [MRSS] In this paper, we addressed problems with traditional clustering algorithms which either favor clusters with spherical shapes and similar sizes, or are very fragile in the presence [NH941 of outliers. We proposed a clustering method called CURE. CURE utilizes multiple representative points for each cluster that are generated by selecting well scattered points from [Ols93] the cluster and then shrinking them toward the center of the cluster by a specified fraction. This enables CURE to adjust well to the geometry of clusters having non-spherical shapes and wide variances in size. To handle large databases, CURE [Sam891 employs a combination of random sampling and partitioning [SamSO] that allows it to handle large data sets efficiently. Random sampling, coupled with outlier handling techniques, also makes it possible for CURE to filter outliers contained [SRF87] in the data set effectively. Furthermore, the labeling algorithm in CURE uses multiple random representative points for each cluster to assign data points on disk. This enables it to correctly label points even when the shapes of clus- [Vit85] ters are non-spherical and the sizes of clusters vary. For a random sample size of 3, the time complexity of CURE is 0(s2) for low-dimensional data and the space complexity is [ZRL96] linear in s. To study the effectiveness of CURE for clustering large data sets, we conducted extensive experiments. Our results confirm that the quality of clusters produced by CURE is much better than those found by existing algorithms. Furthermore, they demonstrate that CURE not only outperforms existing algorithms but also scales well for large databases without sacrificing clustering quality. "},{"aspect":"expdata","tweet":" 5.2 Data sets We experimented with four data sets containing points in two dimensions. Details of these experiments can be found in [GRS97]. Due to the lack of space, we report here the results with only two data sets whose geometric shape is as illustrated in Figure 7. The number of points in each data set is also described in Table 2. Data set 1 contains one big and two small circles that traditional partitional and hierarchical clustering algorithms, including BIRCH, fail to find. The data set also contains two ellipsoids which are con- nected by a chain of outliers. In addition, the data set has random outliers scattered in the entire space. The purpose of having outliers in the data set is to compare the sensitiv- ity of CURE and MST to outliers. Data set 2 is identical to one of the data sets used for the experiments in [ZRLSG]. It consists of 100 clusters with centers arranged in a grid pattern and data points in each cluster following a normal distribution with mean at the cluster center (a more detailed description of the data set can be found in [ZRL96]). We Table 2: Data Sets 81 show that CURE not only correctly clusters this data set, but also that its execution times on the data set are much smaller than BIRCH. "},{"aspect":"background","tweet":" 1 Introduction The wealth of information embedded in huge databases be- longing to corporations (e.g., retail, financial, telecom) has spurred a tremendous interest in the areas of lcnowledge dis- covery and data mining. Clustering, in data mining, is a useful technique for discovering interesting data distribu- tions and patterns in the underlying data. The problem of clustering can be defined as follows: given n data points in a d-dimensional metric space, partition the data points into Ic *The work was done while the author was visiting Bell Laboratories. Permiaslon to make digital or hard copier of all or part of this work for pareOne or clrrseroom use is granted without fee provided that copi** are not made or distributed for profit or commrrcisl advan- tage and that copies boar this notice and the full citation on the firat psga. To copy otherwise. to republish. to post on a.rv.r, or to redistribute to Iiatr, requires prior specific permission and/or a foe. SIGMOD \u201aÄò98 Seattle, WA, USA 8 1998 ACM 0-89791~996.5/98/006...$6.00 Bell Laboratories Murray Hill, NJ 07974 rastogi@bell-labs.com 73 Bell Laboratories Murray Hill, NJ 07974 shim@bell-labsxom clusters such that the data points within a cluster are more similar to each other than data points in different clusters. 1.1 Traditional Clustering Algorithms - Drawbacks Existing clustering algorithms can be broadly classified into partitional and hierarchical [JD88]. Partitional clustering algorithms attempt to determine k partitions that optimize a certain criterion function. The square-error criterion, de- fined below, is the most commonly used (m; is the mean of cluster Ci). k E = c c IIP - rni112. i=l pee; The square-error is a good measure of the within-cluster variation across all the partitions. The objective is to find L partitions that minimize the square-error. Thus, square- error clustering tries to make the k clusters as compact and separated as possible, and works well when clusters are com- pact clouds that are rather well separated from one another. However, when there are large differences in the sizes or ge- ometries of different clusters, as illustrated in Figure 1, the square-error method could split large clusters to minimize the square-error. In the figure, the square-error is larger for the three separate clusters in (a) than for the three clusters in (b) where the big cluster is split into three portions, one of which is merged with the two smaller clusters. The reduc- tion in square-error for (b) is due to the fact that the slight reduction in square error due to splitting the large cluster is weighted by many data points in the large cluster. A hierarchical clustering is a sequence of partitions in which each partition is nested into the next partition in the sequence. An agglomerative algorithm for hierarchical clus- tering starts with the disjoint set of clusters, which places each input data point in an individual cluster. Pairs of items or clusters are then successively merged until the number of clusters reduces to Ic. At each step, the pair of clus- ters merged are the ones between which the distance is the minimum. The widely used measures for distance between clusters are as follows (mi is the mean for cluster Ci and n; is the number of points in Ci). For example, with d,,,, as the distance measure, at each step, the pair of clusters whose centroids or means are the closest are merged. On the other hand, with d,i,, the pair of clusters merged are the ones containing the closest pair of points. All of the above distance measures have a minimum variance flavor and they usually yield the same results if the clusters are compact and well-separated. However, if the clusters are close to one another (even by outliers), or if their shapes and sizes are not hyperspherical and uniform, the re- sults of clustering can vary quite dramatically. For example, with the data set shown in Figure l(a), using d,,,, d,,, or d,,,, as the distance measure results in clusters that are similar to those obtained by the square-error method shown in Figure l(b). Similarly, consider the example data points in Figure 2. The desired elongated clusters are shown in Fig- ure 2(a). However, d,,,, as the distance measure, causes the elongated clusters to be split and portions belonging to neighboring elongated clusters to be merged. The resulting clusters are as shown in Figure 2(b). On the other hand, with dmin as the distance measure, the resulting clusters are as shown in Figure 2(c). The two elongated clusters that are connected by narrow string of points are merged into a single cluster. This \u201aÄúchaining effect\u201aÄù is a drawback of d,in - basically, a few points located so as to form a bridge between the two clusters causes points across the clusters to be grouped into a single elongated cluster. From the above discussion, it follows that neither the centroid-based approach (that uses d,,,,) nor the all-points approach (based on d,i,) work well for non-spherical or arbitrary shaped clusters. A shortcoming of the centroid- based approach is that it considers only one point as repre- sentative of a cluster - the cluster centroid. For a large or arbitrary shaped cluster, the centroids of its subclusters can be reasonably far apart, thus causing the cluster to be split. The all-points approach, on the other hand, considers all the points within a cluster as representative of the cluster. This other extreme, has its own drawbacks, since it makes the clustering algorithm extremely sensitive to outliers and to slight changes in the position of data points. When the number N of input data points is large, hi- erarchical clustering algorithms break down due to their non-linear time complexity (typically, O(N\u201aÄô)) and huge I/O costs. In order to remedy this problem, in [ZRL96], the authors propose a new clustering method named BIRCH, which represents the state of the art for clustering large data sets. BIRCH first performs a preclzlstering phase in which dense regions of points are represented by compact sum- maries, and then a centroid-based hierarchical algorithm is used to cluster the set of summaries (which is much smaller than the original dataset). The preclustering algorithm employed by BIRCH to re- Figure 1: Splitting of a large cluster by partitional algorithms 74 duce input size is incremental and approximate. During preclustering, the entire database is scanned, and cluster summaries are stored in memory in a data structure called the CF-tree. For each successive data point, the CF-tree is traversed to find the closest cluster to it in the tree, and if the point is within a threshold distance of the closest cluster, it is absorbed into it. Otherwise, it starts its own cluster in the CF-tree. Once the clusters are generated, a final labeling phase is carried out in which using the centroids of clusters as seeds, each data point is assigned to the cluster with the closest seed. Using only the centroid of a cluster when redistribut- ing the data in the final phase has problems when clusters do not have uniform sizes and shapes as in Figure 3(a). In this case, as illustrated in Figure 3(b), in the final labeling phase, a number of points in the bigger cluster are labeled as belonging to the smaller cluster since they are closer to the centroid of the smaller cluster. 1.2 Our Contributions In this paper, we propose a new clustering method named CURE (Clustering Using Representatives) whose salient fea- tures are described below. Hierarchical Clustering Algorithm: CURE employs a novel hierarchical clustering algorithm that adopts a middle ground between the centroid-based and the all-point extremes. In CURE, a constant number c of well scattered points in a clus- ter are first chosen. The scattered points capture the shape and extent of the cluster. The chosen scattered points are next shrunk towards the centroid of the cluster by a fraction cr. These scattered points after shrinking are used as repre- sentatives of the cluster. The clusters with the closest pair of representative points are the clusters that are merged at each step of CURE\u201aÄôs hierarchical clustering algorithm. The scattered points approach employed by CURE alle- viates the shortcomings of both the all-points as well as the centroid-based approaches. It enables CURE to correctly identify the clusters in Figure 2(a) - the resulting clusters due to the centroid-based and all-points approaches is as shown in Figures 2(b) and 2(c), respectively. CURE is less sensitive to outliers since shrinking the scattered points to- ward the mean dampens the adverse effects due to outliers ~ outliers are typically further away from the mean and are thus shifted a larger distance due to the shrinking. Multiple scattered points also enable CURE to discover non-spherical clusters like the elongated clusters shown in Figure 2(a). For the centroid-based algorithm, the space that constitutes the vicinity of the single centroid for a cluster is spherical. Thus, it favors spherical clusters and as shown in Figure 2(b), splits the elongated clusters. On the other hand, with multiple scattered points as representatives of a cluster, the space that forms the vicinity of the cluster can be non-spherical, and this enables CURE to correctly identify the clusters in Figure 2(a). Note that the kinds of clusters identified by CURE can be tuned by varying 0: between 0 and 1. CURE reduces to the centroid-based algorithm if (Y = 1, while for cy = 0, it becomes similar to the all-points approach. CURE\u201aÄôs hi- erarchical clustering algorithm uses space that is linear in the input size n and has a worst-case time complexity of O(n2 log n). For lower dimensions (e.g., two), the complex- ity can be shown to further reduce to O(n\u201aÄô). Thus, the time complexity of CURE is no worse than that of the centroid- based hierarchical algorithm. Random Sampling and Partitioning: CURE\u201aÄôs approach to the clustering problem for large data sets differs from BIRCH in two ways. First, instead of preclustering with all the data points, CURE begins by drawing a random sample from the database. We show, both analytically and experimentally, that random samples of moderate sizes preserve informa- tion about the geometry of clusters fairly accurately, thus enabling CURE to correctly cluster the input. In particu- lar, assuming that each cluster has a certain minimum size, we use chernoff bounds to calculate the minimum sample size for which the sample contains, with high probability, at least a fraction f of every cluster. Second, in order to further speed up clustering, CURE first partitions the ran- dom sample and partially clusters the data points in each partition. After eliminating outliers, the preclustered data in each partition is then clustered in a final pass to generate (4 (b) 04 Figure 2: Clusters generated by hierarchical algorithms Figure 3: Problem of labeling 75 the final clusters. Labeling Data on Disk: Once clustering of the random sample is completed, instead of a single centroid, multiple representative points from each cluster are used to label the remainder of the data set. The problems with BIRCH\u201aÄôs la- beling phase are eliminated by assigning each data point to the cluster containing the closest representative point. Overview: The steps involved in clustering using CURE are described in Figure 4. Our experimental results confirm that not only does CURE\u201aÄôs novel approach to clustering based on scattered points, random sampling and partition- ing enable it to find clusters that traditional clustering algo- rithms fail to find, but it also results in significantly better execution times. The remainder of the paper is organized as follows. In Section 2, we survey related work on clustering large data sets. We present CURE\u201aÄôs hierarchical clustering algorithm that uses representative points, in Section 3. In Section 4, we discuss issues related to sampling, partitioning, outlier handling and labeling in CURE. Finally, in Section 5, we present the results of our experiments which support our claims about CURE\u201aÄôs clustering ability and execution times. Concluding remarks are made in Section 6. Data C!)[ Draw random sample) C$( Partition sample 2 Related Work (2 [ Label datain disk ](Il ( Cluster partial clusters In recent years, a number of clustering algorithms for large data.bases have been proposed [NH94, ZRL96, EKSX96]. In [NH94], the authors propose a partitional clustering method for large databases which is based on randomized search. Each cluster is represented by its medoid, the most centrally located point in the cluster, and the objective is to find the ,$ best medoids that optimize the criterion function. The authors reduce this problem to that of graph search by representing each set of k: medoids as a node in the graph, two nodes being adjacent if they have k - 1 medoids in common. Initially, an arbitrary node is set to be the current node and a fixed number of iterations are performed. In each iteration, a random neighbor of the current node is set to be the current node if it results in better clustering. The computation of the criterion function for the random neighbor requires the entire database to be examined. It is experimentally shown that CLARANS outperforms the traditional k-medoid algorithms. However, CLARANS may require several passes over the database, the runtime cost of which could be prohibitive for large databases. Furthermore, like other partitional converge to a local optimum. clustering algorithms, it could In [EKX95], the authors use the R*-tree[SRF87, BKSSSO, Sam891 to improve the I/O efficiency of CLARANS on large databases by (1) drawing samples from leaf pages to reduce the number of data points (since data points are packed in leaf nodes based on spatial locality, a sample point in the leaf page can be a good representative point), and (2) focusing on relevant points when evaluating neighbor. the \u201aÄúgoodness\u201aÄù of a Since multiple I/O scans of the data points is a bottleneck for existing clustering algorithms, in (ZRLSG], the authors present a clustering method named BIRCH whose I/O complexity is a little more than one scan of the data. BIRCH first pre-clusters the data into the maximum possible and finest possible subclusters that can fit in main-memory. For the pre-clustering phase, BIRCH employs a CF-tree which is a balanced tree structure similar to the B-tree and R-tree family[Sam89]. After pre-clustering, BIRCH treats each of the subcluster summaries as representative points, and runs a well-known approximation algorithm from [Ols93], which is an agglomerative hierarchical clustering algorithm. BIRCH and CLARANS work well for convex or spherical clusters of uniform size. However, they are unsuitable when clusters have different sizes (see Figure l), or when clusters are non-spherical (see Figure 2). For clustering such arbitrary shaped collections of points (e.g., ellipsoid, spiral, cylindrical), a density-based algorithm called DBSCAN was proposed in [EKSXSG]. DBSCAN requires the user to specify two parameters that are used to define minimum density for clustering ~~ the radius Eps of the neighborhood of a point and the minimum number of points MinPts in the neighborhood. Clusters are then found by starting from an arbitrary point, and if its neighborhood satisfies the minimum density, Figure 4: Overview of CURE 76 j\u201aÄù$( Partially cluster partitions -3 Eliminate outliers including the points in its neighborhood into the cluster. The process is then repeated for the newly added points. While DBSCAN can find clusters with arbitrary shapes, it suffers from a number of problems. DBSCAN is very sen- sitive to the parameters Eps and MinPts, which in turn, are difficult to determine. Furthermore, DBSCAN also suffers from the robustness problems that plague the all-points hier- archical clustering algorithm - in case there is a dense string of points connecting two clusters, DBSCAN could end up merging the two clusters. Also, DBSCAN does not perform any sort of preclustering and executes directly on the entire database. As a result, for large databases, DBSCAN could incur substantial I/O costs. Finally, with density-based al- gorithms, using random sampling to reduce the input size may not be feasible - the reason for this is that unless sample sizes are large, there could be substantial variations in the density of points within each cluster in the random sample. "},{"aspect":"expintro","tweet":" In this section, we study the performance of CURE and demonstrate its effectiveness for clustering compared to BIRCH 80 and MST\u201aÄô (minimum spanning tree). From our experimen- tal results, we establish that BIRCH fails to identify clusters with non-spherical shapes (e.g., elongated) or wide variances in size. MST is better at clustering arbitrary shapes, but is very sensitive to outliers. CURE can discover clusters with interesting shapes and is less sensitive (than MST) to outliers. Sampling and partitioning, together, constitute an ef- fective scheme for preclustering - they reduce the input size for large data sets without sacrificing the quality of clustering. The execution time of CURE is low in practice. Sampling and our outlier removal algorithm do a good job at filtering outliers from data sets. Our final labeling phase labels the data residing on disk correctly even when clusters are non-spherical. In our experiments, in addition to CURE, we consider BIRCH and MST. We first show that, for data sets contain- ing elongated or big and small clusters, both BIRCH and MST fail to detect the clusters while CURE discovers them with appropriate parameter settings. We then focus on ana- lyzing the sensitivity of CURE to parameters like the shrink factor Q: and the random sample size s. Finally, we com- pare the execution times of BIRCH and CURE on a data set from [ZRL96], and present the results of our scale-up experiments with CURE. In all of our experiments, we use euclidean distance as the distance metric. We performed experiments using a Sun Ultra-2/200 machine with 512 MB of RAM and running Solaris 2.5. Due to lack of space, we do not report all our experi- mental results - these can be found in [GRS97]. Also, the clusters in the figures in this section were generated using our labeling algorithm and visualizer. Our visualizer assigns a unique color to each cluster\u201aÄô. "},{"aspect":"problemdef","tweet":""},{"aspect":"solution","tweet":" 3 Hierarchical Clustering Algorithm In this section, we present CURE\u201aÄôs hierarchical clustering algorithm whose salient features are: (1) the clustering al- gorithm can recognize arbitrarily shaped clusters (e.g., el- lipsoidal), (2) the algorithm is robust to the presence of outliers, and (3) the algorithm has linear storage require- ments and time complexity of O(n\u201aÄô) for low-dimensional data. The n data points input to the algorithm are either a sample drawn randomly from the original data points, or a subset of it if partitioning is employed. An analysis of issues related to the size of the random sample and number of partitions is presented in Section 4. 3.1 Intuition and Overview The clustering algorithm starts with each input point as a separate cluster, and at each successive step merges the closest pair of clusters. In order to compute the distance between a pair of clusters, for each cluster, c representative points are stored. These are determined by first choosing c well scattered points within the cluster, and then shrinking them toward the mean of the cluster by a fraction a\u201aÄô. The distance between two clusters is then the distance between the closest pair of representative points - one belonging to each of the two clusters. Thus, only the representative points of a cluster are used to compute its distance from other clusters. The c representative points attempt to capture the phys- ical shape and geometry of the cluster. Furthermore, shrink- ing the scattered points toward the mean by a factor cy gets rid of surface abnormalities and mitigates the effects of out- liers. The reason for this is that outliers typically will be further away from the cluster center, and as a result, the shrinking would cause outliers to move more toward the cen- ter while the remaining representative points would experi- ence minimal shifts. The larger movements in the outliers would thus reduce their ability to cause the wrong clusters to procedure cluster(S, Ic) begin 1. T := buildkd-tree(S) 2. Q := build-heap(S) 3. 4. 5. 6. 7. 8. 9. 10. 11. 12. 13. 14. 15. 16. 17. 18. 19. 20. 21. 22. 23. 24. 25. while size(Q) > Ic do { 26. j end u := extractmin(Q) v := uclosest delete(Q, w) w := merge(u, w) deleterep(T, u); deleterep(T, v); insert-rep@\u201aÄò, w) w.closest := x /\u201aÄù x is an arbitrary cluster in Q */ for each x E Q do { if dist(w,x) < dist(w, wclosest) wclosest := z if zclosest is either u or v { if dist(z, xclosest) < dist(x, w) z.closest := closest-cluster(T, else z.closest := w Z, dist(z, w)) relocate(Q, Z) I else if dist(z, z.closest) > dist(z, w) { z.c1osest := w relocate(Q, x) > 1 insert(Q, w) Figure 5: Clustering algorithm be merged. The parameter ~1 can also be used to control the shapes of clusters. A smaller value of CY shrinks the scattered points very little and thus favors elongated clusters. On the other hand, with larger values of a, the scattered points get located closer to the mean, and clusters tend to be more compact. 3.2 Clustering Algorithm In this subsection, we describe the details of our cluster- ing algorithm (see Figure 5). The input parameters to our algorithm are the input data set S containing n points in d- dimensional space and the desired number of clusters k. As we mentioned earlier, starting with the individual points as individual clusters, at each step the closest pair of clusters is merged to form a new cluster. The process is repeated until there are only k remaining clusters. Data Structures: With every cluster is stored all the points in the cluster. Also, for each cluster U, u.mean and u.rep store the mean of the points in the cluster and the set of c representative points for the cluster, respectively. For a pair of points p, q, dist(p,q) denotes the distance between the points. This distance could be any of the L, metrics like LI (\u201aÄúmanhattan\u201aÄù) or Lz (\u201aÄúeuclidean\u201aÄù) metrics. Alternatively, nonmetric similarity functions can also be used. The dis- tance between two clusters u and u can then be defined as dist(,u, II) = peu.r~,i$~.repdist(p\u201aÄô \u201aÄò) For every cluster U, we keep track of the cluster closest to it in u.closest. 77 procedure merge(u, u) begin 1. w:=nUv 3. tmpSet := 0 IUlflUl 4. for i := 1 to c do { 5. maxDist := 0 6. foreach point p in cluster w do { 7. ifi=l 8. minDist := dist(p, w.mean) 9. else 10. minDist := min{dist(p, q) : q E tmpSet} 11. if (minDist 2 maxDist){ 12. maxDist := minDist 13. maxPoint := p 14. 15. } 1 16. 17. } tmpSet := tmpSet U {maxPoint} 18. foreach point p in tmpSet do 19. w.rep := w.rep U {p + cw*(w.mean-p) } 20. return end w Figure 6: Procedure for merging clusters The algorithm makes extensive use of two data struc- tures - a heap[CLRSO] and a k-d tree[Sam90]. Furthermore, corresponding to every cluster, there exists a single entry in the heap - the entries for the various clusters u are arranged in the heap in the increasing order of the distances between u and uclosest. The second data structure is a k-d tree that stores the representative points for every cluster. The k-d tree is a data structure for efficiently storing and retriev- ing multi-dimensional point data. It is a binary search tree with the distinction that a different key value is tested at each level of the tree to determine the branch to traverse further. For example, for two dimensional data points, the first dimension of the point is tested at even levels (assum- ing the root node is level 0) while the second dimension is tested at odd levels. When a pair of clusters is merged, the k-d tree is used to compute the closest cluster for clusters that may previously have had one of the merged clusters as the closest cluster. Clustering procedure: Initially, for each cluster u, the set of representative points w..rep contains only the point in the cluster. Thus, in Step 1, all input data points are inserted into the k-d tree. The procedure buildheap (in Step 2) treats each input point as a separate cluster, com- putes uclosest for each cluster u and then inserts each clus- ter into the heap (note that the clusters are arranged in the increasing order of distances between u and wclosest). Once the heap Q and tree T are initialized, in each it- eration of the while-loop, until only k clusters remain, the closest pair of clusters is merged. The cluster u at the top of the heap Q is the cluster for which u and uxlosest are the closest pair of clusters. Thus, for each step of the while- loop, extractmin (in Step 4) extracts the top element u in Q and also deletes u from Q. The merge procedure (see Figure 6) is then used to merge the closest pair of clusters u and u, and to compute new representative points for the new merged cluster w which are subsequently inserted into T (in Step 8). The points in cluster w are simply the union of the points in the two clusters u and w that were merged. The merge procedure, in the for-loop (Steps 4-17), first iteratively selects c well-scattered points. In the first iteration, the point farthest from the mean is chosen as the first scattered point. In each subsequent iteration, a point from the cluster w is chosen that is farthest from the previously chosen scattered points. The points are then shrunk toward the mean by a fraction Q in Step 19 of the merge procedure. For the merged cluster w, since the set of representative points for it could have changed (a new set of representative points is computed for it), we need to compute its distance to every other cluster and set w.closest to the cluster closest to it (see Steps 11 and 12 of the cluster procedure). Similarly, for a different cluster z in Q, z.closest may change and z may need to be relocated in Q (depending on the distance between z and zclosest). A brute-force method for determining the closest cluster to z is to compute its distance with every other cluster (including w). However, this would require O(n) steps for each cluster in Q, and could be computationally expensive and inefficient. Instead, we observe that the expensive computation of determining the closest cluster is not required for every cluster IC. For the few cases that it is required, we use T to determine this efficiently in O(log n) steps per case. We can classify the clusters in Q into two groups. The first group of clusters are those who had either 2~ or v as the closest cluster before u and 21 were merged. The remaining clusters in Q constitute the second group. For a cluster x in the first group, if the distance to w is smaller than its distance to the previously closest cluster (say n), then all we have to do is simply set w to be the closest cluster (see Step 17). The reason for this is that we know that the distance between x and every other cluster is greater than the distance between z and 1~. The problem arises when the distance between x and w is larger than the distance between x and u. In this case, any of the other clusters could become the new closest cluster to x. The procedure closest-cluster (in Step 15) uses the tree T to determine the closest cluster to cluster 2. For every point p in xrep, T is used to determine the nearest neighbor to p that is not in z.rep. From among the nearest neighbors, the one that is closest to one of x\u201aÄôs representative points is determined and the cluster containing it is returned as the closest cluster to x. Since we are not interested in clusters whose distance from z is more than dist(z,w), we pass this as a parameter to closest-cluster which uses it to make the search for nearest neighbors more ef%icient. Processing a cluster z in the second group is much simpler ~ z.closest already stores the closest cluster to 2 from among existing clusters (except w). Thus, if the distance between x and w is smaller than x\u201aÄôs distance to it\u201aÄôs previously closest cluster, x.closest, then w becomes the closest cluster to x (see Step 21); otherwise, nothing needs to be done. In case z.closest for a cluster z is updated, then since the distance between Z-C and its closest cluster may have changed, x may need to be relocated the heap Q (see Steps 18 and 22). in An improved merge procedure: In the merge procedure, the overhead of choosing representative points for the merged cluster can be reduced as follows. The merge procedure, in the outer for-loop (Step 4), chooses c scattered points from among all the points in the merged cluster w. Instead, sup- pose we selected the c scattered points for w from the 2c scattered points for the two clusters \u201aÄòu. and u being merged (the original scattered points for clusters 1~ and 2) can be obtained by unshrinking their representative points by 0). 78 Then, since at most 2c points, instead of O(n) points, need to be examined every time a scattered point is chosen, the complexity of the merge procedure reduces to O(1). Fur- thermore, since the scattered points for w are chosen from the original scattered points for clusters u and v, they can be expected to be fairly well spread out. 3.3 Time and Space Complexity The worst-case time complexity of our clustering algorithm can be shown to be O(n2 logn). In [GRS97], we show that when the dimensionality of data points is small, the time complexity further reduces to O(n2). Since both the heap and the /c-d tree require linear space, it follows that the space complexity of our algorithm is O(n). 4 Enhancements for Large Data Sets Most hierarchical clustering algorithms, including the one presented in the previous subsection, cannot be directly ap- plied to large data sets due to their quadratic time complex- ity with respect to the input size. In this section, we present enhancements and optimizations that enable CURE to han- dle large data sets. We also address the issue of outliers and propose schemes to eliminate them. 4.1 Random Sampling In order to handle large data sets, we need an effective mech- anism for reducing the size of the input to CURE\u201aÄôs cluster- ing algorithm. One approach to achieving this is via random sampling - the key idea is to apply CURE\u201aÄôs clustering algo- rithm to a random sample drawn from the data set rather than the entire data set. Typically, the random sample will fit in main-memory and will be much smaller than the orig- inal data set. Consequently, significant improvements in execution times for CURE can be realized. Also, random sampling can improve the quality of clustering since it has the desirable effect of filtering outiiers. Efficient algorithms for drawing a sample randomly from data in a file in one pass and using constant space are pro- posed in [Vit85]. As a result, we do not discuss sampling in any further detail, and assume that we employ one of the well-known algorithms for generating the random sample. Also, our experience has been that generally, the overhead of generating a random sample is very small compared to the time for performing clustering on the sample (the random sampling algorithm typically takes less than two seconds to sample a few thousand points from a file containing hundred thousand or more points). Of course, one can argue that the reduction in input size due to sampling has an associated cost. Since we do not con- sider the entire data set, information about certain clusters may be missing in the input. As a result, our clustering algo- rithms may miss out certain clusters or incorrectly identify certain clusters. Even though random sampling does have this tradeoff between accuracy and efficiency, our experi- mental results indicate that for most of the data sets that we considered, with moderate sized random samples, we were able to obtain very good clusters. In addition, we can use chernoff bounds to analytically derive values for sample sizes for which the probability of missing clusters is low. We are interested in answering the following question: what should the size s of the random sample be so that the probability of missing clusters is low ? One assumption that we will make is that the probability of missing a cluster u is low if the sample contains at least flu] points from the sample, where 0 5 f 5 1. This is a reasonable assumption to make since clusters will usually be densely packed and a subset of the points in the cluster is all that is required for clustering. Furthermore, the value of f depends on the cluster density as well as the intercluster separation - the more well-separated and the more dense clusters become, the smaller is the fraction of the points from each cluster that we need for clustering. Chernoff bounds [MR95] can be used to prove the following theorem. Theorem 4.1: For o. cluster IL, if the sample size s satisfies s L .frv + fi log(i) + ; a d (log(+))\u201aÄô + 2flul log($) (1) then the probability that the sample contains fewer than flui points belonging to cluster IL is less than 6, 0 5 6 5 1. m Proof: See [GRS97]. u Thus, based on the above equation, we conclude that for the sample to contain at least flu] points belonging to clus- ter \u201aÄòu. (with high probability), we need the sample to contain more than a fraction f of the total number of points - which seems intuitive. Also, suppose 2~~;~ is the smallest cluster that we are interested in, and snLln is the result of substi- tuting ]umzn] for ]u] in the right hand side of Equation (1). It is easy to observe that Equation (1) holds for s = smzn and all I$ 2 ]~~mzn]. Thus, with a sample of size smzn, we can guarantee that with a high probability, 1 - 6, the sam- ple contains at least flu] points from an arbitrary cluster \u201aÄò1~. Also, assuming that there are k clusters, with a sample size of Sml.n, the probability of selecting fewer than flu] points from any one of the clusters u is bounded above by lc6. 4.2 Partitioning for Speedup As the separation between clusters decreases and as clus- ters become less densely packed, samples of larger sizes are required to distinguish them. However, as the input size n grows, the computation that needs to be performed by CURE\u201aÄôs clustering algorithm could end up being fairly sub- stantial due to the O(n2 log n) time complexity. In this sub- section, we propose a simple partitioning scheme for speed- ing up CURE when input sizes become large. The basic idea is to partition the sample space into p partitions, each of size %. We then partially cluster each partition until the final number of clusters in each partition reduces to 5 for some constant q > 1. Alternatively, we could stop merging clusters in a partition if the distance be- tween the closest pair of clusters to be merged next increases above a certain threshold. Once we have generated $ clus- ters for each partition, we then run a second clustering pass on the s partial clusters for all the partitions (that resulted from the first pass). The idea of partially clustering each partition achieves a sort of yeclustering - schemes for which were also pro- posed in [ZRL96]. The preclustering algorithm in [ZRL96] is incremental and scans the entire data set. Each successive data point becomes part of the closest existing cluster if it is within some threshold distance r from it - else, it forms a new cluster. Thus, while [ZRL96] applies an incremen- tal and approximate clustering algorithm to all the points, CURE uses it\u201aÄôs hierarchical clustering algorithm only on the points in a partition. In some abstract sense, CURE\u201aÄôs parti- tioning scheme behaves like a sieve working in a bottom-up 79 fashion and filtering out individual points in favor of partial clusters that are then processed during the second pass. The advantage of partitioning the input in the above mentioned fashion is that we can reduce execution times by a factor of approximately 5 + 5. The reason for this is that the complexity of clustering any one partition is O(( 4=\u201aÄú) log F) since the number of points per parti- tion i,\u201aÄù z &d the number of merges that need to be per- formed for the number of clusters to reduce to & is F(y). Since there are p such partitions, the complexity of the first pass becomes 0($(y) log $). The time complexity of clustering the : clusters in the second pass is 0( $ log i). Thus, the complexity of CURE\u201aÄôs partitioning algorithm is o($(+og; + $log5), which corresponds to an im- provement factor of approximately * + $ over clustering without partitioning. An important point to note is that, in the first pass, the closest points in each partition are merged only until the final number of clusters reduces to 2. By ensuring that $ is sufficiently large compared to the number of desired clusters, k, we can ensure that even though each partition contains fewer points from each cluster, the closest points merged in each partition generally belong to the same cluster and do not span clusters. Thus, we can ensure that partitioning does not adversely impact clustering quality. Consequently, the best values for p and q are those that maximize the improvement factor 5 + -$ while ensuring that E is at least 2 or 3 times k. The partitioning scheme can also be employed to ensure that the input set to the clustering algorithm is always in main-memory even though the random sample itself may not fit in memory. If the partition size is chosen to be smaller than the main-memory size, then the input points for clus- tering during the first pass are always main-memory resi- dent. The problem is with the second pass since the size of the input is the size of the random sample itself. The reason for this is that for every cluster input to the second cluster- ing pass, we store all the points in the cluster. Clearly, this is unnecessary, since our clustering algorithm only relies on the representative points for each cluster. Furthermore, the improved merge procedure in Section 3 only uses representa- tive points of the previous clusters when computing the new representative points for the merged cluster. Thus, by stor- ing only the representative points for each cluster input to the second pass, we can reduce the input size for the second clustering pass and ensure that it fits in main-memory. 4.3 Labeling Data on Disk Since the input to CURE\u201aÄôs clustering algorithm is a set of randomly sampled points from the original data set, the fi- nal k clusters involve only a subset of the entire set of points. In CURE, the algorithm for assigning the appropriate clus- ter labels to the remaining data points employs a fraction of randomly selected representative points for each of the final k clusters. Each data point is assigned to the cluster containing the representative point closest to it. Note that approximating every cluster with multiple points instead a single centroid as is done in [ZRL96], enables CURE to, in the final phase, correctly distribute the data points when clusters are non-spherical or non-uniform. The final labeling phase of [ZRLSG], since it employs only the cen- troids of the clusters for partitioning the remaining points, has a tendency to split clusters when they have non-spherical shapes or non-uniform sizes (since the space defined by a single centroid is a sphere). 4.4 Handling Outliers Any data set almost always contains o&hers. These do not belong to any of the clusters and are typically defined to be points of non agglomerative behavior. That is, the neighbor- hoods of outliers are generally sparse compared to points in clusters, and the distance of an outlier to the nearest cluster is comparatively higher than the distances among points in bon&de clusters themselves. Every clustering method needs mechanisms to eliminate outliers. In CURE, outliers are dealt with at multiple steps. First, random sampling filters out a majority of the outliers. Furthermore, the few outlicrs that actually make it into the random sample are distributed all over the sample space. Thus, random sampling further isolates outliers. In agglomerative hierarchical clustering, initially each point is a separate cluster. Clustering then proceeds by merging closest points first. What this suggests is that out- liers, due to their larger distances from other points, tend to merge with other points less and typically grow at a much slower rate than actual clusters. Thus, the number of points in a collection of outliers is typically much less than the num- ber in a cluster. This leads us to a scheme of outlier elimination that pro- ceeds in two phases. In the first phase, the clusters which are growing very slowly are identified and eliminated as outliers. This is achieved by proceeding with the clustering for some time until the number of clusters decreases below a certain fraction of the initial number of clusters. At this time, we classify clusters with very few points (e.g., 1 or 2) as out- liers. The choice of a value for the fraction of initial clusters at which outlier elimination gets triggered is important. A very high value for the fraction could result in a number of cluster points being incorrectly eliminated - on the other hand, with an extremely low value, outliers may get merged into proper clusters before the elimination can kick in. An appropriate value for the fraction, obviously, is dependent on the data set. For most data sets we considered, a value of around i performed well. The first phase of outlier elimination is rendered ineffec- tive if a number of outliers get sampled in close vicinity - this is possible in a randomized algorithm albeit with low probability. In this case, the outliers merge together pre- venting their elimination, and we require a second level of pruning. The second phase occurs toward the end. Usually, the last few steps of a clustering are the most important ones, because the granularity of the clusters is very high, and a single mistake could have grave consequences. Conse- quently, the second phase of outlier elimination is necessary for good clustering. From our earlier discussion, it is easy to observe that outliers form very small clusters. As a result, we can easily identify such small groups and eliminate them when there are very few clusters remaining, typically in the order of k, the actual number of clusters desired. We have found the above two-phase approach to outlier elimination to work very well in practice. "},{"aspect":"expcomparison","tweet":" 5.5 Comparison of Execution time to BIRCH The goal of our experiment in this subsection is to demon- strate that using the combination of random sampling and partitioning to reduce the input size as is done by CURE can result in lower execution times than the preclustering scheme employed by BIRCH for the same purpose. We run both BIRCH and CURE on Data set 2 - this is the data set that centroid-based algorithms, in general, and BIRCH, in particular, can cluster correctly since it contains com- pact clusters with similar sizes. CURE, too, finds the right clusters with a random sample size of 2500, o = 1 (which reduces CURE to a centroid-based algorithm), one represen- tative for each cluster (that is, the centroid), and as many as 5 partitions. ? 120 8 s. 100 if 80 i= (a) a = 0.1 (a) c = 2 (b) cy = 0.2 - 0.7 (c) cy = 0.8 - 0.9 Figure 9: Shrink factor toward centroid (b) c = 5 (c) c = 10 Figure 10: Representatives of clusters *... BIRCH -- CURE (p = 1) -----x--- CURE (P = \u201aÄò4 CURE(P=5) a-. _I 200000 300000 400000 500000 Number of Points Figure 11: Comparison to BIRCH Figure 11 illustrates the performance of BIRCH and CURE as the number of data points is increased from 100000 to 500000. The number of clusters or their geometry is not altered - thus, each cluster becomes more dense as the num- ber of points increases. For CURE, we consider three values for the number of partitions: 1, 2 and 5, in order to show the effectiveness of partitioning. The execution times do not include the time for the final labeling phase since these 83 are approximately the same for BIRCH and CURE, both of which utilize only the cluster centroid for the purpose of labeling. As the graphs demonstrate, CURE\u201aÄôs execution times are always lower than BIRCH\u201aÄôs, In addition, partitioning fur- ther improves our running times by more than 50%. Finally, as the number of points is increased, execution times for CURE increase very little since the sample size stays at 2500, and the only additional cost incurred by CURE is that of sampling from a larger data set. In contrast, the executions times for BIRCH\u201aÄôs preclustering algorithm increases much more rapidly with increasing data set size. This is because BIRCH scans the entire database and uses all the points in the data set for preclustering. Thus, the above results con- firm that our proposed random sampling and partitioning algorithm are very efficient compared to the preclustering technique used in BIRCH. "}]}