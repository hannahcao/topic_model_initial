{"user_name":" ï»¿Efficiently Mining Long Patterns from Databases ","user_timeline":[{"aspect":"abstract","tweet":" Abstract We present a pattern-mining algorithm that scales roughly linearly in the number of maximal patterns embedded in a database irrespective of the length of the longest pattern. In comparison, previous algorithms based on Apriori scale exponentially with longest pattern length. Experiments on real data show that when the patterns are long, our algorithm is more efficient by an order of magnimaximal frequent itemset, Max-Miner\u201a€™s output implicitly and concisely represents all frequent itemsets. Max-Miner is shown to result in two or more orders of magnitude in performance improvements over Apriori on some data-sets. On other data-sets where the patterns are not so long, the gains are more modest. In practice, Max-Miner is demonstrated to run in time that is roughly linear in the number of maximal frequent itemsets and the size of the database, irrespective of the size of the longest frequent itemset. tude or more. "},{"aspect":"expanalysis","tweet":"  6.2 Max-Miner Scaling For every data set at the support levels we looked at, the lower the support, the more maximal-frequent patterns were found. Figure 14 plots the amount of time spent by Max-Miner per maximal frequent itemset against the number of maximal frequent itemsets found during a given run of the algorithm. The support values used to generate this data are the same ones that appear in the previous graphs. Max-Miner\u201a€™s performance per maximal frequent itemset remains relatively constant as the number of maximal frequent itemsets increases, even though the size of the longest itemsets varies significantly. For instance, for the pumsb* data set, the Jeft- most point arises from a run at 35% support where the longest frequent itemsets contain I5 items. The right-most point is for a run at 5% support where the longest frequent itemsets contain 40 items. Even so, the performance per maximal frequent itemset varies no more than 25%, indicating Max-Miner is scaling roughly linearly with the number of maximal frequent itemsets. The chess data-set exhibits the most non-linear increase in difficulty with the number of maximal frequent itemsets, though this increase is still relatively subdued (within a factor of 2.5) considering the large increase in the number of maximal Frequent itemsets and their length. It is possible that the curve for the chess data-set would begin to decrease had we mined at even lower levels of support. We were unable to determine this because of the explosion in the number of maximal frequent itemsets at low supports -- already there are over half a million maximal frequent itemsets at a minsup of 20%. The other data-sets all begin to get easier as the number of maximal frequent patterns increases beyond some point. This is certainly in part due to the fact that itemsets with lower support incur less overhead since they are contained by fewer database transactions. However, as support decreases, maximal frequent itemsets become longer, which leads to an increase in storage and indexing overhead. Figure 15. Number of candidate groups considered per maximal frequent itemset. 700000 cl-lez=x c 600000 500000 t 400000 - u - 300000 - : I 200000 - 100000 - fi ,m' 7 P 0 0 100000 200000 300000 400000 500000 6OOOOC IMI / 91 To remove the effect of indexing and support-counting overhead on runtime scaling, and to demonstrate how Max-Miner scales in its space consumption, we also compared the number of candidate groups whose support was counted to the number of maximal frequent sets identified (Figure 15)\u201a€˜. For every data-set there is a strong linear relationship. In fact, the number of candidates considered is always within a small (at most 3.7 on pumsb*) constant of the number of maximal frequent itemsets. Figure 16. Database passes performed by Max-Miner compared to the longest frequent itemset. 40 - 35 - chess +< connect. q..L . . . pqrjb'i .o.-.- - 30 t ssdice ny.droom ..\u201a€™ : retail * -- - -=.- i 5 10 15 20 25 30 35 40 Length of longest pattern Figure I6 plots the number of database passes performed by Max- Miner against the length of the longest patterns identified during each run. The worst-case number of passes is represented by the diagonal. While the number of database passes increases with pattern length, it is usually far from the worst-case. Though not illustrated, Apriori-LB was often able to skip one or two database passes because all candidates were lower-bounded above minsup. This had a relatively small effect on performance compared to the amount of reduction in overhead from computing the support of fewer candidates. The reductions in database passes tended not to have as dramatic an effect on performance as might be expected from experiments on small-pattern data because the overhead of candidate itemset lookup largely exceeded that of data access. 6.3 Effects of Max-Miner Optimizations Support lower-bounding is a beneficial optimization on the datasets with long patterns for Max-Miner as well as Apriori. For example, after turning off support lower-bounding, Max-Miner\u201a€™s performance dropped by approximately four-fold at all levels of support on the chess data-set due to a four-fold increase in the number of candidate groups to be counted. On the retail data-set, the optimization\u201a€™s effects were negligible. The item-(re)ordering heuristic was beneficial, usually dramatically so, on every data-set we looked at. For example, at 80% support on the chess data set, turning off item ordering (which caused the algorithm to default to a static lexical item ordering) resulted in an order of magnitude decrease in performance, with the performance gap widening even further as support was decreased. The decrease in performance was due to an increase in candidate groups resulting primarily from less opportunities for superset-frequency pruning. The plot for the connect-4 data-set is difficult to make out because it lies directly along the lower-left portion of the plot for chess. Figure 17. Performance of Max-Miner-LO 10000 0 1000 : I \u201a€˜2 E 100 10 chess + connect - 4 -*---- pumsb 0 pumsb' * 10 1 0.1 support (%) 6.4 Max-Miner-LO Figure 17 shows the runtime of Max-Miner-LO on the data sets with the longest frequent itemsets. We chose very low support values for these runs to illustrate how additional constraints can make mining feasible even when the number of maximal frequent itemsets is too large. Note that Max-Miner-LO can mine on the pumsb data-set without removing items with 80% or more support. The longest frequent itemsets in pumsb at .I % support contain 72 items. Frequent itemsets were very long even at 10% support where they contained 61 items. For most of these data points, the number of longest frequent itemsets was under 300.  "},{"aspect":"expdata","tweet":"  6. Evaluation We selected data-sets from several domains for evaluating the performance of Max-Miner, all but one of them being publicly accessible through the web. The data-set that is not publicly available was provided by a retailer. This data-set contains records listing all of the items purchased by a customer over a period of time. We produced another of our data-sets from PUMS census data available at http://augustus.csscr.washington.edu/census/ camp-Ol3.html. Following Brin et al. [6], we discretized continuous attributes and removed uninformative attributes. We created another version of the data-set where all items with 80% or greater support were discarded. The raw data from the web consists of both housing and person records, but we extracted only the person records. The remaining data-sets used in our evaluation were taken from the Irvine Machine Learning Database Repository (http:Nwww,ics.uci.edu/-mleam/MLRepository.html). We favored those with categorically-valued attributes, relatively wide record length, and a substantial number of records. These data-sets include connect-4, chess, splice, and mushroom. The splice data set contains DNA data, the mushroom database contains records describing the characteristics of various mushroom species, and Connect-4 and chess are compiled from game state information. Table 1 lists the width and height of each of these data-sets. Pumsb* is the same data set as pumsb minus all items with 80% or more support. Table 1. Width and height of the evaluation data-sets. Data-set Records Avg. Record Width chess 3,196 37 connect-4 67,557 43 mushroom 8,124 23 pumsb 49,046 74 pumsb* 49,046 50 retail 213,972 31 splice 3,174 61 The data-set with the longest patterns was pumsb. This data-set also had the most maximal frequent patterns -- intractably many even at relatively high levels of support. We thus focus on pumsb* for evaluating Max-Miner, and use pumsb only to evaluate Max- Miner-LO. Even though items with 80% or more support are removed, pumsb* still a challenging data set with long frequent itemsets. A similar but smaller data-set was used by Brin et al. to evaluate DIC, though only at supports of 36% and higher. Their data-set was not available to us at the time of this writing, so we created pumsb* to use in its place.  "},{"aspect":"background","tweet":" 1. Introduction Finding patterns in databases is the fundamental operation behind several common data-mining tasks including association rule [l] and sequential pattern mining [4]. For the most part, pattern mining algorithms have been developed to operate on databases where the longest patterns are relatively short. This leaves data outside this mold unexplorable using current techniques. Interesting data-sets with long patterns include those composed of questionnaire results (oeople tend to answer similarly to many questions), sales transactions detailing the purchases made by regular customers over a laree time window. and biological data from the fields of DNA and- protein analysis. Most categorically-valued data-sets used for classification problems (e.g. targeted marketing campaigns) also tend to have long patterns because they contain many frequently occurring items and have a wide average record length. Almost every recently-proposed pattern-mining algorithm is a variant of Apriori [2]. Two recent papers have demonstrated that Apriori-like algorithms are inadequate on data-sets with long patterns. Brin et al. [6] applied their association-rule miner DIC to a data-set composed of PUMS census records. To reduce the difftculty of this data-set, they removed all items appearing in over 80% of the transactions yet still could only mine efficiently at high support. We [5] previously applied an Apriori-inspired algorithm to several data-sets from the Irvine Machine Learning Database Repository. In order to mine efftciently, this algorithm had to sometimes apply pruning strategies that rendered the search incomplete. Apriori involves a phase for finding patterns called frequent itemsets. A frequent itemset is a set of items appearing together in a number of database records meeting a user-specified threshold. Apriori employs a bottom-up search that enumerates every single frequent itemset. This implies in order to produce a frequent itemset of length 1, it must produce all 2\u201a€™ of its subsets since they too must be frequent. This exponential complexity fundamentally restricts Apriori-like algorithms to discovering only short patterns. To address this problem, this paper proposes the Max-Miner algorithm for efftciently extracting only the maximal frequent itemsets, where an itemset is maximal frequent if it has no superset that is frequent. Because any frequent itemset is a subset of a Max-Miner is successful because it abandons a strict bottom-up traversal of the search space, and instead always attempts to \u201a€œlook ahead\u201a€ in order to quickly identify long frequent itemsets. By identifying a long frequent itemset early on, Max-Miner can prune all its subsets from consideration. Max-Miner uses a heuristic to tune its search in an effort to identify long frequent itemsets as early as possible. It also uses a technique that can often determine when a new candidate itemset is frequent before accessing the database. The idea is to use information gathered during previous database passes to compute a good lower-bound on the number of transactions that contain the itemset. The techniques we introduce in this paper are flexible and can be extended in various ways and applied to other algorithms. To demonstrate this point, we optimize Apriori with the lowerbounding technique mentioned above. While the fundamental limitations of Apriori with respect to pattern length remain, performance is improved by an order of magnitude on several datasets. We also show how Max-Miner can be extended to exploit additional pattern constraints during its search by creating a variant that identities only the longest of the maximal frequent itemsets in a data-set. This algorithm efficiently identifies all of the longest maximal frequent itemsets even when the space of all maximal frequent itemsets is itself intractably large. 1.1 Related Work There are many variants of Apriori that differ in how they check \u201a€œcandidate\u201a€ itemsets against the database. Aoriori in its purest form checks itemsets of length I for frequency during database pass 1. DIC r61 is more eaeer and beeins checkine an itemset shortlv after all its\u201a€™ subsets have\u201a€been det&rnined freqient, rather than waiting until the database pass completes. Partition [I l] identifies all frequent-itemsets in memory-sized partitions of the database, and then checks these against the entire database during a final pass. DIC considers the same number of candidate itemsets as Apriori, and Partition can consider more but never fewer candidate itemsets than Apriori, potentially exacerbating problems associated with long patterns. Park et al. [9] enhance Apriori with a hashing scheme that can identify (and thereby eliminate from consideration) some candidates that will turn up infrequent if checked against the database. It also uses the hashing scheme to re-write a smaller database after each pass in order to reduce the overhead of subsequent passes. Still, like Apriori, it considers every frequent itemset. Permission to make digital or hard copiaa of all or part of this work for perwmal or olsswoom usa ia granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copier bear this notice and the full citation on the firat pa&f.. To copy otherwise, to republish, to port on servers or to redistribute to lirts. requiroe prior specific permieoion and/or a fee. SIGMOD \u201a€˜98 Seattle. WA, USA Q 1996 ACM 0-89791-995-5/98/006...85.00 Gunopulos et al. [7] present a randomized algorithm for identifying maximal frequent itemsets in memory-resident databases. Their algorithm works by iteratively attempting to extend a working pattern until failure. A randomized version of the algorithm that does not guarantee every maximal frequent itemset will be returned is evaluated and found to efftciently extract long frequent itemsets. Unfortunately, it is not clear how this algorithm would be scaled to disk resident data-sets since each attempt at extending an itemset requires a scan over the data. It also remains to be seen how the 85 proposed complete version of the algorithm would perform in practice. Zaki et al. 1161 present the algorithms MaxEclat and MaxClique for identifying maximal frequent itemsets. These algorithms are similar to Max-Miner in that they also attempt to look ahead and identify long frequent itemsets early on to help prune the space of candidate itemsets considered. The important difference is that Max-Miner attempts to look ahead throughout the search,, whereas MaxEclat and MaxCliaue look ahead onlv durine an inmalization phase prior to a p&ely bottom-up Apriori-Kke search with exponential scaling. The initialization phase of MaxEclat is also prone to problems with long frequent itemsets since it uses a dynamic programming algorithm for finding maximal cliques in a graph whose largest clique is at least as large as the length of the longest frequent itemset. Concurrent to our work, Lin and Kedem [8] have proposed an algorithm called Pincer-Search for mining long maximal frequent itemsets. Like Max-Miner, Pincer-Search attempts to identify long patterns throughout the search. The difference between these algorithms is primarily in the long candidate itemsets considered by each. Max-Miner uses a simple, polynomial time candidate generation procedure directed by heuristics, while Pincer-Search uses an NP-hard reduction phase to ensure no long candidate itemset contains any known infrequent itemset. Our comparison with Pincer-Search is thus far only preliminary, and more work is needed to fully understand the advantages offered by each technique. 1.2 Overview Section 2 begins with an introduction into the basic search strategy used by Max-Miner and the techniques used to restrict the search space. Section 3 formalizes these techniques through pseudo-code, provides implementation details, and establishes Max-Miner\u201a€™s correctness and efficiency characteristics. Section 4 discusses and exploits a technique for lower-bounding the support of candidate itemsets. Section 5 discusses the integration of additional pattern constraints into the search, culminating in a description of the Max-Miner-LO algorithm for finding only the longest maximal frequent itemsets. The algorithms are evaluated experimentally in Section 6 followed by a summary of contributions and avenues for future work in Section 7.  "},{"aspect":"expintro","tweet":"  All experiments were performed on a lightly loaded 200MHz Power-PC with 256 megabytes of RAM. The algorithms were implemented in C++ atop the same optimized hash tree implementation. Apriori and Apriori-LB were optimized for finding only maximal frequent itemsets by having them discard from memory any frequent itemset that was found to be non- maximal. The Max-Miner algorithm evaluated here uses support lower-bounding. In subsection 6.3 we describe the effects of disabling this and other optimizations.  "},{"aspect":"problemdef","tweet":"  2. Introducing Max-Miner We begin with defining the necessary terminology for describing the Max-Miner algorithm. For simplicity of presentation, we will be dealing only with the problem of identifying frequent itemsets. The application of our techniques to finding other patterns (e.g. sequential patterns) is similar. A data-set is a set of transactions that are sets over a finite item domain. Transactions can represent things such as the supermarket items purchased by a customer during a shopping visit, or the characteristics of a person as described by his or her replies in a census questionnaire. A set of items is more succinctly called an itemset, and a frequent itemset is one that is contained in a number of transactions above or equal to the minimum support (minsup) specified by the user. An itemset with k items will be more succinctly referred to as a k -itemset. The support of an itemset I, denoted sup(f), is the number of transactions that contain it. The minsup parameter will sometimes be specified as a percentage of the transactions in the data-set instead of as an absolute number of transactions. Max-Miner can be described using Rymon\u201a€™s generic set- enumeration tree search framework 1101. The idea is to exoand sets over an ordered and finite item domain as illustrated in\u201a€™Figure 1 where four items are denoted by their position in the ordering. The particular ordering imposed on the item domain affects the parent/ child relationships in the set-enumeration tree but not its completeness, The figure assumes a static lexical ordering of the items, hut later we describe an optimization that dramatically improves performance by heuristically ordering the items and 86 dynamically reordering them on a per-node basis. Set-enumeration trees are not data-structures like the hash tree or trie, but instead are used to illustrate how sets of items are to be completely enumerated in a search problem. Note that the tree could be traversed depth-first, breadth first, or even best-first as directed by some heuristic. Max-Miner employs a purely breadth-first search of the set-enumeration tree in order to limit the number of passes made over the data. Figure 1. Complete set-enumeration tree over four items. 1 3 ? A 12 193 I,4 23 2,4 3,4 I I a3 1,3,4 2,3,4 1,2,X4 The key to an efficient set-enumeration search is the pruning strategies that are applied to remove entire branches from consideration. Without pruning, a set-enumeration tree search for frequent itemsets will consider every itemset over the set of all items. Max-Miner uses pruning based on subset infrequency, as does Apriori, but it also uses pruning based on superset frequency. To aid in our pruning efforts, we will represent each node in the set enumeration tree by what we call a candidate group. A candidate group g consists of two itemsets. The first, called the head and denoted h(g) , represents the itemset enumerated by the node. The second itemset, called the tail and denoted t(g), is an ordered set and contains all items not in h(g) that can potentially appear in any sub-node. For example, the node enumerating itemset { 1 } in the figure has h(g) = 11) and t(g) = { 2,3,4} . The ordering of tail items reflect how the sub-nodes are to be expanded. In the case of a static lexical ordering without pruning, the tail of any candidate group is trivially the set of all items following the greatest item in the head according to the item ordering. When we are applying pruning and dynamic item reordering, it becomes necessary to make the tail items explicit. When we say we are counting the support of a candidate group g , we are computing the support of itemsets h(g), h(g) u t(g), and h(g) u {i} for all i E t(g). The supports of itemsets other than h(g) are used for pruning. For example, consider first the itemset h(g) u t(g). Since h(g) u t(g) contains every item that appears in any viable sub-node of g, if it is frequent, then any itemset enumerated by a sub-node will also be frequent but not maximal. Superset-frequency pruning can therefore be implemented by halting sub-node expansion at any candidate group g for which h(g) u t(s) is frequent. Consider next the itemset h(g) u {i} for some i E t(g). If h(g) u { i) is infrequent, then any head of a subnode that contains item i will also be infrequent. Subsetinfrequency prunmg can therefore be implemented by simply removing any such tail item horn a candidate group before expanding its sub-nodes.  3. Formalizing Max-Miner We now provide a pseudo-code description of Max-Miner followed by the motivation behind and description of the item ordering policy. Implementation details describing how Max- Miner can use the same data-structures as Apriori are provided in the following subsection, and the last subsection provides correctness and efficiency arguments. 3.1 Pseudo-Code for Max-Miner The pseudo-code description of Max-Miner appears in figures 2 through 4. The body (Figure 2) accepts a data-set and (implicitly) the minimum support specified by the user. The while loop implements a breadth-first search of the set-enumeration tree that maintains every frequent itemset encountered so long as it is potentially maximal. The function Gen-Initial-Groups (Figure 3) performs the initial scan over the data-set to identify the item domain and seed the search at the second level of the tree. Superset-frequency based pruning is performed by only expanding the sub-nodes of a candidate g if h(g) u l(g) is infrequent. Another instance of superset-frequency pruning is any candidate group g is pruned if h(g) u r(g) is a subset of some alreadyknow-to-be frequent itemset I. Sub-nodes are generated by Gen-Sub-Nodes in Figure 4. Subsetinfrequency pruning is performed here through the removal of any tail item i from a candidate group g if h(g) u {i} is infrequent. Gen-Sub-Nodes and Gen-Initial-Groups return the sub-node with an empty tail as a frequent itemset instead of a candidate group since its frequency is already known and it has no children in the search tree. Figure 2. Max-Miner at its top level. MAX-MrNER(Data-set T) ;; Returns the set of maximalfrequent itemsets present in T Set of Candidate Groups C t { } Set of Itemsets F t {GEN-INITIAL-GROUPS( T, C)} while C is non-empty do scan T to count the support of all candidate groups in C for each g E C such that h(g) u t(g) is frequent do F+-Fu{WutOl Set of Candidate Groups C,,, t { } for each g E C such that h(g) u t(g) is infrequent do F t F u { GEN-SUB-NODES& C,,,)} c + cnew remove from F any itemset with a proper superset in F remove from C any group g such that h(g) u t(g) has a superset in F return F Figure 3, Generating the initial candidate groups. GEN-INITIAL-GROuPS(Data-Set T, Set of Candidate Groups C) ;; C is passed by reference and returns the candidate groups ;; The return value of the function is a frequent I-itemset scan T to obtain F, , the set of frequent I -itemsets impose an ordering on the items in F, ;; see section 3.2 for each item i in F, other than the greatest item do let g be a new candidate with h(g) = {i} and t(g) = Qp follows i in the ordering} CtCukl return the itemset in F, containing the greatest item Figure 4. Generating sub-nodes. GEN-SUB-NODES(Candidate Group g , Set of Cand. Groups C) ;; C is passed by reference and returns the sub-nodes of g ;; The return value of the function is a frequent itemset remove any item i from t(s) if h(g) u {i} is infrequent reorder the items in t(g) ;; see section 3.2 for each i E t(g) other than the greatest do let g\u201a€™ be a new candidate with h(g\u201a€™) = h(g) u {i} and t(s\u201a€™) = Ql j E t(g) andj follows i in t(g)} Ct cu {g\u201a€™) return h(g) u (m} where m is the greatest item in t(g) , or h(g) if t(g) is empty. 87 3.2 Item Ordering Policies The motivation behind item (re)ordering is to increase the effectiveness of superset-frequency pruning. Recall that supersetfrequency pruning can be applied when a candidate group g is found such that h(g) u t(g) is frequent. We therefore want to make it likely that many candidate groups will have this property. A good heuristic for accomplishing this is to force the most frequent items to appear in the most candidate groups. This is simply because items with high frequency are more likely to be part of long frequent itemsets. Items that appear last in the ordering will appear in the most candidate groups. For instance, item 4 from Figure I appears either in the head or tail of every single node. Item ordering is therefore used to position the most frequent items last. Gen-Initial-Groups orders the items in increasing order of sup({ i}) . Items in the tails of candidate groups are re-ordered prior to sub-node generation in Gen-Sub-Nodes. This function orders the tail items of a group g in increasing order of sup(h(g) u (i}) . This strategy tunes the frequency heuristic by having it consider only the subset of transactions relevant to the given node. Interestingly, the same item reordering heuristic is used by Slagel et al. [12] in a set-enumeration algorithm for identifying prime implicants in CNF propositional logic expressions. The fact that the same policy works well for both problems is likely due to their close relationship. Finding prime implicants in CNF expressions is similar to the problem of generating hypergraph transversals, and Gunopulos et al. [7] have previously shown that hypergraph transversal algorithms can be used as a component of an algorithm for mining maximal frequent itemsets. 3.3 Implementation Details Max-Miner can use the same data-structures as Apriori (as detailed in [3]) for efficiently computing itemset supports. The primary data-structure used by Apriori is the hash tree to index candidate itemsets. Max-Miner uses the hash tree to index only the head of each candidate group. For each transaction in the data-set, Max- Miner uses the hash tree to quickly look up all candidate groups whose head appears in the transaction. Then, for each candidate group g identified, it traverses down its tail items one by one, incrementirm the support of h(g) u { i} if tail item i is present in the transacti&. If every tail it% appears in the transaciion, then the support of h(p) u t(n) is also incremented. We found this implementation to%e sut%antially faster than individually storing each itemset within the hash tree. Hash trees are also used by our implementation of Max-Miner for efficiently identifying the subsets of frequent itemsets in F and C . Our implementation of Max-Miner diverges from the pseudo-code description in only one way. During the second pass over the dataset, we use a two-dimensional array for quickly computing the support of all 2-itemsets as suggested in [3], and do not compute the support of the long itemsets h(g) u t(s). We have found that the long itemsets h(g) u t(g) almost always turn up infrequent at this stage, so computing their support offers no benefit. 3.4 Correctness and Effkiency Claims THEOREM (CORRECTNESS): Max-Miner returns all and only the maxima1 frequent itemsets in the given data-set. Proof? The fact that Max-Miner identifies and stores every maximal frequent itemset follows from the completeness of a set-enumeration tree search and the fact that branches of the set-enumeration tree are pruned if and only if they lead to only infrequent itemsets or non-maximal frequent itemsets. The fact that Max-Miner returns only those itemsets that are maximal frequent follows from the operation within the body of Max- Miner that continuously removes any itemset I if a frequent superset of I is known. 0 Max-Miner, like Apriori, easily handles disk-resident data because it requires only one transaction at a time in memory. Also like Apriori, the number of passes over the data made by Max-Miner is bounded by the length of the longest frequent itemset. For Apriori this bound is nearly tight. Max-Miner, on the other hand, often performs substantially fewer database passes, as will be demonstrated in our evaluation. THEOREM (EFFICIENCY): Max-Miner makes at most I+ 1 passes over the data-set, where 1 denotes the length of the longest frequent itemset. Proof We establish the claim by demonstrating why Max-Miner terminates after pass I + 1 if it happens to get that far. By the manner in which Max-Miner generates candidate groups, it is easy to see that during pass k , the head of any candidatk group has exactlv k- I items. After oass l+ I . for anv candidate group g &d any of its tail [terns i, h(g) u {I) will be infrequent otherwise we would have a frequent itemset longer than I. This implies that the next set of candidate groups will be empty, in which case the algorithm terminates. 0  "},{"aspect":"solution","tweet":"  4. Support Lower-Bounding This section first describes a general technique that can be used to obtain a lower-bound on the support of an itemset by exploiting the support information provided by its subsets. The subsequent subsections describe how this technique is used to improve the performance of Max-Miner and Apriori. 4.1 Computing Support Lower-Bounds The idea behind our method of computing a lower-bound on the support of an itemset is to exploit, as much as possible, the available support information provided by its subsets. The following function is useful in this endeavor, as established by the subsequent theorem. The function computes the number of transactions that are \u201a€œdropped\u201a€ from the supporting set of an itemset when it is extended with a given item. DEFIJVITION: drop(l,, i) = sup(/,)-sup@, u (d}) , where i is an item not in itemset I,F . Figure 5. Illustration of support drop resulting from extending itemsets I and I, with i . Because sup(f u {i}) = sup(f)-drop(l, i), we can get a lowerbound on the value of sup(1 u { i}) given the value of sup(I) and an upper-bound on drop(l, i) . This fact is exploited by our next theorem. THEOREM (SUPPORT LOWER-BOUNDING): sup(l) - drop(l., i) is a lower-bound on the support of items&t I J ii} when\u201a€˜f. & I, Proof We show that drop(I.. i) is an unner-bound on &oD(I. i) fcom which the claim %db&s. The argument is geomet& &h is illustrated in Figure 5. The outer square represents the space of all transactions supporting itemset I,, and the inner square the space of all transactions supporting ltemset I. Because the space occupied by I is entirely contained within the space occupied by Z,, , the set of transactions dropped by extending itemset I with i must be a subset of the transactions dropped by extending itemset I, with i . The fact that drop(l,, i) is an upper-bound on drop(d i) is immediate. 0 The support lower-bounding theorem, as stated, can only be annlied to lower-bound the SUDDO~~ of a k-itemset if we have the s;pport of one of its k- I item subsets. Below we generalize the theorem to apply when only the supports of smaller subsets are available. 88 THEOREM (GENERALIZED SUPPORT LOWER-BOUNDING): The following equation computes a lower-bound on the support of itemset lu T where 7\u201a€™ is an itemset disjoint from I and I,, c I , sup(l) - c drop(l,, i) ieT Proof The equation is simply the result of applying the previous theorem repeatedly for each item i in T. q 4.2 SuDnort Lower-Bounding in Max-Miner Support iower-bounding can be use; by Max-Miner within the Gen-Sub-Nodes function for additional suoerset-fieauencv pruning (Figure 6). If sub-nodes of a candidate grdup are ge<erateh while traversing the tail items in item order, a sub-node g2 generated after ,g, will have the DroDertv that x(g,) u t(g,) c h&,)-6 t(g,) . This means if /~(g\u201a€™~) b &,) is a freauent itemset. then anv sub-node generated after P. can lead only to non-maiimal ite&ets. Max-h?iner thus avoid; ienerating sub-nodes following any sub-node g for which h(g) u t(g) can be lower-bounded above minsup. Figure 6. Generating sub-nodes with support lower-bounding. GEN-SUB-NODES(Candidate Group g , Set of Cand. Groups C) ;; C is passed by reference and returns the sub-nodes of g ;; The return value of the function is a frequent itemset remove any item i from t(g) if h(g) u {i} is infrequent reorder the items in t(s) for each i E t(g) in increasing item order do let g\u201a€™ be a new candidate with h(g\u201a€™) = h(g) u {i} and t(g\u201a€™) = tilti E t(g)) andifollows i in l(g)} if COMPUTE-LB(g\u201a€™ , h(g) ) 2 minsup then return h(g\u201a€™) u t(g\u201a€™) ;; this itemset is frequent else Ct Cu {g\u201a€™} return h(g) ;; This case arises only if t(g) is empty Figure 7. Computing the support lower-bound. XlPuTE-LB(Candidate Group g , Itemset Z, ) ;; Returns a lower-bound on the support of h(g) u r(g) ;; Itemset tr is a proper subset of h(g) Integer d t 0 for each i E t(g) do d t d + drop(I,,, i) return sup(h(g)) -d Figure 7 shows how Max-Miner computes a lower-bound on h(g) u t(g) using only support information provided by its subsets. The function directly applies the generalized support lower-bounding theorem. Note that the support values required for this computation are available through the itemsets whose supports were computed while counting the support of the parent node. 4.3 Support Lower-Bounding in Apriori Apriori generates candidate itemsets of length k whose supports are computed during database pass k. An itemset is made a candidate if every k - I item subset was found frequent during the previous database pass. Suppose we are using Apriori to identify the maximal frequent itemseta. If Apriori can be made to lower- bound the support of a candidate itemset above or equal to minsup, then its support does not have to be explicitly counted. However, the candidate itemset cannot be entirely pruned because it must remain present for the subsequent candidate generation phase. Nevertheless, the savings that result from counting the support of fewer candidate itemsets can be substantial. Also, for a particular database pass, if ever Apriori can lower-bound the support of all candidate itemsets above minsup, then it can skip the database pass altogether. A support lower-bound can be obtained on a candidate itemset 1, by plugging into the support lower-bounding theorem any proper subset I of I , and any proper subset [F of I. The tightest bounds will be obtaiied by using only subsets with one less item. If the candidate itemset I, has k items, there are then (k- l)(k-2) subset combinations for lower-bounding the support of !c. Our lower-bounding enhanced Apriori algorithm, Aprtori-LB, considers every one of these possibilities and compares the best (largest) bound obtained to minsup. Apriori-LB does not always have access to the exact support of every proper subset of a candidate because one or more subsets of a candidate itemset may have been left uncounted due to previous lower-bounding efforts. When this is the case, Apriori-LB uses a new Rmction to bound support drop. The new function, drop-b, uses support bounds instead of exact support values. Because drop-b clearly computes an upper-bound on the value of drop given the same arguments, it can be used in place of drop in the lower-bounding theorems. DEFINITION: drop-b(l,Y, i) = ub-sup(1.J - lb-sup(l,, u {i}) , where ub-sup(f) is the best-known upper-bound on sup(l), and lb-sup(l) is the best-known lower-bound on sup(l). The support of an itemset can be upper-bounded by the support (or upper-bound on support) of any of its subsets. Apriori-LB sets ub-sup(Z) of an uncounted itemset I with k items to the smallest of the support upper-bounds or (if computed) support values of each of its k- 1 item subsets. 5. Exploiting Additional Constraints Though the frequent patterns themselves are often of interest to the end-user, often they need to be digested further before being presented. Association rules are digested frequent itemsets that can be useful for prediction. The confidence of an association rule i,, i2, ., ik + i, is equal to the support of the itemset ii,,+, . . ..ikJ divided by the support of the itemset {iI, i,, . . . . i,, ic} . Typically the user is interested in finding only those association rules with high confidence and support, and these are produced by searching the entire space of frequent itemsets. Another database pass is required after finding all maximal frequent itemsets in order to obtain the supports of all frequent itemsets for producing association rules. If the frequent itemsets are long, even if implemented efficiently using specialized data structures, this step is hopelessly intractable. Max-Miner can be used to identify many, though not all, high- confidence association rules during its execution. After counting the support of a candidate group g, Max-Miner has all the supports necessary to compute the confidence of any association rule of the form h(g) + i, where i, E t(g). Another approach at incomplete rule-mining could be to use the set of maximal frequent itemsets to define the space of rules searched by a randomized algorithm. Though incomplete techniques at association rule mining may sometimes be sufficient, completeness is more desirable. We believe that incorporating additional constraints into the search for frequent patterns is the only way to achieve completeness on complex data. Association rule confidence is a constraint that Bayardo [5] uses to prune some itemsets from consideration. Other constraints that have been used during the search for patterns include item constraints [ 151 and information-theoretic constraints [ 131. Interestingness constraints thus far applied only during post- processing (e.g. [6]) might also be exploitable during search to improve efficiency. Max-Miner provides a framework in which additional constraints can often be easily integrated into the search. Consider as an example the problem of finding only the longest frequent itemsets. This constraint is quite powerful because data sets with long frequent itemsets usually have very many maximal frequent itemsets, of which only a small fraction are longest. We have implemented a version of Max-Miner that exploits this constraint called Max-Miner-LO (\u201a€œLongest Only\u201a€). It determines the 89 cardinal&y 1 of the longest itemset in the set of frequent itemsets F after each database pass. Any frequent itemsets in F that are shorter than 1 are then pruned, as are any candidate groups g in C such that Ih(g) u t(g)/ < I.  "},{"aspect":"expcomparison","tweet":" 2 J!! 3 3 100000 10000 1000 100 100000 Figure 8. CPU time on pumsb*. Figure 9. CPU time on mushroom. Max-Miner + Agriori -LB -*---- Apriori Max-Miner + Apriori-LB -f---- .o Apriori 0. 1 J 10 7.5 5 2.5 1 0.1 support (%) Figure 10. CPU time on chess. Max-Miner +-- Agriori-LB -*---. Agriori \"m'.. 10 \u201a€™ I 60 55 50 45 40 35 30 25 20 support (%) Figure 11. CPU time on connect-4. .m Max-Miner -.-.- : Apriori-LB -*---- .:\u201a€™ Apriori \u201a€˜a---- 10 \u201a€™ I 90 80 70 60 50 40 30 20 10 support (%) 90 6.1 Max-Miner versus Apriori and Apriori-LB Figures 8 through 11 compare the performance of Max-Miner, Apriori-LB, and Apriori on the most difftcult of the evaluation data-sets. While Apriori-LB is performing far better than Apriori with respect to run-time (note the logarithmically scaled y axes), because of its space complexity, we were unable to run it at lower support than Apriori without exceeding the memory of our machine. At several data points, Max-Miner is over two orders of magnitude faster than Apriori at identifying maximal frequent patterns, and an order of magnitude faster than Apriori-LB. Had we allowed Apriori to perform candidate paging, the speedups at lower supports would be even more substantial. Even though these data sets are from distinctly different domains, the performance trends are all identical. What these data-sets all have in common are long patterns at relatively high values of support. 1400 1200 1000 800 600 400 200 450 400 350 300 250 200 150 100 50 Figure 12. CPU time on retail. 0 \u201a€™ I 0.3 0.25 0.2 0.15 0.1 support ($1 Figure 13. CPU time on splice. 0 \u201a€™ I 6 5.5 5 4.5 4 3.5 3 2.5 a support (%) The two remaining evaluation data-sets, retail and splice, have comparatively small patterns at low support levels. Even so, Max- Miner still outperforms both Apriori and Apriori-LB. We plot only the performance of Apriori on these data sets, since Apriori-LB offered no advantages. Apriori-LB appears to be more effective at tightly lower-bounding support when the patterns are long. Most of the maximal frequent itemsets in these data sets are of length 2 to 4, and the longest are of .length 8 in splice and 6 in retail at the lowest support values. The superior performance of Max-Miner on these data-sets arises from considering fewer candidate itemsets and reduced index overhead resulting from the indexing of candidate groups using only head items. This suggests that Apriori should also index candidate itemsets that share a common prefix as a group rather than individually. We are currently investigating whether this optimization pays off more generally. Figure 14. CPU time per maximal frequent itemset. 2.4 r I 2.2 - 2 - 1.8 - 1.6 - 1.4 - 1.2 - l- 0.8 - 0.6 - n-4 - 100 1000 10000 100000 1e+06 IMI  "}]}