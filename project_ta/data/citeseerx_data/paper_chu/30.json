{"user_name":" Mining Association Rules with Item Constraints ","user_timeline":[{"aspect":"abstract","tweet":" Abstract  The problem of discovering association rules has received considerable research attention and several fast algorithms for mining association rules have been developed. In practice, users are often interested in a subset of association rules. For example, they may only want rules that contain a specific item or rules that contain children of a specific item in a hierarchy. While such constraints can be applied as a postprocessing step, integrating them into the mining algorithm can dramatically reduce the execution time. We consider the problem of integrating constraints that are boolean expressions over the presence or absence of items into the association discovery algorithm. We present three integrated algorithms for mining association rules with item constraints and discuss their tradeoffs. "},{"aspect":"expanalysis","tweet":" 6. Conclusions  We considered the problem of discovering association rules in the presence of constraints that are boolean expressions over the presence of absence of items. Such constraints allow users to specify the subset of rules that they are interested in. While such constraints can be applied as a post-processing step, integrating them into the mining algorithm can dramatically reduce the execution time. We presented three such integrated algorithm, and discussed the tradeoffs between them. Empirical evaluation of the MultipleJoins algorithm on three real-life datasets showed that integrating item constraints can speed up the algorithm by a factor of 5 to 20 for item constraints with selectivity between 0.1 and 0.01. Although we restricted our discussion to the Apriori algorithm, these ideas apply to other algorithms that use apriori candidate generation, including the recent (Toivonen 1996). The main idea in (Toivonen 1996) is to first run Apriori on a sample of the data to find itemsets that are expected to be frequent, or all of whose subsets are are expected to be frequent. (We also need to count the latter to ensure that no frequent itemsets were missed.) These itemsets are then counted over the complete dataset. Our ideas can be directly applied to the first part of the algorithm: those itemsets counted by Reorder or Direct over the sample would be counted over the entire dataset. For candidates that were not frequent in the sample but were frequent in the datasets, only those extensions of such candidates that satisfied those constraints would be counted in the additional pass. "},{"aspect":"expdata","tweet":""},{"aspect":"background","tweet":" 1. Introduction  The problem of discovering association rules was introduced in (Agrawal, Imielinski, & Swami 1993). Given a set of transactions, where each transaction is a set of literals (called items), an association rule is an expression of the form X ) Y , where X and Y are sets of items. The intuitive meaning of such a rule is that transactions of the database which contain X tend to contain Y . An example of an association rule is: \"30% of transactions that contain beer also contain diapers; 2% of all transactions contain both these items\". Here 30% is called the confidence of the rule, and 2% the  support of the rule. Both the left hand side and right hand side of the rule can be sets of items. The problem is to find all association rules that satisfy userspecified minimum support and minimum confidence constraints. Applications include discovering affinities for market basket analysis and cross-marketing, catalog design, loss-leader analysis, store layout and customer segmentation based on buying patterns. See (Nearhos, Rothman, & Viveros 1996) for a case study of an application in health insurance, and (Ali, Manganaris, & Srikant 1997) for case studies of applications in  1  Copyright c fl1997, American Association for Artificial Intelligence (www.aaai.org). All rights reserved.  predicting telecommunications order failures and medical test results. There has been considerable work on developing fast algorithms for mining association rules, including (Agrawal et al. 1996) (Savasere, Omiecinski, & Navathe 1995) (Toivonen 1996) (Agrawal & Shafer 1996) (Han, Karypis, & Kumar 1997). Taxonomies (is-a hierarchies) over the items are often available. An example of a taxonomy is shown in Figure 1. This taxonomy says that Jacket is-a  Outerwear, Ski Pants is-a Outerwear, Outerwear isa  Clothes, etc. When taxonomies are present, users are usually interested in generating rules that span different levels of the taxonomy. For example, we may infer a rule that people who buy Outerwear tend to buy Hiking Boots from the fact that people bought Jackets with Hiking Boots and Ski Pants with Hiking Boots. This generalization of association rules and algorithms for finding such rules are described in (Srikant & Agrawal 1995) (Han & Fu 1995). In practice, users are often interested only in a subset of associations, for instance, those containing at least one item from a user-defined subset of items. When taxonomies are present, this set of items may be specified using the taxonomy, e.g. all descendants of a given item. While the output of current algorithms can be filtered out in a post-processing step, it is much more efficient to incorporate such constraints into the associations discovery algorithm. In this paper, we consider constraints that are boolean expressions over the presence or absence of items in the rules. When taxonomies are present, we allow the elements of the boolean expression to be of the form ancestors(item) or descenClothes  Jackets Footwear Ski Pants Shirts Outerwear Shoes Hiking Boots Figure 1: Example of a Taxonomy  dants(item) rather than just a single item. For example,  (Jacket  Shoes)  (descendants(Clothes)  : ancestors(Hiking Boots)) expresses the constraint that we want any rules that either (a) contain both Jackets and Shoes, or (b) contain Clothes or any descendants of clothes and do not contain Hiking Boots or Footwear.  Paper Organization We give a formal description of the problem in Section 2. Next, we review the Apriori algorithm (Agrawal et al. 1996) for mining association rules in Section 3. We use this algorithm as the basis for presenting the three integrated algorithms for mining associations with item constraints in Section 4. However, our techniques apply to other algorithms that use apriori candidate generation, including the recently published (Toivonen 1996). We discuss the tradeoffs between the algorithms in Section 5, and conclude with a summary in Section 6.  "},{"aspect":"expintro","tweet":""},{"aspect":"problemdef","tweet":" 2. Problem Statement  Let L = fl 1 ; l 2 ; : : : ; l m g be a set of literals, called items. Let G be a directed acyclic graph on the literals. An edge in G represents an is-a relationship, and G represents a set of taxonomies. If there is an edge in G from  p to c, we call p a parent of c and c a child of p (p represents a generalization of c.) We call x an ancestor of  y (and y a descendant of x) if there is a directed path from x to y in G.  Let D be a set of transactions, where each transaction  T is a set of items such that T ` L. We say that a transaction T supports an item x 2 L if x is in T  or x is an ancestor of some item in T . We say that a transaction T supports an itemset X ` L if T supports every item in the set X.  A generalized association rule is an implication of the form X ) Y , where X ae L, Y ae L, X \" Y = ;.  1  The rule X ) Y holds in the transaction set D with  confidence c if c% of transactions in D that support X  also support Y . The rule X ) Y has support s in the transaction set D if s% of transactions in D support  X [ Y . Let B be a boolean expression over L. We assume without loss of generality that B is in disjunctive normal form (DNF).  2  That is, B is of the form  D 1 D 2 : : :Dm , where each disjunct D i is of the form  ff i1  ff i2  : : :  ff in i . When there are no taxonomies present, each element ff ij is either l ij or :l ij for some  l ij 2 L. When a taxonomy G is present, ff ij can also be ancestor(l ij ), descendant(l ij ), : ancestor(l ij ), or  1  Usually, we also impose the condition that no item in  Y should be an ancestor of any item in X. Such a rule would have the same support and confidence as the rule without the ancestor in Y , and is hence redundant.  2  Any boolean expression can be converted to a DNF expression.  : descendant(l ij ). There is no bound on the number of ancestors or descendants that can be included. To evaluate B, we implicitly replace descendant(l ij ) by l ij  l  0  ij  l  00  ij  : : :, and : descendant(l ij ) by  :(l ij l  0  ij l  00  ij : : :), where l  0  ij ; l  00  ij ; : : : are the descendants of l ij . We perform a similar operation for ancestor.  To evaluate B over a rule X ) Y , we consider all items that appear in X ) Y to have a value true in B and all other items to have a value false.  Given a set of transactions D, a set of taxonomies  G and a boolean expression B, the problem of mining association rules with item constraints is to discover all rules that satisfy B and have support and confidence greater than or equal to the user-specified minimum support and minimum confidence respectively. "},{"aspect":"solution","tweet":"  3. Review of Apriori Algorithm  The problem of mining association rules can be decomposed into two subproblems:  ffl Find all combinations of items whose support is greater than minimum support. Call those combinations  frequent itemsets.  ffl Use the frequent itemsets to generate the desired rules. The general idea is that if, say, ABCD and  AB are frequent itemsets, then we can determine if the rule AB ) CD holds by computing the ratio r = support(ABCD)/support(AB). The rule holds only if r  minimum confidence. Note that the rule will have minimum support because ABCD is frequent. We now present the Apriori algorithm for finding all frequent itemsets (Agrawal et al. 1996). We will use this algorithm as the basis for our presentation. Let  k-itemset denote an itemset having k items. Let L k  represent the set of frequent k-itemsets, and C k the set of candidate k-itemsets (potentially frequent itemsets) . The algorithm makes multiple passes over the data. Each pass consists of two phases. First, the set of all frequent (k \\Gamma 1)-itemsets, L k\\Gamma1 , found in the (k\\Gamma1)th pass, is used to generate the candidate itemsets  C k . The candidate generation procedure ensures that  C k is a superset of the set of all frequent k-itemsets.  The algorithm now scans the data. For each record, it determines which of the candidates in C k are contained in the record using a hash-tree data structure and increments their support count. At the end of the pass,  C k is examined to determine which of the candidates are frequent, yielding L k . The algorithm terminates when L k becomes empty.  Candidate Generation Given L k , the set of all frequent  k-itemsets, the candidate generation procedure returns a superset of the set of all frequent (k + 1)- itemsets. We assume that the items in an itemset are lexicographically ordered. The intuition behind this procedure is that all subsets of a frequent itemset are also frequent. The function works as follows. First, in the join step, L k is joined with itself:  insert into C k+1  select p:item 1 ; p:item 2 ; : : : ; p:item k ; q:item k  from L k p, L k q  where p:item 1 = q:item 1 ; : : : ; p:item k\\Gamma1 = q:item k\\Gamma1 ; p:item k ! q:item k ; Next, in the prune step, all itemsets c 2 C k+1 , where some k-subset of c is not in L k , are deleted. A proof of correctness of the candidate generation procedure is given in (Agrawal et al. 1996). We illustrate the above steps with an example. Let  L 3 be ff1 2 3g, f1 2 4g, f1 3 4g, f1 3 5g, f2 3 4gg. After the join step, C 4 will be ff1 2 3 4g, f1 3 4 5gg. The prune step will delete the itemset f1 3 4 5g because the subset f1 4 5g is not in L 3 . We will then be left with only f1 2 3 4g in C 4 . Notice that this procedure is no longer complete when item constraints are present: some candidates that are frequent will not be generated. For example, let the item constraint be that we want rules that contain the item 2, and let L 2 = f f1 2g, f2 3g g. For the Apriori join step to generate f1 2 3g as a candidate, both f1 2g and f1 3g must be present -- but f1  3g does not contain 2 and will not be counted in the second pass. We discuss various algorithms for candidate generation in the presence of constraints in the next section.   4. Algorithms  We first present the algorithms without considering taxonomies over the items in Sections 4.1 and 4.2, and then discuss taxonomies in Section 4.3. We split the problem into three phases:  ffl Phase 1 Find all frequent itemsets (itemsets whose support is greater than minimum support) that satisfy the boolean expression B. Recall that there are two types of operations used for this problem: candidate generation and counting support. The techniques for counting the support of candidates remain unchanged. However, as mentioned above, the apriori candidate generation procedure will no longer generate all the potentially frequent itemsets as candidates when item constraints are present. We consider three different approaches to this problem. The first two approaches, \"MultipleJoins\" and \"Reorder\", share the following approach (Section 4.1): 1. Generate a set of selected items S such that any itemset that satisfies B will contain at least one selected item. 2. Modify the candidate generation procedure to only count candidates that contain selected items. 3. Discard frequent itemsets that do not satisfy B.  The third approach, \"Direct\" directly uses the boolean expression B to modify the candidate generation procedure so that only candidates that satisfy  B are counted (Section 4.2).  ffl Phase 2 To generate rules from these frequent itemsets, we also need to find the support of all subsets of frequent itemsets that do not satisfy B. Recall that to generate a rule AB ) CD, we need the support of AB to find the confidence of the rule. However,  AB may not satisfy B and hence may not have been counted in Phase 1. So we generate all subsets of the frequent itemsets found in Phase 1, and then make an extra pass over the dataset to count the support of those subsets that are not present in the output of Phase 1.  ffl Phase 3 Generate rules from the frequent itemsets found in Phase 1, using the frequent itemsets found in Phases 1 and 2 to compute confidences, as in the Apriori algorithm. We discuss next the techniques for finding frequent itemsets that satisfy B (Phase 1). The algorithms use the notation in Figure 2.  4.1 Approaches using Selected Items  Generating Selected Items Recall the boolean expression B = D 1  D 2  : : :  Dm , where D i =  ff i1  ff i2  : : :  ff in i and each element ff ij is either  l ij or :l ij , for some l ij 2 L. We want to generate a set of items S such that any itemset that satisfies B will contain at least one item from S. For example, let the set of items L = f1; 2; 3; 4; 5g. Consider B = (12)3. The sets f1, 3g, f2, 3g and f1, 2, 3, 4, 5g all have the property that any (non-empty) itemset that satisfies B  will contain an item from this set. If B = (1  2) :3,  the set f1, 2, 4, 5g has this property. Note that the inverse does not hold: there are many itemsets that contain an item from S but do not satisfy B.  For a given expression B, there may be many different sets S such that any itemset that satisfies B contains an item from S. We would like to choose a set of items for S so that the sum of the supports of items in  S is minimized. The intuition is that the sum of the supports of the items is correlated with the sum of the supports of the frequent itemsets that contain these items, which is correlated with the execution time. We now show that we can generate S by choosing one element ff ij from each disjunct D i in B, and adding either l ij or all the elements in L \\Gamma fl ij g to S, based on whether ff ij is l ij or :l ij respectively. We define an element ff ij = l ij in B to be \"present\" in S if l ij 2 S  and an element ff ij = :l ij to be \"present\" if all the items in L \\Gamma fl ij g are in S. Then:  Lemma 1 Let S be a set of items such that  8D i 2 B 9 ff ij 2 D i [(ff ij = l ij  l ij 2 S)   (ff ij = :l ij  (L \\Gamma fl ij g) ` S)]:  Then any (non-empty) itemset that satisfies B will contain an item in S.  Proof: Let X be an itemset that satisfies B. Since X  satisfies B, there exists some D i 2 B that is true for X.  From the lemma statement, there exists some ff ij 2 D i  B = D 1  D 2  : : :  Dm (m disjuncts)  D i = ff i1  ff i2  : : :  ff in i (n i conjuncts in D i )  ff ij is either l ij or :l ij , for some item l ij 2 L S Set of items such that any itemset that satisfies B contains an item from S  selected itemset An itemset that contains an item in S  k-itemset An itemset with k items.  L  s k Set of frequent k-itemsets (those with minimum support) that contain an item in S  L  b k Set of frequent k-itemsets (those with minimum support) that satisfy B  C  s k Set of candidate k-itemsets (potentially frequent itemsets) that contain an item in S  C  b k Set of candidate k-itemsets (potentially frequent itemsets) that satisfy B  F Set of all frequent items Figure 2: Notation for Algorithms such that either ff ij = l ij and l ij 2 S or ff ij = :l ij and (L \\Gamma fl ij g) ` S. If the former, we are done: since D i  is true for X, l ij 2 X. If the latter, X must contain some item in in L \\Gamma fl ij g since X does not contain l ij  and X is not an empty set. Since (L \\Gamma fl ij g) ` S, X  contains an item from S. 2  A naive optimal algorithm for computing the set of elements in S such that support(S) is minimum would require  Q m i=1 n i time, where n i is the number of conjuncts in the disjunct D i . An alternative is the following greedy algorithm which requires  P m i=1  n i time and is optimal if no literal is present more than once in B. We define S [ ff ij to be S [ l ij if ff ij = l ij and  S [ (L \\Gamma fl ij g) if ff ij = :l ij .  S := ;;  for i := 1 to m do begin // B = D 1  D 2  : : :  Dm  for j := 1 to n i do // D i = ff i1  ff i2  : : :  ff in i  Cost(ff ij ) := support(S [ ff ij ) - support(S); Let ff ip be the ff ij with the minimum cost.  S := S [ ff ip ;  end  Consider a boolean expression B where the same literal is present in different disjuncts. For example, let  B = (1  2)  (1  3). Assume 1 has higher support than 2 or 3. Then the greedy algorithm will generate  S = f2; 3g whereas S = f1g is optimal. A partial fix for this problem would be to add the following check. For each literal l ij that is present in different disjuncts, we add l ij to S and remove any redundant elements from  S, if such an operation would decrease the support of  S. If there are no overlapping duplicates (two duplicated literals in the same disjunct), this will result in the optimal set of items. When there are overlapping duplicates, e.g, (1  2)  (1  3)  (3  4), the algorithm may choose f1; 4g even if f2; 3g is optimal. Next, we consider the problem of generating only those candidates that contain an item in S.  Candidate Generation Given L  s k , the set of all selected frequent k-itemsets, the candidate generation procedure must return a superset of the set of all selected frequent (k+1)-itemsets. Recall that unlike in the Apriori algorithm, not all subsets of candidates in C  s k+1 will be in L  s k . While all subsets of a frequent selected itemset are frequent, they may not be selected itemsets. Hence the join procedure of the Apriori algorithm will not generate all the candidates. To generate C  s  2 we simply take L  s  1 \\Theta F , where F is the set of all frequent items. For subsequent passes, one solution would be to join any two elements of L  s k  that have k \\Gamma 1 items in common. For any selected k-  itemset where k ? 2, there will be at least 2 subsets with a selected item: hence this join will generate all the candidates. However, each k + 1-candidate may have up to k frequent selected k-subsets and k(k \\Gamma 1) pairs of frequent k-subsets with k \\Gamma 1 common items. Hence this solution can be quite expensive if there are a large number of itemsets in L  s k . We now present two more efficient approaches.  Algorithm MultipleJoins The following lemma presents the intuition behind the algorithm. The itemset  X in the lemma corresponds to a candidate that we need to generate. Recall that the items in an itemset are lexicographically ordered.  Lemma 2 Let X be a frequent (k+1)-itemset, k  2.  A. If X has a selected item in the first k \\Gamma 1 items, then there exist two frequent selected k-subsets of X  with the same first k \\Gamma 1 items as X.  B. If X has a selected item in the last min(k \\Gamma 1, 2)  items, then there exist two frequent selected k-subsets  of X with the same last k \\Gamma 1 items as X.  C. If X is a 3-itemset and the second item is a selected item, then there exist two frequent selected 2subsets of X, Y and Z, such that the last item of Y  is the second item of X and the first item of Z is the second item of X.  For example, consider the frequent 4-itemset f1 2 3 4g. If either 1 or 2 is selected, f1 2 3g and f1 2 4g are  two subsets with the same first 2 items. If either 3 or 4 is selected, f2 3 4g and f1 3 4g are two subsets with the same last 2 items. For a frequent 3-itemset f1 2 3g where 2 is the only selected item, f1 2g and f2 3g are the only two frequent selected subsets. Generating an efficient join algorithm is now straightforward: Joins 1 through 3 below correspond directly to the three cases in the lemma. Consider a candidate (k+1)-itemset X, k  2. In the first case, Join 1 below will generate X. (Join 1 is similar to the join step of the Apriori algorithm, except that it is performed on a subset of the itemsets in L  s  2 .) In the second case, Join 2 will generate X. When k  3, we have covered all possible locations for a selected item in X. But when k = 2, we also need Join 3 for the case where the selected item in X is the second item. Figure 3 illustrates this algorithm for S = f2, 4g and an L  s  2 with 4 itemsets. // Join 1  L  s k  0  := fp 2 L  s k j one of the first k \\Gamma 1 items of p is in Sg  insert into C  s k+1  select p:item 1 ; p:item 2 ; : : : ; p:item k ; q:item k  from L  s k  0  p, L  s k  0  q  where (p:item 1 = q:item 1 ; : : : ; p:item k\\Gamma1 = q:item k\\Gamma1 ; p:item k ! q:item k ) // Join 2  L  s k  00  := fp 2 L  s k j one of the last min(k \\Gamma 1,2) items of p is in Sg  insert into C  s k+1  select p:item 1 ; q:item 1 ; q:item 2 ; : : : ; q:item k  from L  s k  00  p, L  s k  00  q  where (p:item 1 ! q:item 1 ; p:item 2 = q:item 2 ; : : : ; p:item k = q:item k ) // Join 3 (k = 2)  insert into C  s  3  select q:item 1 ; p:item 1 ; p:item 2  from L  s  2  0  p, L  s  2  00  q  where (q:item 2 = p:item 1 ) and  (q:item 1 , p:item 2 are not selected); Note that these three joins do not generate any duplicate candidates. The first k \\Gamma 1 items of any two candidate resulting from Joins 1 and 2 are different. When k = 2, the first and last items of candidates resulting from Join 3 are not selected, while the first item is selected for candidates resulting from Join 1 and the last item is selected for candidates resulting from Join 1. Hence the results of Join 3 do not overlap with either Join 1 or Join 2. In the prune step, we drop candidates with a selected subset that is not present in L  s k .  Algorithm Reorder As before, we generate C  s  2 by taking L  s  1 \\Theta F . But we use the following lemma to simplify the join step.  Lemma 3 If the ordering of items in itemsets is such that all items in S precede all items not in S, the join  L  s  2  0  L  s  2  00  Join 1 Join 2 Join 3  f2 3g f1 2g f2 3 5g f1 2 3g  f2 5g f1 4g f1 3 4g f1 2 5g  f3 4g  Figure 3: MultipleJoins Example  L  s  2 Join 1  f2 1g f2 1 3g  f2 3g f2 1 5g  f2 5g f2 3 5g  f4 1g f4 1 3g  f4 3g Figure 4: Reorder Example procedure of the Apriori algorithm applied to L  s k will generate a superset of L  s k+1 .  The intuition behind this lemma is that the first item of any frequent selected itemset is always a selected item. Hence for any (k +1)-candidate X, there exist two frequent selected k-subsets of X with the same first  k \\Gamma 1 items as X. Figure 4 shows the same example as shown in Figure 3, but with the items in S, 2 and 4, ordered before the other items, and with the Apriori join step. Hence instead of using the lexicographic ordering of items in an itemset, we impose the following ordering. All items in S precede all items not in S; the lexicographic ordering is used when two items are both in S  or both not in S. An efficient implementation of an association rule algorithm would map strings to integers, rather than keep them as strings in the internal data structures. This mapping can be re-ordered so that all the frequent selected items get lower numbers than other items. After all the frequent itemsets have been found, the strings can be re-mapped to their original values. One drawback of this approach is that this reordering has to be done at several points in the code, including the mapping from strings to integers and the data structures that represent the taxonomies.  4.2 Algorithm Direct  Instead of first generating a set of selected items S  from B, finding all frequent itemsets that contain one or more items from S and then applying B to filter the frequent itemsets, we can directly use B in the candidate generation procedure. We first make a pass over the data to find the set of the frequent items F . L  b  1  is now the set of those frequent 1-itemsets that satisfy  B. The intuition behind the candidate generation procedure is given in the following lemma.  Lemma 4 For any (k +1)-itemset X which satisfies  B, there exists at least one k-subset that satisfies B  unless each D i which is true on X has exactly k +1  non-negated elements.  We generate C  b k+1 from L  b k in 4 steps: 1. C  b k+1 := L  b k \\Theta F ; 2. Delete all candidates in C  b k+1 that do not not satisfy  B;  3. Delete all candidates in C  b k+1 with a k-subset that satisfies B but does not have minimum support. 4. For each disjunct D i = ff i1  ff i2  : : :   ff in i in B with exactly k + 1 non-negated elements  ff ip1 ; ff ip2 ; : : : ; ff ipk+1 , add the itemset  fff ip1 ff ip2 : : : ; ff ipk+1 g to C  b k+1 if all the ff ip j s are frequent,  For example, let L = f1; 2; 3; 4; 5g and B = (1  2)   (4  :5)). Assume all the items are frequent. Then  L  b  1 = ff4gg. To generate C  b  2 , we first take L  b  1 \\Theta F to get f f1 4g, f2 4g, f3 4g, f4 5g g. Since f4 5g does not satisfy B, it is dropped. Step 3 does not change C  b  2  since all 1-subsets that satisfy B are frequent. Finally, we add f1 2g to C  b  2 to get ff1 2g, f1 4g, f2 4g, f3 4gg.  4.3 Taxonomies  The enhancements to the Apriori algorithm for integrating item constraints apply directly to the algorithms for mining association rules with taxonomies given in (Srikant & Agrawal 1995). We discuss the Cumulate algorithm here.  3  This algorithm adds all ancestors of each item in the transaction to the transaction, and then runs the Apriori algorithm over these \"extended transactions\". For example, using the taxonomy in Figure 1, a transaction fJackets, Shoesg would be replaced with fJackets, Outerwear, Clothes, Shoes, Footwearg. Cumulate also performs several optimization, including adding only ancestors which are present in one or more candidates to the extended transaction and not counting any itemset which includes both an item and its ancestor. Since the basic structure and operations of Cumulate are similar to those of Apriori, we almost get taxonomies for \"free\". Generating the set of selected items, S is more expensive since for elements in B that include an ancestor or descendant function, we also need to find the support of the ancestors or descendants. Checking whether an itemset satisfies B is also more expensive since we may need to traverse the hierarchy to find whether one item is an ancestor of another.  Cumulate does not count any candidates with both an item and its ancestor since the support of such an itemset would be the same as the support of the itemset without the ancestor. Cumulate only checks for such candidates during the second pass (candidates of size 2). For subsequent passes, the apriori candidate generation procedure ensures that no candidate that  3  The other fast algorithm in (Srikant & Agrawal 1995), EstMerge, is similar to Cumulate, but also uses sampling to decrease the number of candidates that are counted.  contains both an item and its ancestor will be generated. For example, an itemset fJacket Outerwear Shoesg would not be generated in C 3 because fJacket  Outerwearg would have been deleted from L 2 . However, this property does not hold when item constraints are specified. In this case, we need to check each candidate (in every pass) to ensure that there are no candidates that contain both an item and its ancestor. "},{"aspect":"expcomparison","tweet":""}]}