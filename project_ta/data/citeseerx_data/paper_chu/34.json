{"user_name":" XSEarch: A Semantic Search Engine for XML ","user_timeline":[{"aspect":"abstract","tweet":" Abstract XSEarch, a semantic search engine for XML, is presented. XSEarch has a simple query language, suitable for a naive user. It returns semantically related document fragments that satisfy the user\u201aÄôs query. Query answers are ranked using extended information-retrieval techniques and are generated in an order similar to the ranking. Advanced indexing techniques were developed to facilitate efficient implementation of XSEarch. The performance of the different techniques as well as the recall and the precision were measured experimentally. These experiments indicate that XSEarch is efficient, scalable and ranks quality results highly. "},{"aspect":"expanalysis","tweet":" 7 Related Work and Conclusion Numerous query languages for XML have been developed. Recently, interest has arisen in techniques for \u201aÄúflexible querying\u201aÄù of XML. For example, the XQuery working group is considering how to add full-text search features and ranking to XQuery [5]. Such capabilities have already been added to various XML query languages. [10] extends XML-QL with keyword search and presents performance experiments. XIRQL [11] is an extension of XQL that supports vague predicates, weighting of terms and minimal structural abstracting (e.g., abstraction of differences between attributes and elements). The XXL search engine [15] has an SQL-like syntax, extended with ranking and ontolog- ÔøΩÔøΩÔøΩ ÔøΩÔøΩÔøΩ ÔøΩÔøΩÔøΩ ÔøΩÔøΩÔøΩ ÔøΩÔøΩÔøΩ ÔøΩ ÔøΩÔøΩÔøΩ ÔøΩÔøΩÔøΩ ÔøΩÔøΩÔøΩ ÔøΩÔøΩÔøΩ ÔøΩ ÔøΩÔøΩ ÔøΩÔøΩÔøΩÔøΩ ÔøΩÔøΩÔøΩ ÔøΩÔøΩÔøΩÔøΩ ÔøΩ ÔøΩÔøΩÔøΩÔøΩ ÔøΩÔøΩ ÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩ ÔøΩÔøΩ ÔøΩÔøΩ ÔøΩÔøΩ ÔøΩÔøΩÔøΩ ÔøΩÔøΩ ÔøΩÔøΩ ÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩ ÔøΩÔøΩÔøΩ ÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩ ÔøΩÔøΩÔøΩÔøΩÔøΩ ÔøΩÔøΩÔøΩÔøΩ ÔøΩÔøΩ ÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩ ÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩ ÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩ ÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩ Figure 8: P@5, P@10 and P@20 of Qkw and Qkw+tag for DBLP. ical knowledge for similarity metrics. On the whole, these languages are not suitable for naive user, since the query syntax is always complex. The EquiX [8] language is a simple extension of a search engine for XML documents. However, EquiX can only deal with documents that have a DTD. In [4], another search language for XML was proposed. Their language consists of fragments of XML documents, and they only require approximate matching of the queries to the documents. However, their query answers consist of entire documents, instead of document fragments. In addition, they do not require any semantic relationship between the parts of the document that match a given query. In [2, 13], it is suggested to rank query answers according to the distance in the document between the different document elements that satisfy a query. Closer elements would receive a higher ranking. We also use this measure for our ranking, but it is only one of several measures. In [13], efficient algorithms to compute the top k answers are presented. However, these algorithms are based on the assumption that each document has a schema, which may not necessarily hold. A theoretical treatment of the problem of flexibly matching a query to a document was presented in [14]. However, their approach did not include keyword searching. A recent related work is the XRANK system [12] for keyword searching in XML documents. XRANK has a ranking mechanism and it returns document fragments as answers. In XRANK, there is no distinction between keywords and labels, and each keyword of an XRANK query is matched against every word of the document (even if that word is a label). An answer to an XSEarch query is also an answer or some part of an answer to the XRANK query that consists of the same keywords and labels, but the converse is not necessarily true. Actually, XRANK may return answers with parts that are semantically unrelated, as in Example 1.1. XRANK ranks the elements of an XML document by generalizing the Page-Rank algorithm of Google [3]. It ranks the answers to a query by combin- ing the ranking of elements with keyword proximity. The notion of proximity in XRANK means that the children of an element must be in the \u201aÄúright order\u201aÄù if that element should be ranked highly as an answer. For example, if a paper element has title as its first child andauthor as its last child, with all the section elements in between, then that paper element will get a low rank, even if the query has a keyword from the title and a keyword from author\u201aÄôs name. In XSEarch, proximity is included in the ranking formula in terms of the size of the relationship tree and thus, it is not affected by the order of children. XSEarch employs more information-retrieval techniques than XRANK, namely, tfidf and similarity between the query and the document. The element ranking used in XRANK can also be incorporated in XSEarch, but its utility is not clear. It seems to be useful in DBLP, where references between elements indicate importance. However, what is the significance of a large number of references in a document about geographical data (e.g., Mondial), where references are between neighboring countries? The main contribution of this paper is in laying the foundations for a semantic search engine over XML documents. XSEarch returns semantically related fragments, ranked by estimated relevance. Our system is extensible, and can easily accommodate different types of relationships between nodes. We have shown that it is possible to combine these qualities with an efficient, scalable and modular system. Thus, XSEarch can be seen as a general framework for semantic searching in XML documents. "},{"aspect":"expdata","tweet":""},{"aspect":"background","tweet":" 1 Introduction It is becoming increasingly popular to publish data on the Web in the form of XML documents. Current search engines, which are an indispensable tool for finding HTML documents, have two main drawbacks when it comes to searching for XML documents. First, it is not possible to pose queries that explicitly refer to meta-data (i.e., XML tags). Hence, it is difficult, and sometimes even impossible, to formulate a search query that incorporates semantic knowledge in a clear and precise way. The second drawback is that search engines return references (i.e., links) to documents and not to specific fragments thereof. This is problematic, since large XML documents (e.g., the XML DBLP) may contain Permission to copy without fee all or part of this material is granted provided that the copies are not made or distributed for direct commercial advantage, the VLDB copyright notice and the title of the publication and its date appear, and notice is given that copying is by permission of the Very Large Data Base Endowment. To copy otherwise, or to republish, requires a fee and/or special permission from the Endowment. Proceedings of the 29th VLDB Conference, Berlin, Germany, 2003 School of Computer Science and Engineering The Hebrew University of Jerusalem Jerusalem 91904, Israel {sarina, mamou, yarok, sagiv}@cs.huji.ac.il thousands of elements storing many pieces of information that are not necessarily related to each other. For example, an author is related to titles of papers she wrote, but not to titles of other papers. Actually, if a search engine simply matches the search terms against the documents, it may return documents that do not answer the user\u201aÄôs query. This occurs when distinct search terms are matched to unrelated parts of an XML document, as illustrated in the next example. Example 1.1 Suppose that a user is trying to find papers of Vianu on the topic of logical databases. This might be formulated as the search query: \u201aÄúVianu logical databases\u201aÄù. Consider the XML document fragment below, an excerpt from the XML version of DBLP. <proceedings> <inproceedings> <author>Moshe Y. Vardi<\/author> <title>Querying Logical Databases<\/title> <\/inproceedings> <inproceedings> <author>Victor Vianu<\/author> <title>A Web Odyssey: From Codd to XML<\/title> <\/inproceedings> <\/proceedings> A standard search engine would regard the document above as an appropriate response, since it mentions all the search terms. However, we can easily see that although the search terms appear, they do not all appear in the same context. Thus, the document is not an ideal response to the user\u201aÄôs query. The problem arises since the document is treated as an integral unit. Since a reference to a whole XML document is usually not a useful answer, the granularity of the search should be refined. Instead of returning entire documents, an XML search engine should return fragments of XML documents. A query language for XML, such as XQuery, can be used to extract data from XML documents. However, such a query language is not an alternative to an XML search engine for several reasons. First, the syntax of XQuery is by far more complicated than the syntax of a standard search query. Hence, it is not appropriate for a naive user. Second, rather extensive knowledge of the document structure is required in order to correctly formulate a query. Thus, queries must be formulated on a per document basis. Finally, XQuery lacks any mechanism for ranking answers\u201aÄî an essential feature, since there are likely to be many answers when querying large XML documents. There have been several attempts to extend XQuery-like languages with information-retrieval techniques [5, 10, 11, 6, 15]. However, those languages still suffer from a complex query syntax. Another approach is to add capabilities of meta-data querying to search engines [4, 2]. But answers to those search engines are not required to consist of semantically-related pieces of information, and thus suffer from the problem illustrated in Example 1.1. In [9], we have investigated under what conditions different elements of an XML document are semantically related. In this paper, we show how the theoretical results of [9] can be efficiently combined with information-retrieval techniques to yield XSEarch\u201aÄîa search engine for XML. The design and implementation of XSEarch involved several challenges. First, we developed a syntax for search queries that is suitable for a naive user and facilitates a fine-granularity search. The syntax allows, but does not require, the user to specify how keywords are related to tags; in fact, a search query may consist only of keywords. Second, the theoretical results of [9] were adapted so that XSEarch always returns, as answers, document fragments that are semantically related, even when only keywords (and no tags) are specified in the query. Third, we have combined the notion of semantic relationship with traditional information-retrieval techniques to guarantee that answers are not merely semantically-related fragments, but actually fragments that are highly relevant to the keywords of the query. Fourth, we developed a suitable ranking mechanism that takes into account both the degree of the semantic relationship and the relevance of the keywords. Fifth, we developed index structures and evaluation algorithms that allow the system to deal efficiently with large documents, containing thousands of kilobytes of information, and to generate answers in an order similar to their ranking (thus, avoiding the overhead of sorting all answers before returning any). Sixth, the implementation of XSEarch is extensible in the sense that it can easily accommodate different types of semantic relationships. Section 2 describes the syntax of search queries. Section 3 presents the semantics of queries, which is based on the theory developed in [9]. In Section 4, we show how to rank answers by extending informationretrieval techniques. In Section 5, the XSEarch system implementation is presented. In Section 6, we present our experimental results. Finally, Section 7 considers related work and then concludes. "},{"aspect":"expintro","tweet":" We performed extensive experimentation with the XSEarch system, which was implemented in Java. The experiments were carried out on a Pentium 4, with a CPU of 1.6GHZ and 2GB of RAM, running the Windows XP operating system. Note that Java can only take advantage of up to 1.46GB of RAM. "},{"aspect":"problemdef","tweet":""},{"aspect":"solution","tweet":" 2 Query Syntax The query language of a standard search engine is simply a list of keywords. In some search engines, each keyword can optionally be prepended by a plus sign (\u201aÄú+\u201aÄù). Keywords with a plus sign must appear in a satisfying document, whereas keywords without a plus sign may or may not appear in a satisfying document (but the appearance of such keywords is desirable). The query language of XSEarch is a simple extension of the language described above. In addition to specifying keywords, we allow the user to specify labels and keyword-label combinations that must or may appear in a satisfying document. Formally, a search term has the form l: k, l: or : k where l is a label and k is a keyword. A search term may have a plus sign prepended, in which case it is a required term. Otherwise, it is an optional term. We use t, t1, t2, etc., as an abstract notation for required and optional terms. A query has the form Q(S) where S = t1, . . .,tm is a sequence of required and optional search terms. We sometimes refer to the above query as Q, when S is clear from the context. 3 Query Semantics This section presents the semantics of our queries. In order to satisfy a query Q, each of the required terms in Q must be satisfied. In addition, the elements satisfying Q must be meaningfully related. However, it is difficult to determine when a set of elements is meaningfully related. Therefore, we assume that there is a given relationship R that determines when two nodes are related. We then show how to extend R for arbitrary sets of nodes. We also give one natural example of a relationship, which we call interconnection. In our working system we use the interconnection relationship. However, it is possible to use a different relationship, with little impact on system efficiency. 3.1 Satisfaction of a Search Term We model XML documents as trees in the standard fashion. 1 Each interior node is associated with a label and each leaf node is associated with a sequence of keywords. If k is a keyword in the sequence associated with n, we will also say that n contains k. In Figure 1 there is a tree that represents a small portion of the XML document of the Sigmod Record. 1 XML is sometimes modeled as a graph, instead of a tree, by taking ID/IDREF and XLink links into consideration. In principle, it is possible to use our system even when XML is modeled as a graph. To simplify, we only consider XML trees in this paper. volume (4) 28 title (8) Diluting ACID author (10) position (11) 01 issuesTuple (3) number (5) 4 articles (6) articlesTuple (7) Stirling authors (9) author (12) position (13) 02 Thanisch SigmodRecord (1) issues (2) author (14) Kempster We will refer to this tree as Tsr. The interior nodes are numbered to allow easy reference. Let n be an interior node in a tree T. We say that n satisfies the search term l: k if n is labeled with l and a descendent that contains the keyword k. We say that n satisfies the search term l: if n is labeled with l. Finally, we say that n satisfies the search term : k if n has a leaf child that contains the keyword k. Example 3.1 In the tree Tsr, node number 14 satisfies : Kempster and node number 9 satisfies authors:Kempster. However, node 9 does not satisfy :Kempster, position: or :position. 3.2 Meaningfully Related Sets of Nodes Let T be a tree and R be a binary, reflexive and symmetric relationship on the nodes in T. We assume that R contains pairs of nodes that are meaningfully related. We present two different ways to extend R to arbitrary sets of nodes. We say that a set of nodes N is all-pairs R-related, denoted ¬\u2020 R a {N}, if (n1, n2) is in R, for every pair of nodes n1, n2. Intuitively, this states that a set of nodes is meaningfully related if every pair of nodes in the set is meaningfully related. We say that N is star R-related, denoted ¬\u2020 R s {N}, if there is a node n\u201aàó \u201aàà N such that the pair (n\u201aàó, n) is in R, for all nodes n \u201aàà N. We call n\u201aàó the star center. Intuitively, this states that the nodes of a set are meaningfully related if all these nodes are meaningfully related to a node in the set. Depending on the structure of the documents in a volume (21) 29 position (15) 00 issuesTuple (20) number (22) 1 articlesTuple (16) title (17) On Views and XML articles (23) articlesTuple (24) Figure 1: Part of the Sigmod Record document tree. title (25) Editors Note author (18) position (19) Abiteboul 00 corpus, either the all-pairs relationship or star relationship may be more appropriate. This will be discussed in detail later on in Section 3.6. 3.3 Query Answers Let Q(t1, . . .,tm) be a query. We say that a sequence N = n1, . . .,nm of nodes and null values is an allpairs R-answer for Q if the nodes in N are all-pairs R-related and for all 1 \u201aâ§ i \u201aâ§ m: 1. ni is not the null value if ti is a required term; 2. ni satisfies ti if it is not the null value. Similarly, N is a star R-answer, when the nodes in N are star R-related. We use Ans a,R T (Q) to denote the set of all-pairs R-answers for the query Q over a tree T and use Ans s,R T (Q) to denote the set of star R-answers for Q over T. It is not difficult to see that for all trees T, relationships R and queries Q, Ans a,R T (Q) \u201aäÜ Ans s,R T (Q). Actually, if R is a transitive relationship then, Ans a,R T (Q) = Ans s,R T (Q). Our query answers can have null values in their sequences. However, we are interested in answers that have maximal information. Let Q(S) be a query and let both N and N \u201aÄ≤ be either all-pairs R-answers or star R-answers. We say that an answer N \u201aÄ≤ subsumes N if N \u201aÄ≤ is equal to N on all non-null values of N. Intuitively, if N \u201aÄ≤ subsumes N, then it contains more information. We say that an answer N is maximal if every answer that subsumes N is actually equal to N. For ¬\u2020 ¬° ,R \u201aàà {a, s}, we use MaxAns ¬° ,R T (Q) to denote the set of maximal answers in AnsT (Q). 3.4 The Interconnection Relationship We present a relation which can be used to determine whether a pair of nodes is meaningfully related. We found this relation to be intuitive, and it gave appropriate results in our working system. Let T be a tree and let n1 and n2 be nodes in T. The shortest undirected path between n1 and n2 consists of the paths from the lowest common ancestor of n1 and n2 to n1 and n2. We denote the tree consisting of these two paths as T |n1,n2 . Intuitively, this tree describes the relationship between the nodes n1 and n2. For example in Tsr, depicted in Figure 1, the tree T |8,13 consists of the nodes 7, 8, 9, 12 and 13. We start by giving an intuitive understanding of relationships in a document tree. One may view a node in a tree as representing an entity in the world. Two different nodes with the same label correspond to different entities of the same type. If na is an ancestor of n, then we may understand that n belongs to the entity that na represents. Now, suppose that nodes n and n \u201aÄ≤ have distinct ancestors na and n \u201aÄ≤ a, respectively, such that na and n \u201aÄ≤ a have the same label. Suppose also that n \u201aÄ≤ a is not an ancestor of n, and na is not an ancestor of n \u201aÄ≤ . We may conclude that n and n \u201aÄ≤ are not meaningfully related since they belong to different entities of the same type. Note that both na and n \u201aÄ≤ a must be in the relationship tree of n and n \u201aÄ≤ . Otherwise, they would be ancestors of both n and n \u201aÄ≤ and would not imply that n and n \u201aÄ≤ are unrelated. We demonstrate and extend this intuition with a few examples. Consider nodes 4 and 5 in Tsr (Figure 1). Their relationship tree does not contain two nodes with the same label. Therefore, nodes 4 and 5 are related. However, nodes 4 and 22 are not related since their relationship tree contains different nodes with the label issuesTuple. This reflects the intuition that 4 is the volume of the issue with number node 5 and not the volume of the issue with number node 22. Now, consider nodes 11 and 12 in Tsr. Node 11 belongs to theauthor node numbered 10. However, 12 is a different author node. Therefore, we may conclude that the position in node 11 belongs to node 10 and is not related to node 12. As a final example, consider nodes 10 and 12. These nodes share the same label. However, all their ancestors are the same, and thus, they belong to the same entities. Therefore, we may conclude that nodes 10 and 12 are meaningfully related. In fact, nodes 10 and 12 represent different authors, but they are related by virtue of belonging to the same article. We formalize this idea. Let n and n \u201aÄ≤ be nodes in T. We say that n and n \u201aÄ≤ are interconnected if one of the following conditions holds: 1. T |n,n \u201aÄ≤ does not contain two distinct nodes with the same label or 2. the only two distinct nodes in T |n,n \u201aÄ≤ with the same label are n and n \u201aÄ≤ . We use Ri to denote the interconnection relationship. In the sequel, only the interconnection relationship between nodes will be considered. Hence, usually we will not specify explicitly the relationship considered. 3.5 Complexity In combined complexity both the document and the query are considered as part of the input. This is often of interest since queries may be quite large. In input-output complexity, we analyze the complexity of a problem as a function of the input (i.e., query and document) and the output. This complexity measure is useful when both queries and query results are large. The following complexity results are from [9]. Theorem 3.2 (Evaluation Complexity) Let T be a tree and let Q(S) be a query. \u201aÄ¢ Determining whether MaxAns a,Ri T (Q) ÔøΩ= \u201aàÖ is NPcomplete under combined complexity. \u201aÄ¢ If S contains only optional terms, then MaxAns a,Ri T (Q) can be computed in polynomial time under input-output complexity. \u201aÄ¢ The set MaxAns s,Ri T (Q) can be computed in polynomial time under input-output complexity. 3.6 Examples of Query Semantics Example 3.3 Consider the query Q1, defined as Q1(+title: , author: ). The query Q1 finds pairs of titles and authors, belonging to the same article. Only tuples where the title is non-null will be returned. For both all-pairs and star semantics, the answers created for Tsr are the same, namely (8, 10), (8, 12), (8, 14), (17, 18) and (25, \u201aä\u2022). Consider also the portion of the DBLP document presented in Figure 2. The answers for Q1 over this document would consist of (6, 3) and (6, 4). Observe that although this document differs in structure from Tsr, the correct pairs are found for both documents. Example 3.4 Consider the query Q2 that looks for volumes, authors with the name Kempster, and authors who have published with Kempster: Q2(+volume: , +author:Kempster, author: ). The set of maximal all-pairs answers for Q2 over Tsr only contains answers for which both authors appear under the same articlesTuple node. However, the set of maximal star answers for Q2 over Tsr also contains authors that appear in the same issue, but in different articles. Thus, star answers require a \u201aÄúlooser\u201aÄù inproceedings (1) crossref (2) pages (8) /conf/sigmod/02 author (3) Raman author (4) Hellerstein relationship between the nodes in the answer, and can be viewed as an approximation for all-pairs answers. Currently, in the Sigmod Record, author elements contain theirposition as an attribute and the name of the author simply as data. However, author elements could have been modeled slightly differently, with both name and position as subelements, e.g., <author> <name>Stirling<\/name> <position>01<\/position> <\/author> Observe that Q2 would still retrieve the same answers. However, Q3(+volume: , +name:Kempster, name: ) would not retrieve any answer under all-pairs semantics with a non-null element in its optional-component. Under star semantics, similar answers to those of Q2 would be retrieved. Example 3.5 In Example 1.1 the user wished to find papers of Vianu on the topic of logical databases. In the absence of knowledge of the tags in the document, the query Q4(+:Vianu, +:logical, +:databases) would be used for this purpose. When applying Q4 to the document in Example 1.1, the answer will be empty for both all-pairs and star semantics. We get an empty result since the title node that matches logical and databases is not interconnected to the author node that matches Vianu. This conforms to our intuition of the meaning of Q4. 4 Ranking Answers In the previous section, we presented our semantics for query answers. These semantics combined databaselike ideas (e.g., computing a projection of a document, clear-cut semantics) with a heuristic for defining relationships between nodes. In this section, we extend our semantics with extended traditional information retrieval techniques to rank query answers. 4.1 Weight of a Keyword and of a Label We compute the weight of a keyword (sometimes called a term) k in a given leaf node nl using a variation of the year (5) 2002 title (6) booktitle (7) SIGMOD Partial Results for Online Query Processing Figure 2: Part of the DBLP document tree. 275-286 standard tfidf (term frequency, inverse document frequency) formula. Normally, given a document D and a keyword k appearing in D, the tfidf formula defines a value tfidf(k, D) that represents both the frequency of the keyword k in the document D (i.e., the tf ) and the inverse frequency of the keyword in all the documents in the given corpus (i.e., the idf ). In XSEarch, subtrees of a document are returned to the user. Hence, we compute the weight of keywords at a lower granularity, i.e., at the level of the leaf nodes of a document. This allows us to determine which subtrees of a document are more relevant, thereby enabling us to properly rank query results. Let k be a keyword and nl be a leaf node. We use occ(k, nl) to denote the number of times that k appears in nl. The term frequency of k in nl is defined as tf(k, nl) := occ(k, nl) max{occ(k \u201aÄ≤ , nl) | k \u201aÄ≤ \u201aàà words(nl)} . This is a standard variation of the tf formula that gives a larger weight to frequent keywords in sparse nodes than to those in nodes with many keywords. Let N be the set of all leaf nodes in the corpus. Then, we define ilf (k) := log ÔøΩ 1 + |N| |{n \u201aÄ≤ \u201aàà N | k \u201aàà words(n \u201aÄ≤ )}| ÔøΩ . Intuitively, ilf (k) is the logarithm of the inverse leaf frequency of k, i.e., the number of leaves in the corpus over the number of leaves that contain k. Now we define tfilf(k, nl) as tf(k, nl) √ó ilf (k). Note that by taking a log in the ilf factor, we increase the overall importance of the tf factor. In XSEarch the weight of each keyword in each node is stored in an index. The actual weight stored is a normalized version of the value tfilf(k, nl), denoted as w(k, nl). By definition, w(k, nl) is 0 if k does not appear in nl. A weight of 0 is not stored explicitly in our index. Each label l is associated with a weight w(l) that determines its importance. The label weights can be either user defined or system generated. For example, the user may choose to give the label title a greater weight than the label section. As of now, if the user does not specify label weights, then the system gives the same weight to all labels. In the future we may implement other methods to automatically determine the label weight, such as giving higher weight to less common labels. This information can be derived from the indices we create. 4.2 Ranking Factors A query can have many answers. Therefore, it is of primary importance to rank the answers by their estimated relevance. The XSEarch Ranker gives a score to each query answer N by taking into consideration both the structure of the result as well as its contents. The factors considered are described in detail below. Query and Answer Similarity We use the vector space model, common in information retrieval [1], when determining how well an answer satisfies a query. Let L be the set of all labels and K be the set of all keywords. Each interior node n in the corpus is associated with a vector Vn of size |L √ó K|. The vector Vn is called the profile of n. The profile of n has an entry for each pair (l, k) \u201aàà L √ó K. We use Vn[l, k] to denote the entry of Vn corresponding to the pair (l, k). Let Nleaf be the set of leaf descendents of n. The values in the profile of n, (i.e., Vn) are defined as follows: Vn[l, k] = ÔøΩ ÔøΩ n \u201aÄ≤ \u201aààNleaf w(k, n\u201aÄ≤ ) if label(n) = l 0 otherwise Consider a search term t. (It is irrelevant for our purposes here whether t is an optional or a required term.) The search term t is associated with a vector of size |L √ó K|, denoted Vt. The entries in the vector Vt are defined as follows. If t is of the form : k, then Vt has the value 1 in all dimensions that correspond to the keyword k, and 0 in all other dimensions. If t is of the form l: , then Vt has w(l) in all dimensions that correspond to the label l, and 0 in all other dimensions. If t has the form l: k, then Vt has the value w(l) in exactly the dimension corresponding to (l, k), and 0 in all other dimensions. The measure of similarity between a query Q and an answer N, denoted sim(Q, N), is the sum of the cosine distances between the vectors associated with the nodes in N and the vectors associated with the terms that they match in Q. Relationships between Nodes Let N be a query answer. The nodes in N may appear in the document tree in many different places. Some configurations of the nodes in N seem to be more meaningful. We use tsize(N) to denote the number of nodes in the relationship tree of N. If this value is small, then the nodes in N are close together. Hence, they are more likely to be meaningfully related. Search Query Processor Index Repository Indices User Indexer Ranker 1 2 3 4 L 1 L 2 L 3 L 4 XML Files Figure 3: XSEarch system architecture. We say that nodes n and n \u201aÄ≤ participate in an ancestor-descendent relationship if n is the ancestor of n \u201aÄ≤ or n \u201aÄ≤ is the ancestor of n. In many XML documents, this type of configuration tends to indicate a strong relationship between n and n \u201aÄ≤ . We define anc-des(N) as the number of unordered pairs from N that participate in an ancestor-descendent relationship. Combining the Factors Given a query Q and an answer N, we use the measures sim(Q, N), tsize(N) and anc-des(N) to determine the ranking of the answer. We experimented with the following combination of factors by varying the values of Œ±, Œ≤ and Œ≥ sim(Q, N) Œ± tsize(N) Œ≤ √ó ÔøΩ 1 + Œ≥ √ó anc-des(N) ÔøΩ . (1) Section 6 contains additional details on our experimentation in ranking. 5 System Implementation Our first attempt at implementing our language was to try to translate our queries to XQuery and use an XQuery processor to create the query results. This approach was found inappropriate for several reasons. It was possible to translate our queries to XQuery, since the full XQuery language has Turing machine expressive power. However, the translation was extremely complicated. We tried running queries generated by our translation on several different XQuery processors. Even for very small queries and extremely small documents (of size  20KB), query execution took several hours. In addition, XQuery does not yet have any built-in ranking mechanism, which is sorely needed in the context of searching large document sets. Actually, it is not surprising that this implementation proved infeasible since XQuery systems are generally not optimized for queries of the type that we produced. Hence, we created our own working system, from scratch. ComputeInterconnectionIndex(T) 1. for i:=|T |-1 down to 0 do 2. for j:=i+1 to |T | do 3. if i is an ancestor of j then 4. let ic be the child of i that is on the path to j 5. let jp be the parent of j 6. intercon[i,j] := intercon[ic,j] and label(ic)ÔøΩ=label(j) and 7. intercon[i,jp] and label(i)ÔøΩ=label(jp) 8. for i:=1 to |T | \u201aàí 1 do 9. for j:=i+1 to |T | do 10. if i is not an ancestor of j then 11. let ip be the parent of i 12. let jp be the parent of j 13. intercon[i,j] := intercon[ip,j] and label(ip)ÔøΩ=label(j) and 14. intercon[i,jp] and label(i)ÔøΩ=label(jp) Figure 4: Computing the interconnection index using dynamic programming. The architecture of the XSEarch system is depicted in Figure 3. The basic flow of information is as follows. The user enters a query using a browser. The Search- Query Processor parses the query into a list of search terms. The Index Repository is used to find nodes that satisfy the search terms and to find out whether pairs of nodes are interconnected. The Index Repository responds by checking the stored indices. If these indices do not contain sufficient information, as may be the case when dynamic online indexing is employed (see Section 5.2), the Indexer is used to augment the current indices. Once the relevant information is returned to the Search-Query Processor, it creates the answers, which are ranked, sorted and then returned. We discuss the implementation of the index repository. Implementing this component efficiently was one of the main challenges for our system. The Ranker, another important component, was discussed in Section 4. The query processor is based on the algorithms presented in [9], uses the index structures presented here, and is not discussed due to lack of space. The Indexer creates several different indices in the Index Repository based on a set of XML documents. We do not discuss in detail all of the index structures used (e.g., inverted keyword index, inverted label index, etc.) because of space limitations. Instead, we focus our discussion on the two most important and novel index structures\u201aÄîthe interconnection index and path index. The interconnection index allows for rapid checking of the interconnection relationship. Our path index, allows us to create first answers with higher estimated ranking. It is important to note that for each node we store an encoding that allows us to easily find the lowest common ancestor of any given pair of nodes. Basically, the encoding of a node n, is the encoding of the parent of n, augmented by the index of n among its siblings. This encoding allows the index structures to perform efficiently. 5.1 Dynamic Offline Interconnection Indexing Checking for interconnection of nodes online is expensive. Hence, we decided at first to create a node-interconnection index that would store information about the interconnection relationship between each pair of nodes. This requires solving the following problem. Given a document T, for all pairs of nodes n and n \u201aÄ≤ in T, determine whether n and n \u201aÄ≤ are interconnected. It is easy to see that given a document T and nodes n, n \u201aÄ≤ , it is possible to check whether n and n \u201aÄ≤ are interconnected in time O(|T |), where |T | is the number of nodes in T. It follows that we can check for interconnection of all pairs of nodes in T in time O(|T | 3 ). However, we improved upon this result in our XSEarch implementation by using dynamic programming. We say that nodes n and n \u201aÄ≤ are strongly-interconnected if they are interconnected and are also labeled differently. Essentially, this corresponds to Condition 1 of interconnection from Section 3. Our algorithm is based on the following Lemma. Lemma 5.1 (Interconnection Characterization) Let T be a document and let n and n \u201aÄ≤ be nodes in T. If n is an ancestor of n \u201aÄ≤ , then n and n \u201aÄ≤ are interconnected if and only if the following hold: \u201aÄ¢ the parent of n \u201aÄ≤ is strongly-interconnected with n; \u201aÄ¢ the child of n on the path to n \u201aÄ≤ is stronglyinterconnected with n \u201aÄ≤ . If n is not an ancestor of n \u201aÄ≤ and n \u201aÄ≤ is not an ancestor of n, then n and n \u201aÄ≤ are interconnected if and only if the following hold: \u201aÄ¢ the parent of n \u201aÄ≤ is strongly-interconnected with n; \u201aÄ¢ the parent of n is strongly-interconnected with n \u201aÄ≤ . Theorem 5.2 (All Pairs Interconnection) Let T be a document. Then it is possible to determine interconnection of all pairs of nodes in T in time O(|T | 2 ). Proof (Sketch). Our procedure that solves this problem is presented in Figure 4. For simplicity of exposition, we assume that the nodes in T are numbered 1 through |T |. In addition, we assume that this numbering was derived by a depth-first traversal of T. We use intercon[i,j] to denote the boolean value of whether i and j are interconnected. The index structures that are used to efficiently execute this procedure are not specified. Note that the order that our for loops are evaluated (in Lines 1, 2 and in Lines 8, 9) ensures that the right hand of the assignments in Lines 6 and 13 have already been evaluated. We used the algorithm from Figure 4 in order to compute the interconnection values for all pairs of nodes. In the XSEarch system, we have explored the possibilities of storing the node-interconnection index in either a hashtable or a symmetric matrix. When implemented as a hashtable, the node-interconnection index contains pairs of ids of interconnected nodes. When implemented as a symmetric matrix, the nodeinterconnection index contains a boolean value for each pair of nodes, indicating whether they are interconnected or not. A comparison of time and space efficiency of these structures can be found in Section 6. 5.2 Dynamic Online Interconnection Indexing Offline computation of the node-interconnection index may be expensive (see Section 6.3). In order to amortize the cost of computing this index over the queries received, we have also considered an online indexing method. When indexing online, for each pair of nodes n and n \u201aÄ≤ whose interconnection must be checked (and is not yet known), we compute the section of the node interconnection index corresponding to T |n,n \u201aÄ≤. This can be done in a fashion similar to the procedure presented in Figure 4. We use a hashtable to store the part of the index that has already been computed at any given moment. The hash table contains a boolean value for each pair of nodes whose interconnection has already been checked. The boolean value indicates whether the nodes are interconnected or not. During query processing, usually only a small part of the node-interconnection index will be created, thus the slowdown in response time is not large. In addition, we note that queries tend to have a locality property. Intuitively, queries tend to be similar in the parts of the document that they must access. Therefore, even after many queries have been evaluated, it is likely for the node-interconnection index to be only partially computed. This speeds up execution time when loading the index into main memory. 5.3 Path Index Our ranker (see Equation 1) combines three factors. One, sim(Q, N) Œ± , ranks according to content and the other two rank according to structure. In cases where choosing Œ± = 0 yields a good ranker, the answers can be generated in the order of their ranking. When Œ± ÔøΩ= 0, a good strategy is to generate the top answers, assuming that Œ± = 0, and while the user is looking at those answers, the system can generate and sort all answers for the actual value of Œ±. In the remainder of this section, we show how to generate answers in the order of their ranking when Œ± = 0. Given a document, we first find all the different paths of labels from the root to the leaves. Even very large documents tend to have a relatively small number of such paths [7]. Given two paths of labels, we can determine if they can lead to two interconnected nodes n1 and n2, and if so, we can determine the set of labels in the interconnection tree of n1 and n2. For example, consider the paths of labels p1 = dblp.inproceedings.author and p2 = dblp.inproceedings.title. These can lead to interconnected nodes n1 and n2 only if n1 and n2 share a lowest common ancestor at the second level of the tree (i.e., the inproceedings node). Thus, if these paths of labels lead to interconnected nodes, the relationship tree of those nodes would contain the labels inproceedings,author andtitle. As another example, consider the path p3 = dblp.phdthesis.title. The paths p1 and p3 can lead to interconnected nodes only if their lowest common ancestor is the root. Note that the relationship tree in this case would contain 5 nodes, instead of 3. Thus, a pair of interconnected nodes reachable by p1 and p2 would have a relationship tree of a smaller size (and hence, a higher ranking) than a pair of nodes reachable by p1 and p3. Our path index stores at Path[p1,p2] the labels of the nodes in the interconnection tree defined by the paths p1 and p2, if p1 and p2 can lead to interconnected nodes. In the inverted keyword index, we store for each keyword, the paths in the documents that lead to that keyword. For each of these paths, we store the set of nodes reachable by that path. Similarly, we store for each label, the paths in the document that lead to that label and the nodes reachable by those paths. For efficiency, we actually store a path id instead of the entire path. Now, before creating the answers for a query, we can determine all possible paths that may lead to keywords or labels in the query. In order to check whether a series of paths p1, . . . , pk can lead to k interconnected nodes, it is sufficient to verify that each pair of paths can lead to interconnected nodes [9]. This information appears in the path index. In order to compute the size of the interconnection tree determined by p1, . . . , pk, it is sufficient to check how many distinct labels appear XML Document Size in KB Number of Nodes NII Time (ms) IIH Time (ms) IIM Time (ms) Dream 146 3,360 0.625 36 29 Hamlet 281 6,635 1.11 185 114 Sigmod Record 704 21,246 2.234 1,729 1,552 Mondial 1,198 49,422 10.059 7,837 6,231 Table 1: Test documents for index generation: size in kilobytes, number of nodes and time to create indices. amongPath[pi,pj] for all 1 \u201aâ§ i, j \u201aâ§ k. 2 We create the query answers for the configurations with the highest ranking first. "},{"aspect":"expcomparison","tweet":""}]}