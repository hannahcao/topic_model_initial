{"user_name":" Inverted Files for Text Search Engines ","user_timeline":[{"aspect":"abstract","tweet":" The technology underlying text search engines has advanced dramatically in the past decade. The development of a family of new index representations has led to a wide range of innovations in index storage, index construction, and query evaluation. While some of these developments have been consolidated in textbooks, many specific techniques are not widely known or the textbook descriptions are out of date. In this tutorial, we introduce the key techniques in the area, describing both a core implementation and how the core can be enhanced through a range of extensions. We conclude with a comprehensive bibliography of text indexing literature. Categories and Subject Descriptors: H.3.1 [Information Storage and Retrieval]: Content Analysis and Indexing\u201aÄîIndexing methods; H.3.2 [Information Storage and Retrieval]: Information Storage\u201aÄîFile orzanization; H.3.3 [Information Storage and Retrieval]: Information Search and Retrieval\u201aÄîQuery formulation, retrieval models, search process; D.4.3 [Operating Systems]: File Systems Management\u201aÄîAccess methods, file organization; E.4 [Coding and Information Theory]\u201aÄîData compaction and compression; E.5 [Files]\u201aÄîOrganization/structure; F.2.2 [Analysis of Algorithms and Problem Complexity]: Nonnumerical Algorithms and Problems\u201aÄîSorting and searching; I.7.3 [index Generation] General Terms: Algorithms, Experimentation, Performance Additional Key Words and Phrases: Inverted file indexing, document database, text retrieval, information retrieval, Web search engine "},{"aspect":"expanalysis","tweet":""},{"aspect":"expdata","tweet":""},{"aspect":"background","tweet":" 1. INTRODUCTION Text search is a key technology. Search engines that index the Web provide a breadth and ease of access to information that was inconceivable only a decade ago. Text search has also grown in importance at the other end of the size spectrum. For example, the help services built into operating systems rely on efficient text search, and desktop search systems help users locate files on their personal computers. The Australian Research Council and the Victorian Partnership for Advanced Computing have provided valuable financial support as have our two home institutions. Authors\u201aÄô addresses: J. Zobel, School of Computer Science & Information Technology, RMIT University, Australia; email: jz@cs.rmit.edu.au; A. Moffat, Department of Computer Science & Software Engineering, The University of Melbourne, Australia. Permission to make digital or hard copies of part or all of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or direct commercial advantage and that copies show this notice on the first page or initial screen of a display along with the full citation. Copyrights for components of this work owned by others than ACM must be honored. Abstracting with credit is permitted. To copy otherwise, to republish, to post on servers, to redistribute to lists, or to use any component of this work in other works requires prior specific permission and/or a fee. Permissions may be requested from Publications Dept., ACM, Inc., 1515 Broadway, New York, NY 10036 USA, fax: +1 (212) 869-0481, or permissions@acm.org. c\u201aóã2006 ACM 0360-0300/2006/07-ART6 $5.00 DOI: 10.1145/1132956/1132959 http://doi.acm.org/10.1145/ 1132956.1132959 ACM Computing Surveys, Vol. 38, No. 2, Article 6, Publication date: July 2006. 2 J. Zobel and A. Moffat Search engines are structurally similar to database systems. Documents are stored in a repository, and an index is maintained. Queries are evaluated by processing the index to identify matches which are then returned to the user. However, there are also many differences. Database systems must contend with arbitrarily complex queries, whereas the vast majority of queries to search engines are lists of terms and phrases. In a database system, a match is a record that meets a specified logical condition; in a search engine, a match is a document that is appropriate to the query according to statistical heuristics and may not even contain all of the query terms. Database systems return all matching records; search engines return a fixed number of matches, which are ranked by their statistical similarity. Database systems assign a unique access key to each record and allow searching on that key; for querying on a Web collection, there may be many millions of documents with nonzero similarity to a query. Thus, while search engines do not have the costs associated with operations such as relational join, there are significant obstacles to fast response, that is, a query term may occur in a large number of the documents, and each document typically contains a large number of terms. The challenges presented by text search have led to the development of a wide range of algorithms and data structures. These include representations for text indexes, index construction techniques, and algorithms for evaluation of text queries. Indexes based on these techniques are crucial to the rapid response provided by the major Web search engines. Through the use of compression and careful organization, the space needed for indexes and the time and disk traffic required during query evaluation are reduced to a small fraction of previous requirements. In this tutorial, we explain how to implement high-performance text indexing. Rather than explore all the alternative approaches that have been described (some speculative, some ineffective, and some proven in practice), we describe a simple, effective solution that has been shown to work well in a range of contexts. This indexing core includes algorithms for construction of a document-level index and for basic ranked query evaluation. Given the indexing core, we then sketch some of the principal refinements that have been devised. These include index reorganization, phrase querying, distribution, index maintenance, and, in particular, index compression. The most compelling application of the indexing techniques described in this tutorial is their use in Web search engines and so we briefly review search in the context of the Web. In the context of the different approaches, we identify significant papers and indicate their contribution. Other research topics in text search include innovations such as metasearch, compression techniques for stored documents, and improvements to fundamental technologies such as sorting, storing, and searching of sets of strings. Domains of applicability beyond text include genomic string searching, pattern matching, and proprietary document management systems. These developments are of wide practical importance but are beyond the scope of this tutorial. This article has a slightly unusual structure. The citations are collected into Section 13 which is a critical survey of work in the area. The earlier sections are free of citations, and reflect our desire to present the material as a tutorial that might be useful for people new to the area. To allow the corresponding citations to be accessed, the structure within Section 13 of the previous sections. That is, Section 13 can be used as a \u201aÄúfurther reading\u201aÄù overview for each topic.  "},{"aspect":"expintro","tweet":""},{"aspect":"problemdef","tweet":" 2. TEXT SEARCH AND INFORMATION RETRIEVAL Search engines are tools for finding the documents in a collection that are good matches to user queries. Typical kinds of document collection include Web pages, newspaper articles, academic publications, company reports, research grant applications, manual ACM Computing Surveys, Vol. 38, No. 2, Article 6, Publication date: July 2006. Inverted Files for Text Search Engines 3 pages, encyclopedias, parliamentary proceedings, bibliographies, historical records, electronic mail, and court transcripts. These collections range dramatically in size. The plain text of a complete set of papers written by a researcher over ten years might occupy 10 megabytes, and the same researcher\u201aÄôs (plain text, non-spam) 10-year email archive might occupy 100 megabytes. A thousand times bigger, the text of all the books held in a small university library might occupy around 100 gigabytes. In 2005, the complete text of the Web was probably some several tens of terabytes. Collections also vary in the way they change over time. A newswire archive or digital library might grow only slowly, perhaps by a few thousand documents a day; deletions are rare. Web collections, in contrast, can be highly dynamic. Fortunately, many of the same search and storage techniques are useful for these collections. Text is not the only kind of content that is stored in document collections. Research papers and newspaper articles include images, email includes attachments, and Web collections include audio and video formats. The sizes discussed previously are for text only; the indexing of media other than text is beyond the scope of this tutorial. Query Modes. In traditional databases, the primary method of searching is by key or record identifier. Such searching is rare in text databases. Text in some kinds of collections does have structured attributes such as <author> tags and metadata such as the subject labels used for categorizing books in libraries, but these are only occasionally useful for content-based search and are not as useful as are keys in a relational database. The dominant mode of text search is by its content in order to satisfy an information need. People search in a wide variety of ways. Perhaps the commonest mode of searching is to issue an initial query, scan a list of suggested answers, and follow pointers to specific documents. If this approach does not lead to discovery of useful documents, the user refines or modifies the query and may use advanced querying features such as restricting the search domain or forcing inclusion or omission of specific query terms. In this model of searching, an information need is represented by a query, and the user may issue several queries in pursuit of one information need. Users expect to be able to match documents according to any of the terms they contain. Both casual users and professionals make extensive use of search engines but their typical strategies differ. Casual users generally examine only the first page or so returned by their favorite search engine, while professionals may use a range of search strategies and tools and are often prepared to scrutinize hundreds of potential answers. However, the same kinds of retrieval technique works for both types of searcher. Another contrast with traditional databases is the notion of matching. A record matches an SQL query if the record satisfies a logical condition. A document matches an information need if the user perceives it to be relevant. But relevance is inexact, and a document may be relevant to an information need even though it contains none of the query terms or irrelevant even though it contains them all. Users are aware that only some of the matches returned by the system will be relevant and that different systems can return different matches for the same query. This inexactitude introduces the notion of effectiveness: informally, a system is effective if a good proportion of the first r matches returned are relevant. Also, different search mechanisms have different computational requirements and so measurement of system performance must thus consider both effectiveness and efficiency. There are many ways in which effectiveness can be quantified. Two commonly used measures are precision and recall, respectively the fraction of the retrieved documents that are relevant and the fraction of relevant documents that are retrieved. There are many other metrics in use with differing virtues and differing areas of application. In ACM Computing Surveys, Vol. 38, No. 2, Article 6, Publication date: July 2006. 4 J. Zobel and A. Moffat Fig. 1. TheKeeper database. It consists of six one-line documents. this tutorial, our focus is on describing indexing techniques that are efficient, and we do not review the topic of effectiveness. Worth noting, however, is that the research that led to these efficient indexing techniques included demonstrations that they do not compromise effectiveness. With typical search engines, the great majority of information needs are presented as bag-of-word queries. Many bag-of-word queries are in fact phrases such as proper names. Some queries have phrases marked up explicitly, in quotes. Another common approach is to use Boolean operators such as AND, perhaps to restrict answers to a specific language, or to require that all query terms must be present in an answer. Example Collections. A sample collection, used as an example through this tutorial, is shown in Figure 1. In this Keeper database, only document 2 is about a big old house. But with a simple matching algorithm, the bag-of-words querybig old house matches documents 2 and 3, and perhaps also documents 1 and 4 which containold, but not the other terms. The phrase query \"big old house\" would match only document 2. Another issue is the parsing method used to extract terms from text. For example, when HTML documents are being indexed, should the markup tags be indexed? or terms within tags? And should hyphenated terms be considered as one word or two? An even more elementary issue is whether to stem and casefold, that is, remove variant endings from words, and convert to lowercase. Choice of parsing technique has little impact, however, on indexing. On the other hand, the issue of stopping does affect the cost of indexing and removal of common words or function words such as the and furthermore can have a significant effect. Confusingly, in some information retrieval literature, the task of parsing is known as index term extraction or simply indexing. In this article, indexing is the task of constructing an index. Without stemming, but with casefolding, the vocabulary of Keeper is: and big dark did gown had house in keep keeper keeps light never night old sleep sleeps the town where Stemming might reduce the vocabulary to: and big dark did gown had house in keep light never night old sleep the town where with the exact result dependent on the stemming method used. Stopping might then reduce the Keeper vocabulary to: big dark gown house keep light night old sleep town In addition to the exampleKeeper collection, two hypothetical collections are used to illustrate efficiency issues. The characteristics of these collections are shown in Table I, and, while they are not actual data sets, they are based on experience with real text. Specifically, they are similar to two types of collections provided by the TREC project run by the United States National Institute for Standards and Technology (NIST) (see trec.nist.gov). TREC has been a catalyst for research in information retrieval since 1992, and without it, robust measurement of the techniques described in this tutorial ACM Computing Surveys, Vol. 38, No. 2, Article 6, Publication date: July 2006. Inverted Files for Text Search Engines 5 Table I. Characteristics of Two Hypothetical Text Databases, Used as Examples in This Tutorial NewsWire Web Size (gigabytes) 1 100 Documents 400,000 12,000,000 Word occurrences (without markup) 180,000,000 11,000,000,000 Distinct words (after stemming) ..., 400,000 16,000,000 per document, totaled 70,000,000 3,500,000,000 would have been difficult or impossible. The last line in the table is the number of distinct word-document pairs, that is, the number of word occurrences when duplicates within a document are not counted. Most of the costs required for additional structures scale more or less linearly for collections larger than a gigabyte. For example, in Web data, new distinct words continue to occur at a typical rates of about one per 500\u201aÄì1000 word occurrences. Typical query terms occur in 0.1%\u201aÄì1% of the indexed documents. Taking all of these factors into account, implementors of search engines must design their systems to balance a range of technical requirements: \u201aÄîeffective resolution of queries; \u201aÄîuse of features of conventional text, such as query term proximity, that improve effectiveness; \u201aÄîuse of features of hyperlinked text, such as anchor strings and URL terms, that improve effectiveness; \u201aÄîfast resolution of queries; \u201aÄîminimal use of other resources (disk, memory, bandwidth); \u201aÄîscaling to large volumes of data; \u201aÄîchange in the set of documents; and \u201aÄîprovision of advanced features such as Boolean restriction and phrase querying. This tutorial describes techniques for supporting all of these requirements. Similarity Measures. All current search engines use ranking to identify potential answers. In a ranked query, a statistical similarity heuristic or similarity measure is used to assess the closeness of each document to the textual query. The underlying principle is that the higher the similarity score awarded to a document, the greater the estimated likelihood that a human would judge it to be relevant. The r \u201aÄúmost similar according to the heuristic\u201aÄù documents are returned to the user as suggested answers. To describe the implementation of text retrieval, we first consider evaluation of bag-of-words queries in which similarity is determined by simple statistics. In Section 4, we extend these techniques to phrase queries. Most similarity measures use some composition of a small number of fundamental statistical values: \u201aÄî fd,t, the frequency of term t in document d; \u201aÄî fq,t, the frequency of term t in the query; \u201aÄî ft, the number of documents containing one or more occurrences of term t; \u201aÄîFt, the number of occurrences of term t in the collection; \u201aÄîN, the number of documents in the collection; and \u201aÄîn, the number of indexed terms in the collection. These basic values are combined in a way that results in three monotonicity observations being enforced. ACM Computing Surveys, Vol. 38, No. 2, Article 6, Publication date: July 2006. 6 J. Zobel and A. Moffat (1) Less weight is given to terms that appear in many documents; (2) More weight is given to terms that appear many times in a document; and (3) Less weight is given to documents that contain many terms. The intention is to bias the score towards relevant documents by favoring terms that appear to be discriminatory and reducing the impact of terms that appear to be randomly distributed. A typical older formulation that is effective in practice calculates the cosine of the angle in n-dimensional space between a query vector \u201aå©wq,t\u201aå™ and a document vector \u201aå©wd,t\u201aå™. There are many variations of the cosine formulation. An example is: ÔøΩ wq,t = ln 1 + N Wd = Sq,d = ÔøΩÔøΩ ÔøΩ t w 2 d,t ft ÔøΩ t wd,t ¬∑ wq,t Wd ¬∑ Wq . wd,t = 1 + ln fd,t Wq = ÔøΩ ÔøΩ t w2 q,t The term Wq can be neglected as it is a constant for a given query and does not affect the ordering of documents. Variations on this theme are to avoid use of logarithms, or replace N by maxt{ ft} in the expression for wq,t, or multiply the query-term weights wq,t by 1 + ln fq,t when queries are long, or use a different way of combining wq,t and wd,t, or take Wd to be the length of the document in words or in bytes, and so on. What all of these variants share is that the quantity wq,t typically captures the property often described as the inverse document frequency of the term, or IDF, while wd,t captures the term frequency, or TF, hence the common description of similarity measures as TF√óIDF formulations. Observing that the negative log of a probability is the information content, the score assigned to a document can very loosely be interpreted from an entropy-based perspective as being a sum of information conveyed by the query terms in that document, which maps to the same ordering as the product of their respective probabilities. Similarity formulations that are directly grounded in statistical principles have also proven successful in TREC. The best known of these is the Okapi computation, ÔøΩ ÔøΩ N \u201aàí ft + 0.5 wq,t = ln ¬∑ ft + 0.5 (k3 + 1) ¬∑ fq,t k3 + fq,t wd,t = (k1 + 1) fd,t Kd + fd,t ÔøΩ Kd = k1 (1 \u201aàí b) + b Wd ÔøΩ WA Sq,d = ÔøΩ t\u201aààq wq,t ¬∑ wd,t, in which the values k1 and b are parameters, set to 1.2 and 0.75 respectively; k3 is a parameter that is set to \u201aàû, so that the expression (k3 +1)¬∑ fq,t/ ÔøΩ ÔøΩ k3 + fq,t is assumed to be equivalent to fq,t; and Wd and WA are the document length and average document length, in any suitable units. ACM Computing Surveys, Vol. 38, No. 2, Article 6, Publication date: July 2006. (1) (2) Inverted Files for Text Search Engines 7 Fig. 2. Exhaustive computation of cosine similarity between a query q and every document in a text collection. This approach is suitable only when the collection is small or is highly dynamic relative to the query rate. More recent probabilistic approaches are based on language models. There are many variants; a straightforward language-model formulation is: ÔøΩ |d| fd,t wd,t = log ¬∑ |d|+Œº |d| + ÔøΩ Œº Ft ¬∑ (3) |d|+Œº |C| Sq,d = ÔøΩ t\u201aààq fq,t ¬∑ wd,t, where |d| (respectively, |C|) is the number of term occurrences in document d (respectively, collection C) and Œº is a parameter, typically set to 2500. The left-hand side of the sum is the observed likelihood of the term in the document, while the right-hand side modifies this (using Dirichlet smoothing) by combining it with the observed likelihood of the term in the collection. Taking the smoothed value as an estimate of the probability of the term in the document, this formulation is rank equivalent to ordering documents by the extent to which the query\u201aÄôs entropy in the document\u201aÄôs model differs from the query\u201aÄôs entropy in the collection as a whole. In this language-model formulation, the value wd,t is nonzero even if t is not in d, presenting difficulties for the term-ordered query evaluation strategies we explain later. However, this problem can be addressed by transforming it into a rank-equivalent measure: Sq,d ÔøΩ rank = |q|¬∑log Œº |d|+Œº ÔøΩ + ÔøΩ t\u201aààq\u201aàßd ÔøΩ ÔøΩ ÔøΩÔøΩ fd,t |C| fq,t ¬∑ log ¬∑ + 1 , (4) Œº Ft where the term-oriented component log(1+( fd,t/Œº)¬∑(|C|/Ft)) is zero when t is not in d. In all of these formulations, documents can score highly even if some of the query terms are missing. This is a common attribute of similarity heuristics. We do not explore similarity formulations in detail and take as our brief the need to implement a system in which any such computation can be efficiently computed. Given a formulation, ranking a query against a collection of documents is in principle straightforward: each document is fetched in turn, and the similarity between it and the query calculated. The documents with the highest similarities can then be returned to the user. An algorithm for exhaustive ranking using the cosine measure is shown in Figure 2. The drawback of this approach is that every document is explicitly considered, but for typical situations in which r \u201aâ™ N, only a tiny fraction of documents are returned as answers. For most documents, the vast majority of similarity values are ACM Computing Surveys, Vol. 38, No. 2, Article 6, Publication date: July 2006. 8 J. Zobel and A. Moffat insignificant. The exhaustive approach does, however, illustrate the main features of computing a ranking, and, with a simple reorganization, a more efficient computation can be achieved based on the key observation that, to have a nonzero score, a document must contain at least one query term.  "},{"aspect":"solution","tweet":" 3. INDEXING AND QUERY EVALUATION Fast query evaluation makes use of an index: a data structure that maps terms to the documents that contain them. For example, the index of a book maps a set of selected terms to page numbers. With an index, query processing can be restricted to documents that contain at least one of the query terms. Many different types of index have been described. The most efficient index structure for text query evaluation is the inverted file: a collection of lists, one per term, recording the identifiers of the documents containing that term. Other structures are briefly considered in Section 11, but they are not useful for general-purpose querying. Baseline Inverted File. An inverted file index consists of two major components. The search structure or vocabulary stores for each distinct word t, \u201aÄîa count ft of the documents containing t, and \u201aÄîa pointer to the start of the corresponding inverted list. Studies of retrieval effectiveness show that all terms should be indexed, even numbers. In particular, experience with Web collections shows that any visible component of a page might reasonably be used as a query term, including elements such as the tokens in the URL. Even stopwords\u201aÄîwhich are of questionable value for bag-of-words queries\u201aÄîhave an important role in phrase queries. The second component of the index is a set of inverted lists where each list stores for the corresponding word t, \u201aÄîthe identifiers d of documents containing t, represented as ordinal document numbers; and \u201aÄîthe associated set of frequencies fd,t of terms t in document d. The lists are represented as sequences of \u201aå©d, fd,t\u201aå™ pairs. As described, this is a documentlevel index in that word positions within documents are not recorded. Together with an array of Wd values (stored separately), these components provide all the information required for both Boolean and ranked query evaluation. A complete inverted file for the Keeper database is shown in Figure 3. In a complete text database system, there are several other structures, including the documents themselves and a table that maps ordinal document numbers to disk locations (or other forms of document locator such as a filename or other key). We do not explore these structures in this tutorial. In a simple representation, for the NewsWire data, the total index size would be approximately 435MB (megabytes) or around 40% of the size of the original data. This is comprised of 12MB for 400,000 words, pointers, and counts; 1.6MB for 400,000 Wd values; 280MB for 70,000,000 document identifiers (four bytes each); and 140MB for 70,000,000 document frequencies (two bytes each). For the Web data, the total size is about 21GB (gigabytes) or just over 20% of the original text. The difference between these two collections is a consequence of Web pages tending to contain large volumes of unindexed markup. An assumption made in these calculations is that each inverted list is stored contiguously. The alternative is that lists are composed of a sequence of blocks that are linked or indexed in some way. The assumption of contiguity has a range of implications. First, ACM Computing Surveys, Vol. 38, No. 2, Article 6, Publication date: July 2006. Inverted Files for Text Search Engines 9 Fig. 3. Complete document-level inverted file for the Keeper database. The entry for each term t is composed of the frequency ft and a list of pairs, each consisting of a document identifier d and a document frequency f d,t . Also shown are the Wd values as computed for the cosine measure shown in Equation 1. it means that a list can be read or written in a single operation. Accessing a sequence of blocks scattered across a disk would impose significant costs on query evaluation as the list for a typical query term on the Web data would occupy 100kB (kilobytes) to 1MB, and the inverted list for a common term could be many times this size. Adding to the difficulties for the great majority of terms, the inverted list is much less than a kilobyte, placing a severe constraint on feasible size for a fixed-size block. Second, no additional space is required for next-block pointers. Third, index update procedures must manage variable-length fragments that vary enormously in size, from tiny to vast; our experience, however, is that the benefits of contiguity greatly outweigh these costs. An issue that is considered in detail in Section 8 is how to represent each stored value such as document numbers and in-document frequencies. The choice of any fixed number of bits or bytes to represent a value is clearly arbitrary and has potential implications for scaling (fixed-length values can overflow) and efficiency (inflation in the volume of data to be managed). Using the methods described later in this article, large gains in performance are available through the use of compressed representations of indexes. To facilitate compression, d-gaps are stored rather than straight document identifiers. For example, the sorted sequence of document numbers 7, 18, 19, 22, 23, 25, 63, ... can be represented by gaps 7, 11, 1, 3, 1, 2, 38, ... . ACM Computing Surveys, Vol. 38, No. 2, Article 6, Publication date: July 2006. 10 J. Zobel and A. Moffat Fig. 4. Indexed computation of cosine similarity between a query q and a text collection. Fig. 5. Using an inverted file and a set of accumulators to calculate document similarity scores. While this transformation does not reduce the maximum magnitude of the stored numbers, it does reduce the average, providing leverage for the compression techniques discussed later. Section 8 gives details of mechanisms that can exploit the advantage that is created by gaps. Baseline Query Evaluation. Ranking using an inverted file is described in Figure 4 and illustrated in Figure 5. In this algorithm, the query terms are processed one at a time. Initially each document has a similarity of zero to the query; this is represented by creating an array A of N partial similarity scores referred to as accumulators, one for each document d. Then, for each term t, the accumulator Ad for each document d mentioned in t\u201aÄôs inverted list is increased by the contribution of t to the similarity of d ACM Computing Surveys, Vol. 38, No. 2, Article 6, Publication date: July 2006. Inverted Files for Text Search Engines 11 to the query. Once all query terms have been processed, similarity scores Sd are calculated by dividing each accumulator value by the corresponding value of Wd. Finally, the r largest similarities are identified, and the corresponding documents returned to the user. The cost of ranking via an index is far less than with the exhaustive algorithm outlined in Figure 2. Given a query of three terms, processing a query against the Web data involves finding the three terms in the vocabulary; fetching and then processing three inverted lists of perhaps 100kB to 1MB each; and making two linear passes over an array of 12,000,000 accumulators. The complete sequence requires well under a second on current desktop machines. Nonetheless, the costs are still significant. Disk space is required for the index at 20%\u201aÄì60% of the size of the data for an index of the type shown in Figure 3; memory is required for an accumulator for each document and for some or all of the vocabulary; CPU time is required for processing inverted lists and accumulators; and disk traffic is used to fetch inverted lists. Fortunately, compared to the implementation shown in Figure 4, all of these costs can be dramatically reduced. Indexing Word Positions. We have described inverted lists as sequences of index entries, each a \u201aå©d, fd,t\u201aå™ pair. An index of this form is document-level since it indicates whether a term occurs in a document but does not contain information about precisely where the term appears. Given that the frequency fd,t represents the number of occurrences of t in d, it is straightforward to modify each entry to include the fd,t ordinal word positions p at which t occurs in d and create a word-level inverted list containing pointers of the form \u201aå©d, fd,t, p1, ..., p fd,t \u201aå™. Note that in this representation positions are word counts, not byte counts, so that they can be used to determine adjacency. Word positions can be used in a variety of ways during query evaluation. Section 4 discusses one of these, phrase queries in which the user can request documents with a sequence rather than bag-of-words. Word positions can also be used in bag-of-word queries, for example, to prefer documents where the terms are close together or are close to the beginning of the document. Similarity measures that make use of such proximity mechanisms have not been particularly successful in experimental settings but, for simple queries, adjacency and proximity do appear to be of value in Web retrieval. If the source document has a hierarchical structure, that structure can be reflected by a similar hierarchy in the inverted index. For example, a document with a structure of chapters, sections, and paragraphs might have word locations stored as (c, s, p, w) tuples coded as a sequence of nested runs of c-gaps, s-gaps, p-gaps, and w-gaps. Such an index allows within-same-paragraph queries as well as phrase queries, for example, and with an appropriate representation, is only slightly more expensive to store than a nonhierarchical index. Core Ideas. To end this section, we state several key implementation decisions. \u201aÄîDocuments have ordinal identifiers, numbered from one. \u201aÄîInverted lists are stored contiguously. \u201aÄîThe vocabulary consists of every term occurring in the documents and is stored in a simple extensible structure such as a B-tree. \u201aÄîAn inverted list consists of a sequence of pairs of document numbers and in-document frequencies, potentially augmented by word positions. \u201aÄîThe vocabulary may be preprocessed, by stemming and stopping. \u201aÄîRanking involves a set of accumulators and term-by-term processing of inverted lists. ACM Computing Surveys, Vol. 38, No. 2, Article 6, Publication date: July 2006. 12 J. Zobel and A. Moffat This set of choices constitutes a core implementation in that it provides an approach that is simple to implement and has been used in several public-domain search systems and, we believe, many proprietary systems. In the following sections, we explore extensions to the core implementation. 4. PHRASE QUERYING A small but significant fraction of the queries presented to Web search engines include an explicit phrase, such as\"philip glass\" opera or\"the great flydini\". Users also often enter phrases without explicit quotes, issuing queries such asAlbert Einstein or San Francisco hotel. Intuitively it is appealing to give high scores to pages in which terms appear in the same order and pattern as they appear in the query, and low scores to pages in which the terms are separated. When phrases are used in Boolean queries, it is clear what is intended\u201aÄîthe phrase itself must exist in matching documents. For example, the Boolean query old \"night keeper\" would be evaluated as if it contains two query terms, one of which is a phrase, and both terms would be required for a document to match. In a ranked query, a phrase can be treated as an ordinary term, that is, a lexical entity that occurs in given documents with given frequencies, and contributes to the similarity score for that document when it does appear. Similarity can therefore be computed in the usual way, but it is first necessary to use the inverted lists for the terms in the phrase to construct an inverted list for the phrase itself, using a Boolean intersection algorithm. A question for information retrieval research (and outside the scope of this tutorial) is whether this is the best way to use phrases in similarity estimation. A good question for this tutorial is how to find\u201aÄîin a strictly Boolean sense\u201aÄîthe documents in which a given sequence of words occur together as a phrase since, regardless of how they are eventually incorporated into a matching or ranking scheme, identification of phrases is the first step. An obvious possibility is to use a parser at index construction time that recognizes phrases that might be queried and to index them as if they were ordinary document terms. The set of identified phrases would be added to the vocabulary and have their own inverted lists; users would then be able to query them without any alteration to query evaluation procedures. However, such indexing is potentially expensive. There is no obvious mechanism for accurately identifying which phrases might be used in queries, and the number of candidate phrases is enormous since even the number of distinct two-word phrases grows far more rapidly than the number of distinct terms. The hypothetical Web collection shown in Table I could easily contain a billion distinct two-word pairs. Three main strategies for Boolean phrase query evaluation have been developed. \u201aÄîProcess phrase queries as Boolean bags-of-words so that the terms can occur anywhere in matching document, then postprocess the retrieved documents to eliminate false matches. \u201aÄîAdd word positions to some or all of the index entries so that the locations of terms in documents can be checked during query evaluation. \u201aÄîUse some form of partial phrase index or word-pair index so that phrase appearances can be directly identified. These three strategies can complement each other. However, a pure bag-of-words approach is unlikely to be satisfactory since the cost of fetching just a few nonmatching documents could exceed all other costs combined, and, for many phrases, only a tiny fraction of the documents that contain the query words also contain them as a phrase. ACM Computing Surveys, Vol. 38, No. 2, Article 6, Publication date: July 2006. Inverted Files for Text Search Engines 13 Phrase Query Evaluation. When only document-level querying is required, inclusion of positional information in the index not only takes space, but also slows query processing because of the need to skip over the positional information in each pointer. And, as discussed in more detail in the following, if bag-of-words ranked queries are to be supported efficiently, then other index organizations, such as frequency- and impactsorted arrangements, need to be considered. Taken together, these considerations suggest that maintenance of two separate indexes may be attractive, a word-level index for Boolean searching and phrase identification, and a document-level impact- or frequency-sorted index for processing ranked queries. Given that document-level indexes are small, the space overhead of having multiple indexes is low. Separating the indexes also brings flexibility and allows consideration of index structures designed explicitly for phrases. Many phrases include common words. The cost of phrase query processing using a word-level inverted index is then dominated by the cost of fetching and decoding lists for those words which typically occur at the start of or in the middle of a phrase\u201aÄî consider \"the house in the town\", for example. One way of avoiding this problem would be to neglect certain stop words and index them at the document-level only. For example, to evaluate the query \"the house in the town\" processing could proceed by intersecting the lists forhouse, andtown, looking for positions p ofhouse such thattown is at p + 3. False matches could be eliminated by post-processing, that is, by fetching candidate documents and examining them directly. The possibility of false matches could also simply be ignored. However, in some phrase queries, the common words play an important semantic role and must be included. Phrase Indexes. It is also possible to build a complete index of two-word phrases using a hierarchical storage structure to avoid an overly large vocabulary. Experiments show that such an index occupies around 50% of the size of the source data, that is, perhaps 50GB for theWeb collection. The inverted lists for phrases are on average much shorter than those of the individual words, but there are many more of them, and the vocabulary is also much bigger. Using a two-word phrase index, evaluation of the phrase query \"the house in the town\" (which matches line three of the Keeper collection) involves processing the inverted lists for, say, the phrases \"the house\", \"house in\", and \"the town\". The pair \"in the\" is also a phrase but is covered by the others and\u201aÄîmaking an arbitrary choice between this phrase and \"house in\"\u201aÄîits inverted list does not need to be processed. For phrases composed of rare words, having a phrase index yields little advantage, as processing savings are offset by the need to access a much larger vocabulary. A successful strategy is to have an index for word pairs that begin with a common word and combine it with a word-level inverted index. For example, the preceding query could be evaluated by intersecting the inverted lists for\"the house\",in, and\"the town\".An index of all word pairs beginning with any one of the three commonest words is about 1% of the size of theWeb data but allows phrase querying time to be approximately halved. 5. INDEX CONSTRUCTION The single key problem that makes index construction challenging is that the volume of data involved cannot be held in main memory in a dynamic data structure of the kind typically used for cross-reference generation. The underlying task that needs to be performed is essentially that of matrix transposition. But the documents\u201aÄìterms matrix is very sparse, and is far too large to be manipulated directly as an array. Instead, index construction techniques make use of index compression methods and either distributive or comparison-based sorting techniques. ACM Computing Surveys, Vol. 38, No. 2, Article 6, Publication date: July 2006. 14 J. Zobel and A. Moffat Fig. 6. In-memory inversion. In-Memory Inversion. A simple in-memory inversion algorithm is shown in Figure 6. The key idea is that a first pass through the documents collects term frequency information, sufficient for the inverted index to be laid out in memory in template form. A second pass then places pointers into their correct positions in the template, making use of the random-access capabilities of main memory. The advantage of this approach is that almost no memory is wasted compared to the final inverted file size since there is negligible fragmentation. In addition, if compression is used, the index can be represented compactly throughout the process. This technique is viable whenever the main memory available is about 10%\u201aÄì20% greater than the combined size of the index and vocabulary that are to be produced. It is straightforward to extend the in-memory algorithm to include word positions, but the correspondingly larger final index will more quickly challenge the memory capacity of whatever hardware is being used since individual list entries may become many kilobytes long. It is also possible to extend the in-memory technique to data collections where index size exceeds memory size by laying out the index skeleton on disk, creating a sequence of partial indexes in memory, and then transferring each in a skip-sequential manner to a template that has been laid out as a disk file. With this extended method, and making use of compression, indexes can be built for multi-gigabyte collections using around 10\u201aÄì20MB of memory beyond the space required for a dynamic vocabulary. Sort-Based Inversion. A shortcoming of two-pass techniques of the kind sketched in Figure 6 is that document parsing and fetching is a significant component of index construction costs, perhaps half to two-thirds of the total time for Web data. The documents could be stored parsed during index construction, but doing so implies substantial disk overheads, and the need to write the parsed text may outweigh the cost of the second parsing. Other index construction methods are based on explicit sorting. In a simple form of this approach, an array or file of \u201aå©t, d, fd,t\u201aå™ triples is created in document number order, sorted into term order, and then used to generate the final inverted file. With careful sequencing and use of a multiway merge, the sort can be carried out inplace on disk using compressed blocks. The disk space overhead is again about 10% of the final compressed index size, and memory requirements and speed are also similar to partitioned inversion. As for partitioned inversion, the complete vocabulary must be kept in memory, limiting the volume of data that can be indexed on a single machine. Merge-Based Inversion. As the volumes of disk and data grow, the cost of keeping the complete vocabulary in memory is increasingly significant. Eventually, the index must be created as an amalgam of smaller parts, each of which is constructed using one of the ACM Computing Surveys, Vol. 38, No. 2, Article 6, Publication date: July 2006. Inverted Files for Text Search Engines 15 Fig. 7. Merge-based inversion. Fig. 8. Merge-build process. previous techniques or using purely in-memory structures. Figures 7 and 8 illustrate this process. In merge-based inversion, documents are read and indexed in memory until a fixed capacity is reached. Each inverted list needs to be represented in a structure that can grow as further information about the term is encountered, and dynamically resizable arrays are the best choice. When memory is full, the index (including its vocabulary) is flushed to disk as a single run with the inverted lists in the run stored in lexicographic order to facilitate subsequent merging. As runs are never queried, the vocabulary of a run does not need to be stored as an explicit structure; each term can, for example, be written at the head of its inverted list. Once the run is written, it is entirely deleted from memory so that construction of the next run begins with an initially empty vocabulary. When all documents have been processed, the runs are merged to give the final index. The merging process builds the final vocabulary on the fly and, if a large read buffer is allocated to each run, is highly efficient in terms of disk accesses. If disk space is scarce, the final index can be written back into the space occupied by the runs as they are processed as the final index is typically a little smaller than the runs\u201aÄîvocabulary ACM Computing Surveys, Vol. 38, No. 2, Article 6, Publication date: July 2006. 16 J. Zobel and A. Moffat information is not duplicated, and the final inverted lists can be represented more efficiently. Merge-based index construction is practical for collections of all sizes. In particular, it scales well and operates effectively in as little as 100MB of memory. In addition, disk space overheads can be restricted to a small fraction of the final index; only one parsing pass is required over the data; and the method extends naturally to phrase indexing. Finally, the compression techniques described in Section 8 can further reduce the cost of index construction by reducing the number of runs required. 6. INDEX MAINTENANCE Inserting one document into a text databases involves, in principle, adding a few bytes to the end of every inverted list corresponding to a term in the document. For a document of reasonable size, such an insertion involves fetching and slightly extending several hundred inverted lists and is likely to require 10\u201aÄì20 seconds on current hardware. In contrast, with merge-based inversion, the same hardware can index around 1,000 documents per second. That is, there is a 10,000-fold disparity in cost between these two approaches. For fast insertion, it is necessary to avoid accessing the disk-resident inverted lists of each term. The only practical solution is to amortize the update costs over a sequence of insertions. The properties of text databases, fortunately, allow several strategies for cost amortization. In particular, for ranking, it is not always necessary for new documents to be immediately available for searches. If they are to be searchable, new documents can be made available through a temporary in-memory index\u201aÄîin effect, the last subindex in the merging strategy. Three broad categories of update strategies are available: rebuild from scratch, merge an existing index with an index of new documents, and incremental update. Rebuild. In some applications, the index may not to be updated online at all. Instead, it can be periodically rebuilt from scratch. Consider, for example, a university Web site. New documents are only discovered through crawling and immediate update is not essential. For a gigabyte of data, rebuilding takes just a few minutes, a small cost compared to that of fetching the documents to index. Intermittent Merge. The inverted lists for even large numbers of documents can easily be maintained in the memory of a standard desktop computer. If the lists are in memory, it is cheap to insert new documents as they arrive; indeed, there is no difference between maintaining such lists and the algorithm described in Figure 7. If existing documents are indexed in a standard inverted file and new documents are indexed in memory, the two indexes can share a common vocabulary, and all documents can be made available to queries via a straightforward adaptation of the methods described earlier. Then when memory is full, or some other criterion is met, the in-memory index is merged with the on-disk index. The old index can be used until the merge is complete, at the cost of maintaining two complete copies of the inverted lists. During the merge either a new in-memory index must be created or insertions must temporarily be blocked, and thus, during the merge, new documents are only available via exhaustive search. It was argued earlier that inverted lists should be stored contiguously as accessing a large number of blocks would be a dominant cost of query evaluation. However, if the number of blocks is constrained (for instance, an average of three per term), the time to evaluate queries can similarly be controlled. In addition, if the index is arranged as a sequence of subindexes, each one no greater than a given fraction of the size of the next (that is, the sizes form a geometric sequence), then only a small part of the index is involved in most merge operations. This combination of techniques allow an index to ACM Computing Surveys, Vol. 38, No. 2, Article 6, Publication date: July 2006. Inverted Files for Text Search Engines 17 be built incrementally, and be simultaneously available for querying, in just twice the time required by an offline merge-based build. Incremental Update. A final alternative is to update the main index term by term, as and when opportunity arises, with some terms\u201aÄô in-memory lists covering more documents than others\u201aÄô. This process is similar to the mechanisms used for maintaining variable-length records in a conventional database system. In such an asynchronous merge, a list is fetched from disk, the new information is integrated into the list, and the list is then written back. Using standard free-space management, the list can either be written back in place or, if there is insufficient space, written to a new location. The per-list updates should be deferred for as long as possible to minimize the number of times each list is accessed. The simplest approach is to process as for the merging strategy and, when a memory limit is reached, then proceed through the whole index, amending each list in turn. Other possibilities are to update a list only when it is fetched in response to a query or to employ a background process that slowly cycles through the in-memory index, continuously updating entries. In practice, these methods are not as efficient as intermittent merge, which processes data on disk sequentially. Choosing an Update Strategy. For reasonable collection sizes, merging is the most efficient strategy for update but has the drawback of requiring significant disk overheads. It allows relatively simple recovery as reconstruction requires only a copy of the index and the new documents. In contrast, incremental update proceeds in place with some space lost due to fragmentation. But recovery in an incremental index may be complex due to the need to track which inverted lists have been modified. For smaller, relatively static collections, the cost of rebuild may exceed that of other methods, but still be of little consequence compared to the other costs of maintaining the database. And if the collection is highly dynamic, such as a Web site in which documents are edited as well as inserted, then inserting or deleting a single word in a document may affect all the word positions, for example, and rebuild may be the only plausible option. 7. DISTRIBUTED INFORMATION RETRIEVAL When large volumes of data are involved or when high query volumes must be supported, one machine may be inadequate to support the load even when the various enhancements surveyed earlier are incorporated. For example, in mid-2004, the Google search engine processed more than 200 million queries a day against more than 20TB of crawled data, using more than 20,000 computers. To handle the load, a combination of distribution and replication is required. Distribution refers to the fact that the document collection and its index are split across multiple machines and that answers to the query as a whole must be synthesized from the various collection components. Replication (or mirroring) then involves making enough identical copies of the system so that the required query load can be handled. Document-Distributed Architectures. The simplest distribution regime is to partition the collection and allocate one subcollection to each of the processors. A local index is built for each subcollection; when queries arrive, they are passed to every subcollection and evaluated against every local index. The sets of subcollection answers are then combined in some way to provide an overall set of answers. The advantages of such a document partitioned system are several; collection growth is accommodated by designating one of the hosts as the dynamic collection so that only it needs to rebuild its index; and the computationally expensive parts of the process are distributed equally across all of the hosts in the computer cluster. The dashed region ACM Computing Surveys, Vol. 38, No. 2, Article 6, Publication date: July 2006. 18 J. Zobel and A. Moffat Fig. 9. Two ways in which the index of Figure 3 might be partitioned and distributed across a cluster of machines. in Figure 9 shows one component of a document-distributed retrieval system with this one processor indexing all terms that appear in the first two documents of the collection. Term-Distributed Architectures. An alternative strategy is term partitioning. In a termpartitioned index, the index is split into components by partitioning the vocabulary, with one possible partition shown by the dotted horizontal split in Figure 9. Each processor has full information about a subset of the terms, meaning that to handle a query, only the relevant subset of the processors need to respond. Term partitioning has the advantage of requiring fewer disk seek and transfer operations during query evaluation than document-partitioning because each term\u201aÄôs inverted list is still stored contiguously on a single machine rather than in fragments across multiple machines. On the other hand, those disk transfer operations each involve more data. More significantly, in a term-partitioned arrangement, the majority of the processing load falls to the coordinating machine, and experiments have shown that it can easily become a bottleneck and starve the other processors of work. Choosing a Distribution Strategy. Document distribution typically results in a better balance of workload than does term partitioning and achieves superior query throughput. It also allows more naturally for index construction and for document insertion. On the other hand, index construction in a term-partitioned index involves first of all distributing the documents and building a document-partitioned index, and then exchanging index fragments between all pairs of processors after the vocabulary split has been negotiated. Document distribution also has the pragmatic advantage of still allowing a search service to be provided even when one of the hosts is offline for some reason since any answers not resident on that machine remain available to the system. ACM Computing Surveys, Vol. 38, No. 2, Article 6, Publication date: July 2006. Inverted Files for Text Search Engines 19 On the other hand, in a term-distributed system, having one machine offline is likely to be immediately noticeable. The Google implementation uses a document-partitioned index with massive replication and redundancy at all levels: the machine, the processor cluster, and the site. It is also worth noting that document partitioning remains effective even if the collaborating systems are independent and unable to exchange their index data. A distributed system in which a final result answer list is synthesized from the possibly-overlapping answer sets provided by a range of different services is called a metasearcher. 8. EFFICIENT INDEX REPRESENTATIONS A central idea underpinning several aspects of efficient indexing and query processing is the use of compression. With appropriate compression techniques, it is possible to simultaneously reduce both space consumption and disk traffic. Compression also reduces overall query evaluation time. This section introduces a range of integer coding techniques, and describes their use in inverted file compression. Compact Storage of Integers. In a simple implementation of an inverted file index, 32-bit and 16-bit integers might be used respectively for document identifiers and term frequencies since these sizes are universally supported by compilers and are large enough to hold the likely values. However, fixed-width integers are not particularly spaceefficient, and large savings can be obtained using quite simple compression techniques. An efficient representation for an inverted list requires a method for coding integers in a variable number of bits. Using a fixed number of bits for each number, whether 32 or 20, is inconvenient: it limits the maximum value that can be stored, and is wasteful if most numbers are small. Variable-length codes can be infinite, avoiding the problem of having a fixed upper bound; and can be constructed to favor small values at the expense of large. Parameterless Codes. The simplest variable-bit infinite code is unary which represents the value x > 0asx \u201aàí 1\u201aÄú1\u201aÄù bits followed by a terminating \u201aÄú0\u201aÄù bit. Unary is an example of a fixed code corresponding to a fixed distribution and is unparameterized. Other unparameterized codes for integers are Elias\u201aÄô gamma and delta codes. In the gamma code, integer x > 0 is factored into 2 e + d where e =\u201aåälog 2 x\u201aåã, and 0 \u201aâ§ d < 2 e . The codeword is formed as the concatenation of e + 1 represented in unary and d represented in binary in e bits. In the delta code, the value of e + 1is represented using the gamma code and is followed by d in binary, as for gamma. In both codes, each codeword has two parts, a prefix and a suffix. The prefix indicates the binary magnitude of the value and tells the decoder how many bits there are in the suffix part. The suffix indicates the value of the number within the corresponding binary range. Table II gives some example codewords for each of these three unparameterized codes. The colons used in the codewords to separate the prefix and suffix parts are purely illustrative. Which code is preferable depends on the probability distribution Pr(x) governing the values x that are being coded. Using Shannon\u201aÄôs relationship between the probability of a symbol and its ideal codeword length, len(x) =\u201aàílog 2 Pr(x), it can be seen that unary corresponds to the probability distribution Pr(x) = 2 \u201aàíx . That is, when half of all values are the number 1, a quarter are 2, an eighth are 3, and so on, then unary is the most efficient coding mechanism. When approximately half of all values are the number 1, a quarter are (equally one of) 2 or 3, an eighth are (equally one of) 4, 5, 6, or 7, and so on, and in general Pr(x) \u201aâà 1/(2x 2 ), then gamma is the most efficient coding mechanism. However, inspecting a sequence of bits one by one is relatively costly on machines for which the basic unit of access is multiples of eight bits. If each code occupies a sequence ACM Computing Surveys, Vol. 38, No. 2, Article 6, Publication date: July 2006. 20 J. Zobel and A. Moffat Table II. Example Codewords Using the Unary, Gamma, and Delta Codes value unary gamma delta 1 0 0: 0:: 2 10 10:0 10:0:0 3 110 10:1 10:0:1 4 1110 110:00 10:1:00 10 1111111110 1110:010 110:00:010 100 1111110:100100 110:11:100100 1,000 1111111110:111101000 1110:010:111101000 Colons are used as a guide to show the prefix and suffix components in each codeword. All three codes can represent arbitrarily large numbers; the unary codewords for 100 and 1,000 are omitted only because of their length. Fig. 10. Encoding and decoding variable-length byte-aligned codes. Input values to the encoder must satisfy x \u201aâ\u2022 1. of whole bytes, the bit operations can be eliminated. With this in mind, another simple unparameterized code is to use a sequence of bytes to code a value x \u201aâ\u2022 1, shown in Figure 10. The idea is very simple: if x \u201aâ§ 128, then a single byte is used to represent x \u201aàí 1 in binary, with a leading \u201aÄú0\u201aÄù bit; otherwise, the low-order seven bits of x \u201aàí 1 are packed into a byte with a leading \u201aÄú1\u201aÄù bit, and the quantity (x div 128) is recursively coded the same way. Thus the byte 2, with the bit-pattern 0000 0010, represents the integer 3; the byte 9, with the bit-pattern 0000 1001, represents the (decimal) integer 10; and the doublebyte 147:7, with the bit-pattern 1110 0111 : 0000 0111, represents 1044 since 1044 = 128 √ó (7 + 1) + (147 \u201aàí 127). This approach is a form of gamma code in which the suffix length is a multiple of seven instead of a multiple of one. Several studies have explored bytewise coding and found it to be more efficient than bitwise alternatives. An enhanced version in which the split between continuing and terminating bytes is signaled by a different value than 128 has also been described and offers the possibility of improved compression effectiveness. As well as offering economical decoding, the bytewise coding mechanism facilitates fast stepping through a compressed stream looking for the kth subsequent code. Since each codeword ends with a byte in which the top bit is a \u201aÄú0\u201aÄù, it is easy to step through a compressed sequence and skip over exactly k coded integers without having to decode each of them in full. ACM Computing Surveys, Vol. 38, No. 2, Article 6, Publication date: July 2006. Inverted Files for Text Search Engines 21 Fig. 11. Encoding using a Golomb code with parameter b. Input values must satisfy x \u201aâ\u2022 1. Table III. Example Codewords Using Three Different Golomb Codes value b = 3 b = 5 b = 16 1 0:0 0:00 0:0000 2 0:01 0:01 0:0001 3 0:11 0:10 0:0010 4 10:0 0:110 0:0010 10 1110:0 10:110 0:1001 Colons are used as a guide to show the prefix and suffix components in each codeword. All three codes can represent arbitrarily large numbers. Golomb and Rice Codes. The Elias codes just described have the property that the integer 1 is always encoded in one bit. However, d-gaps of 1 are not particularly common in inverted lists. More pertinently, within the context of a single inverted list with known length, the likely size of the numbers can be accurately estimated. It is therefore desirable to consider schemes that can be parameterized in terms of the average size of the values to be coded. Golomb codes, described in Figure 11, have this property. Integer x \u201aâ\u2022 1 is coded in two parts\u201aÄîa unary bucket selector, and a binary offset within that bucket. The difference between this and the Elias codes is that, in Golomb codes, all buckets are the same size. The use of a variable-length binary code for the remainder r means that no bit combinations are wasted even when the parameter b is not an exact power of two. Table III gives some examples of the codewords generated for different values of b. When b is a power of two, b = 2 k , the suffix part always contains exactly k bits. These are known as Rice codes and allow simpler encoding and decoding procedures. An example Rice code appears in the last column of Table III. Matching Code to Distribution. The implied probability distribution associated with the Elias gamma code was described earlier; Golomb codes are similarly minimumredundancy when Pr(x) \u201aâà (1 \u201aàí p) x\u201aàí1 p , provided that ÔøΩ ÔøΩ log(2 \u201aàí p) b = \u201aâà 0.69 √ó \u201aàí log(1 \u201aàí p) 1 p , where p is the parameter of the geometric distribution (the probability of success in a sequence of independent trials). As we now explain, an inverted list can be represented as a sequence of integers that are, under a reasonable assumption, a sequence of independent (or Bernoulli) trials. Binary Codes. Other coding mechanisms can also perform well and even binary codes can realize compact representations if the data is locally homogeneous. At the same time, they can provide decoding speeds as good as bytewise codes. In the simplest ACM Computing Surveys, Vol. 38, No. 2, Article 6, Publication date: July 2006. 22 J. Zobel and A. Moffat example of this approach, a sequence of values is represented by fitting as many binary codes as possible into the next 32-bit output word. For example, if all of the next seven sequence values are smaller than 17, then a set of 4-bit codewords can be packed into a single output word. Similarly, if all of the next nine values are smaller than 9, an output word containing 3-bit codewords can be constructed. To allow decoding, each word of packed codes is prefixed by a short binary selector that indicates how that word should be interpreted. As with the bytewise coding method, this approach supports fast identification of the kth subsequent codeword since all that is required is that the selector of each word be examined to know how many codewords it contains. Compressing Inverted Lists. The representation of inverted lists introduced earlier described each inverted list as a sequence of \u201aå©d, fd,t\u201aå™ values with the restriction that each document identifier d be an ordinal number. From a database perspective, imposing an ordinal identifier appears to be a poor design decision because it has implications for maintenance. However, text databases are not manipulated and updated in the ways that relational databases are, and, in practice, the use of a simple mapping table obviates the difficulties. The frequencies fd,t are usually small (with a typical median of 1 or 2) and can be efficiently represented using unary or gamma. But representing raw document identifiers using these codes gives no saving since the median value in each inverted list is N/2. On the other hand, if document identifiers are sorted and first-order differences (dgaps) are stored, significant savings are possible. If a term appears in a random subset of ft of the N documents in the collection, the d-gaps conform to a geometric distribution with probability parameter p = ft/N and can thus be coded effectively using a Golomb code or one of the other codes. For example, a Golomb-gamma-coded index of all words and numbers occurring in the documents for theNewsWire collection would occupy about 7% of the text size. In this approach, the representation for each inverted list consists of alternating d-gap values and fd,t values, each occupying a variable number of bits. The d-gap values are represented as Golomb codes, using a parameter b determined from the number of \u201aå©d, fd,t\u201aå™ pairs in that inverted list, and the fd,t values are represented using the gamma code. Use of Golomb codes does, however, present problems for the update strategy of intermittent merge. If Golomb codes are used for representing document identifiers, the merge process involves decoding the existing list and recoding with new parameters, but processing the existing list will then be the dominant cost of update, and should be avoided. One solution is that the old Golomb parameter could continue to be used to compress the added material at some small risk of gradual compression degradation. Alternatively, if static codes are used and lists are document-ordered, new \u201aå©d, fd,t\u201aå™ values can be directly appended to the end of the inverted lists. For other list orderings, such as those described in Section 9, there may be no alternative to complete reconstruction. Compression Effectiveness. The effectiveness of compression regimes is particularly evident for inverted lists representing common words. To take an extreme case, the word the is likely to occur in almost every document (in an English-language collection), and the vast majority of d-gaps in its inverted list will be 1 and represented in just a single bit. Allowing for the corresponding fd,t value to be stored in perhaps (at most) 10\u201aÄì11 bits, around 12 bits is required per \u201aå©d, fd,t\u201aå™ pointer for common words, or one-quarter of the 48 bits that would be required if the pointer was stored uncompressed. The additional space savings that can be achieved with stopping are, for this reason, small. ACM Computing Surveys, Vol. 38, No. 2, Article 6, Publication date: July 2006. Inverted Files for Text Search Engines 23 However, stopping does yield significant advantages during index maintenance because stopping means that updates to the longest lists (those of common words) are avoided. Less frequent words require longer codes for their d-gaps but, in general, shorter codes for their fd,t values. As a general rule-of-thumb, each \u201aå©d, fd,t\u201aå™ pointer in a complete document-level inverted index requires about 8 bits when compressed using a combination of Golomb and Elias codes. Use of the less-precise bytewise code for one of the two components adds around 4 bits per pointer and, for both components, adds around 8 bits per pointer. The word-aligned code has similar performance to the bytewise code for large d-gaps but obtains better compression when the d-gaps are small. For example, a bytewise-gamma-coded index for the NewsWire data (with the d-gaps represented in a bytewise code and the fd,t values coded using gamma) would occupy about 70√ó10 6 √ó12 bits or approximately 10% of the source collection. In this index, the document identifiers are byte aligned, but the fd,t values are not, so the list is organized as a vector of document numbers and a separate vector of frequencies with the two lists decoded in parallel when both components are required. While the compression savings are not as great as those attained by Golomb codes, the bytewise and word-aligned codes bring other benefits. Compression of Word Positions. Uncompressed, at, for instance, two bytes each (so no document can exceed 65,536 words), word positions immediately account for the bulk of index size: 360MB for NewsWire, and 22GB for Web. However, these costs can be reduced by taking differences, just as for document identifiers, and Golomb codes can be used to represent the differences in either a localized within-this-document sense, or, more usefully, in an average-across-all-documents manner. In the latter case, the vocabulary stores two b values, one used to code the d-gaps in the way that was described earlier, and a second to code the w-gaps counting the word intervals between appearances of that term. Static codes\u201aÄîgamma, delta, bytewise, or word-aligned\u201aÄî also give acceptable compression efficiency and may be attractive because of their simplicity. The choice of coding scheme also affects total fetch-and-decode times with the bytewise and word-aligned codes enjoying a clear advantage in this regard. Bitwise codes cannot be easily stepped through, and queries that require only bag-of-words processing can be considerably slower with an interleaved word-level index than with a documentlevel index. An aspect of inverted indexes that is dramatically altered by the introduction of word positions is the cost of processing common words. In a document-level index, common words such as the are relatively cheap to store. In a word-level index, the average perdocument requirement for common words is much larger because of the comparatively large number of fd,t word-gap codes that must be stored. In the case of theWeb data, just a handful of inverted lists account for more than 10% of the total index size. Processing (or even storage) of such lists should be avoided whenever possible. Nonrandom Term Appearances. If documents are chronological, terms tend to cluster. For example, in the 242,918 documents of the Associated Press component of TREC, there are two definite clusters forhurricane, one due to hurricane Gilbert in September 1988, and a second resulting from hurricane Hugo in September 1989. Similar clustering arises with web crawls. Some sites are topic-specific so that words that are rare overall may be common within a group of pages. A particular cause of this effect is indexing of documents that are written in a variety of languages. The nonuniform distribution can be exploited by an interpolative code which transmits the mid-point of the list of document numbers in binary, then recursively handles the two sublists in the resulting narrowed ranges. For typical collections, this code ACM Computing Surveys, Vol. 38, No. 2, Article 6, Publication date: July 2006. 24 J. Zobel and A. Moffat results in an average of 0.5to1.5 bits saved per \u201aå©d, fd,t\u201aå™ pointer compared to a Golomb code. The drawback of the interpolative code is that it is more complex to implement and slower in decoding. The word-aligned binary coding method is also sensitive to localized clustering, a run of consistently small d-gaps is packed more tightly into output words than is a sequence containing occasional larger ones. Pros and Cons of Compression. Compression has immediately obvious benefits. It reduces the disk space needed to store the index; and during query evaluation, it reduces transfer costs (the lists are shorter) and seek times (the index is smaller). Compression also reduces the costs of index construction and maintenance. A less obvious benefit of index compression is that it improves caching. If a typical inverted list is compressed by a factor of six, then the number of inverted lists that can be retained in memory is increased by that same factor. In a retrieval system, queries arrive with a skew distribution with some queries and query terms much more common than others. Queries for Chicago weather forecast far exceed those for Kalgoolie weather forecast, for example. There can also be marked temporal effects. People use Web search engines to check questions on broadcast quiz shows, for example, so the same unusual query might arrive thousands of times in a short space of time. Increasing the effectiveness of caching can dramatically cut the cost of resolving a stream of queries. The principal disadvantage of compression is that inverted lists must be decoded before they are used. A related problem is that they may need to be recoded when they are updated, for example, if parameters change. For some of the codes considered, the addition of new information can require complex recoding. On current desktop machines, the decoding cost is more than offset by the reduction in disk seek costs. More importantly, as the ratio of the speed between processors and disk continues to diverge, the performance benefit available through compression is increasing. For byte- and word-aligned codes, which allow each document identifier to be decoded in just a few instruction cycles, the processing cost is more than offset by the reduction in memory-to-cache transfer costs. Thus, if the index is larger than the available main memory or cannot be buffered for some other reason, there is no disadvantage to compression. And even if the index is in memory, processing can be faster than for uncompressed data. Use of appropriate index compression techniques is an important facet of the design of an efficient retrieval system. 9. LIMITING MEMORY REQUIREMENTS If the standard query evaluation algorithm is used for queries that involve common words, most accumulators are nonzero, and an array of N entries Ad is the most spaceand time-efficient structure. But the majority of those accumulator values are trivially small, as the only matching terms are one or more common words. Analysis of search engine logs has demonstrated that common terms are not the norm in queries, and analysis of relevance has demonstrated that common terms are of low importance. It thus makes sense to ask if there are better structures for the accumulators, requiring fewer than N elements. Accumulator Limiting. If only documents with low ft (i.e., rare) query terms are allowed to have an accumulator, the number of accumulators can be greatly reduced. This strategy is most readily implemented by imposing a limit L on the number of accumulators as shown in Figure 12. ACM Computing Surveys, Vol. 38, No. 2, Article 6, Publication date: July 2006. Inverted Files for Text Search Engines 25 Fig. 12. The limiting method for restricting the number of accumulators during ranked query evaluation. The accumulator limit L must be set in advance. The thresholding method involves a similar computation, but with a different test at step 2(b)i. In ranking, using the models described earlier, a document can have a high similarity score even if several query terms are missing. In the limiting approach, as each \u201aå©d, fd,t\u201aå™ value is processed, a check is made to determine whether there is space in the set of accumulators to consider additional documents. Thus the algorithm enforces the presence of the query terms that are weighted highly because of their frequency of occurrence in the query or because of their rareness in the collection. While the behavior of the ranking is altered, it is arguably for the better since a document that is missing the most selective of the query terms is less likely to be relevant. Some of the Web search engines only return matches in which all of the query terms are present, a strategy that appears to be effective in practice for short queries but, in experimental settings, has been found to be less compelling. Accumulator Thresholding. Another approach of a similar type is to use partial similarities\u201aÄîthe contribution made by a term to a document\u201aÄôs similarity, or wq,t√ówd,t\u201aÄî to determine whether an accumulator should be created. In this approach, accumulators are created if it seems likely that the document will ultimately have a sufficiently high similarity, with the test |A| < L in Figure 12 replaced by a test wq,t √ówd,t > S, for some value S. The threshold S is initially small but is increased during query processing so that it becomes harder for documents to create an accumulator as the computation proceeds. For a set of accumulators that is limited to approximately 1%\u201aÄì5% of the number of documents, in the context of TREC-style long queries and evaluation, there is no negative impact on retrieval effectiveness. However, with Web-style queries, both the limiting and the thresholding methods can be poor. In the limiting method, the limit tends to be reached part way through the processing of a query term, and thus the method favors documents with low ordinal identifiers; but if the limit is only tested between lists, then the memory requirements are highly unpredictable. Similar problems affect thresholding. A solution is to modify the thresholding approach so that, not only are accumulators created when the new contribution is significantly large, but existing accumulators are discarded when they are too small. With this approach, the number of accumulators can be fixed at less than 1% of the number of documents for large Web-like collections. Data Structures. Comparing the two approaches, the limit method gives precise control over memory usage, whereas the threshold method is less rigid and allows even common terms to create accumulators for particular documents if they are sufficiently ACM Computing Surveys, Vol. 38, No. 2, Article 6, Publication date: July 2006. 26 J. Zobel and A. Moffat frequent in those documents. Both methods reduce the number of nonzero accumulators, saving memory space without affecting retrieval effectiveness. And, as examples of more general query pruning methods, they can also reduce disk traffic and CPU time, using methods that are discussed shortly. To maintain the set of accumulators in either of these two approaches, a data structure is required. An obvious solution is to store the accumulators as a list ordered by document number and successively merge it with each term\u201aÄôs inverted list. Representing Document Lengths. Storage of the set of document lengths Wd is another demand on memory during ranking. Figures 2, 4, and 12 suggest that the Wd values be stored in a file on disk, but execution is faster if they can be retained in memory. There are two aspects of their use that make memory residence possible. First, they are an attribute of the document collection rather than of any particular query. This means that the array of W values can be initialized at system startup time rather than for every query and that, in a multithreaded evaluation system, all active queries can access the same shared array. The second aspect that allows memory-residence is that, like many other numeric quantities associated with ranked query evaluation, they are imprecise numbers and result from a heuristic rather than an exact process. Representing them to 64 or 32 bits of precision is, therefore, unnecessary. Experiments have shown that use of 8- or 16-bit approximate weights has negligible effect on retrieval effectiveness. Storage for the Vocabulary. Except for the document mapping table and assorted buffers, the only remaining demand on main memory is the term lookup dictionary or vocabulary. For collections such asNewsWire andWeb, retaining the vocabulary in main memory is expensive since each entry includes a word, ancillary fields such as the weight of that term, and the address of the corresponding inverted list. Fortunately, access to the vocabulary is only a small component of query processing; if a B-tree-like structure is used with the leaf nodes on disk and internal nodes in memory, then a term\u201aÄôs information can be accessed using just a single disk access, and only a relatively small amount of main memory is permanently consumed. For example, consider theWeb collection described in Table I. The 16 million distinct terms in that collection correspond to a vocabulary file of more than 320MB but if each leaf node contains (say) 8kB of data, around 400 vocabulary entries, then the in-memory part of the structure contains only 40,000 words, occupying less than 1MB. As for the document weights, this memory is shared between active queries and is initialized at startup rather than once per query. 10. REDUCING RETRIEVAL COSTS The core implementation, together with simple strategies for reducing memory consumption, provides a functional query evaluation system. For example, in the context of a desktop machine and a gigabyte-scale text collection, typical queries of a few terms can be resolved using these techniques in well under a second. In addition, with accumulator limiting, compact document weights, and a B-tree for the vocabulary, the memory footprint can be limited to a dozen or so megabytes. However, substantial further savings can be made, and, with careful attention to detail, a single standard PC can easily provide text search for a large organization such as a university or corporation. In the core implementation (Figure 4), the principal cost is retrieval and decoding of inverted lists. That is, every \u201aå©d, fd,t\u201aå™ pair contributes to a valid accumulator. With limited-accumulator query evaluation (Figure 12), however, most \u201aå©d, fd,t\u201aå™ pairs do not correspond to a valid accumulator, and processing time spent decoding these pairs is wasted. We also argued earlier that to facilitate compression and the gains that ACM Computing Surveys, Vol. 38, No. 2, Article 6, Publication date: July 2006. Inverted Files for Text Search Engines 27 compression brings, the document numbers in each list should be sorted. However, use of compression means that each number is stored in a variable number of bits or bytes so random access (e.g., to support binary search) into inverted lists is not possible. Skipping. A proposal from the mid-1990s is that decoding costs be reduced by the insertion of additional structure into inverted lists. In this skipping approach, descriptors are periodically embedded in each compressed inverted list, dividing the list into chunks. The descriptor can be used to determine whether any \u201aå©d, fd,t\u201aå™ value in the chunk corresponds to a valid accumulator; if not, that chunk does not need to be decoded, and processing can immediately move to the next chunk. However, all chunks still need to be fetched. Note also that, if the chunks are as large as disk blocks, the great majority will need to be decoded, and, if they are smaller, more chunks can be skipped but most disk blocks will still contain a valid chunk. In experiments at the time, we found that skipping yielded worthwhile performance gains. Since then, processors have become much faster, while disk access times have not greatly improved, and the benefits provided by skipping have eroded. To reduce disk transfer costs, it is necessary to avoid fetching the inverted lists in their entirety. One obvious method is to only fetch inverted lists for rare terms, but experiments consistently show that all terms should be processed if effectiveness is to be maintained. The more attractive option is to rearrange inverted lists so that, in a typical query, only part of each relevant list need be fetched. The schemes described earlier for accumulator limitation provide criteria for deciding whether a \u201aå©d, fd,t\u201aå™ value will be used; we now explain how these criteria can be used to restructure inverted lists without seriously degrading compression effectiveness. Frequency-Ordered Inverted Lists. The principle of accumulator limitation is that large values of wq,t √ówd,t should be processed first. The default heuristic for identifying these values is to process the low- ft terms first as their lists are likely to contain more large wq,t √ó wd,t values than would the lists of high- ft terms. However, in a typical inverted list, most fd,t values are small, while only a few are large. If only the large fd,t values are interesting, that is, can contribute to a useful wq,t √ó wd,t value, then they should be stored at the beginning of their inverted list rather than somewhere in the middle of the document-based ordering. For a given threshold S and term t, all wq,t √ó wd,t > S values (see Equation (1)) will then be stored before any smaller ones. To make use of this idea, the index can be reorganized. A standard inverted list is sorted by document number, for example, \u201aå©12, 2\u201aå™ \u201aå©17, 2\u201aå™ \u201aå©29, 1\u201aå™ \u201aå©32, 1\u201aå™ \u201aå©40, 6\u201aå™ \u201aå©78, 1\u201aå™ \u201aå©101, 3\u201aå™ \u201aå©106, 1\u201aå™. When the list is reordered by fd,t, the example list is transformed into \u201aå©40, 6\u201aå™ \u201aå©101, 3\u201aå™ \u201aå©12, 2\u201aå™ \u201aå©17, 2\u201aå™ \u201aå©29, 1\u201aå™ \u201aå©32, 1\u201aå™ \u201aå©78, 1\u201aå™ \u201aå©106, 1\u201aå™. The repeated frequency information can then be factored out into a prefix component with a counter inserted to indicate how many documents there are with this fd,t value: \u201aå©6:1:40\u201aå™ \u201aå©3:1:101\u201aå™ \u201aå©2:2:12,17\u201aå™ \u201aå©1:4:29,32,78,106\u201aå™. Finally, if differences are taken in order to allow compression, we get \u201aå©6:1:40\u201aå™ \u201aå©3:1:101\u201aå™ \u201aå©2:2:12,5\u201aå™ \u201aå©1:4:29,3,46,28\u201aå™. Repeated frequencies fd,t are not stored, giving a considerable saving. But within each equal-frequency segment of the list, the d-gaps are now on average larger when the document identifiers are sorted, and so the document number part of each pointer ACM Computing Surveys, Vol. 38, No. 2, Article 6, Publication date: July 2006. 28 J. Zobel and A. Moffat Fig. 13. Interleaved processing of inverted lists using a frequency- or impact-sorted index. Blocks from the front of each list are applied to the set of accumulators in decreasing score order until some stopping condition has been met. At the instant shown, 11 blocks have been processed, and, if processing continues, the next block to be processed would be for the term old. increases in cost. In combination, these two effects typically result in frequency-sorted indexes that are slightly smaller than document-sorted indexes. Using a frequency-sorted index, a simple query evaluation algorithm is to fetch each list in turn, processing \u201aå©d, fd,t\u201aå™ values only while wq,t √ó wd,t \u201aâ\u2022 S, where S is the threshold. If disk reads are performed one disk block at a time rather than on a wholeof-inverted-list basis, this strategy significantly reduces the volume of index data to be fetched without degrading effectiveness. A practical alternative is for the first disk block of each list to be used to hold the \u201aå©d, fd,t\u201aå™ values with high fd,t. These important blocks could then all be processed before the remainder of any lists, ensuring that all terms are given the opportunity to create accumulators. The remainder of the list is then stored in document order. A more principled method of achieving the same aim is to interleave the processing of the inverted lists. In particular, once the first block of each list has been fetched and is available in memory, the list with the highest value of wq,t √ówd,t can be selected, and its first run of pointers processed. Attention then switches to the list with the next-highest wq,t √ó wd,t run which might be in a different list or might be in the same list. During query processing, each list could be visited zero, one, or multiple times, depending only on the perceived contribution of that term to the query. The interleaved processing strategy also raises the possibility that query evaluation can be terminated by a time-bound rather than a threshold since the most significant index information is processed first. Figure 13 shows the interleaved evaluation strategy with list sections presumed to be applied to the set of accumulators in decreasing order of numeric score. The shaded sections of each list are never applied. Impact-Ordered Inverted Lists. An issue that remains even in the frequency-sorted approach is that wq,t √ó wd,t/Wd is the true contribution of term t to the similarity score Sq,d, rather than wq,t √ó wd,t. If it makes sense to frequency-sort the inverted lists into decreasing wd,t order, then it makes even better sense to order them in decreasing impact order using wd,t/Wd as a sort key. Then all that remains is to multiply each stored value by wq,t and add it to the corresponding accumulator. That is, an impact value incorporates the division by Wd into the index. ACM Computing Surveys, Vol. 38, No. 2, Article 6, Publication date: July 2006. Inverted Files for Text Search Engines 29 Fig. 14. Impact-ordered query evaluation. If the inverted lists are then sorted by decreasing impact, the same interleaved processing strategy can be employed. Now the blocks in the inverted list must be created artificially rather than occurring naturally, since wd,t/Wd is not integer-valued, and exact sorting would destroy the d-gap compression. Hence, to retain compression, the impact values are quantized so that each stored value is one of a small number of distinct values, and integer surrogates are stored in the inverted lists in place of exact wd,t/Wd values. Experiments with this technique have shown that approximately 10\u201aÄì30 distinct values suffice to give unaltered retrieval effectiveness compared to full evaluation. And, unlike frequency-based methods, impact-sorted lists are just as efficient for evaluation of the Okapi similarity heuristic described in Equation (2). With this change, each list is a document-sorted sequence of blocks of approximately-equal-impact pointers, and no fd,t values are stored. Compared to document- and frequency-sorted indexes, the compressed size grows slightly because the average dgaps are bigger. Nevertheless, the index is still a small fraction of the size of the text being indexed. Query evaluation with an impact-ordered index becomes a matter of processing as many blocks as can be handled in the time that is available. To process a block, an integer contribution score that incorporates the impact score associated with that block and the query term weight wq,t (which might be unity) is added to the accumulator of every document recorded in the block. All query-time operations are on integers, also making the final extraction phase significantly easier to manage. Impact-ordered query evaluation is shown in Figure 14. With an impact-sorted inverted file and integer surrogate weights, query processing is extremely fast. Just as important is that time consumed by each query can be bounded, independent of the number of terms in the query. When query load is light or when a premium service has been purchased, a greater fraction of the blocks in each query can be used to influence the result ranking. Impacts provide another illustration of the flexible constraints on design of algorithms for information retrieval. Information can be selectively thrown away or approximated without detriment to the output of the algorithm, although there may be a beneficial change to efficiency. While the set of documents returned by impact-based processing will not be the same as the set returned by the underlying computation in Equation (1), the quality of the set (proportion of documents that are relevant) may be unchanged. In practice, the effect is likely to be that one method gives better results ACM Computing Surveys, Vol. 38, No. 2, Article 6, Publication date: July 2006. 30 J. Zobel and A. Moffat than the other for some queries and worse results than the other for other queries. Such change-but-no-difference effects are commonly observed in development of algorithms for text query evaluation. Other Considerations. When the inverted lists are impact- or frequency-sorted, they are read in blocks rather than in their entirety, and contiguous storage is no longer a necessity. Blocks with high-impact information could be clustered on disk, further accelerating query processing. The lists for common terms\u201aÄîthe ones with many document pointers\u201aÄîwill never be fully read, and a great deal of disk traffic is avoided. Experiments with these techniques, using collections such asNewsWire, show that disk traffic and processing time are reduced by a factor of up to three compared to previous techniques involving limited accumulators. The likely gain is even greater for the larger Web collection. As a final advantage, the impact-sorted index dispenses with the need for an array or file of Wd values. The disadvantage of both frequency- and impact-sorted indexes is that Boolean queries and index updates are more complex. To handle Boolean queries efficiently, other index structures have been proposed. One approach is to use a blocked index. Rather than use d-gaps that are relative to the previous document number, it is feasible to code d-gaps relative to the start of a block. This allows use of a form of binary search at some loss of compression efficiency. Conjunctive Boolean queries can then be processed extremely quickly. However, updates remain complex. With document-ordered list organizations, new \u201aå©d, fd,t\u201aå™ values can be appended to the list. In the enhanced organizations, the whole of each list must be fetched and decoded. Whether this is a significant disadvantage depends on the application. Summary. We have described compression-based indexing and query evaluation techniques for bag-of-word queries on a text database. Compared to the uncompressed, document-sorted implementation described in Figure 4, \u201aÄîdisk space for a document-level index requires about 7%\u201aÄì9% of the size of the data and has been reduced by a factor of around five; \u201aÄîmemory space for accumulators requires a dozen bytes for 5% of the documents in a small collection or less than 1% of the documents in a large collection and has been reduced by a factor of around twenty; \u201aÄîCPU time for processing inverted lists and updating accumulators is reduced by a factor of three or more; \u201aÄîdisk traffic to fetch inverted lists is reduced by a factor of five in volume and of two or more in time (The relative savings increase with collection size); \u201aÄîthroughput of queries is reduced by making better use of memory, allowing more effective caching of vocabulary entries, lists, and answers; \u201aÄîconstruction time for indexes is cut by a factor of more than two, through reduction in the disk-traffic bottleneck and reduction in the number of runs required to build an index. 11. OTHER APPROACHES TO INDEXING Querying can also be carried out without an index. For typical data and queries, building an index requires about 10\u201aÄì50 times the cost of a string search. If queries are rare, or the data is extremely volatile, it is reasonable to use a document-oriented querying strategy of the type shown in Figure 2. An example is searching of a personal email directory or search within a small collection of files. ACM Computing Surveys, Vol. 38, No. 2, Article 6, Publication date: July 2006. Inverted Files for Text Search Engines 31 Fig. 15. Example of a suffix array. For querying of larger collections, inverted files are not the only technology that has been proposed. The two principal alternatives are suffix arrays and signature files. In this section, we briefly outline these approaches and explain why they are not competitive with inverted files for the applications considered in this article. Suffix Arrays. A suffix array stores pointers into a source string, ordered according to the strings they point at. The index can be of every character position or, for typical retrieval applications, every word position. The structure provides access via a binary search-like process which is fast if it can be assumed that both the array and the underlying source string are available in memory. Consider the first line of the Keeper collection annotated with byte offsets in the string, commencing at zero, as shown in part A of Figure 15. In a word-level suffix array, a list is made of the byte addresses at which words start, shown in the first row of part B of Figure 15. The second row of part B shows the initial two characters of the semi-infinite string that is the target of each pointer. To form the suffix array, the byte pointers are reordered so that the underlying strings are sorted, using as many characters of the semi-infinite strings as are necessary to break ties, as shown in part C. Note that the second of these two lines is provided only to allow the destinations of the pointers to be visualized by the reader. All that is actually stored is the original string, and an array A containing one pointer for each word in the string, with A[0]=36, A[1]=31, and so on. One way of interpreting the resultant array of byte pointers is that they represent a combined vocabulary and inverted index of every suffix string in the original text with access provided directly to the bytes rather than via ordinal document identifiers. To use the suffix array, the sorted byte pointers are binary searched, again using the underlying strings to drive the comparisons. The output of each search is a pair of indices into the suffix array, describing the first and last locations whose strings are consistent with the supplied pattern. For example, to locate occurrences of keep in the example array, the binary search would return 1 and 3 since all ofA[1],A[2], andA[3] contain byte addresses (31, 14, and 21, respectively) pointing at semi-infinite strings in the original text that commence with the prefix keep. (If exactly the word keep was required rather than as a prefix, a trailing delimiter could be added to the search key, and then only A[1]=31 would be returned.) It is straightforward to extend suffix arrays to phrase searching, and a range of simple techniques, such as conflating all nonalphabetic characters to a single separator character for the purposes of string comparison, allow the same binary-searching process to be applied regardless of the length or frequency of the phrase or words in it. ACM Computing Surveys, Vol. 38, No. 2, Article 6, Publication date: July 2006. 32 J. Zobel and A. Moffat Case-folding can also be achieved by making the string comparison function caseinsensitive as has been presumed in the example. For large-scale applications, suffix arrays have significant drawbacks. The pointer array is accessed via binary search so compression is not an option. For a word-aligned suffix array, a 4-byte pointer is needed for each 6 bytes or so of text, and the underlying text must also be retained. In total, the indexing system requires around 170% of the space required by the input, all of it memory-resident. A suffix array-based retrieval system for 1GB of text demands a computer with 2GB or more of memory, a requirement that scales linearly as the source message grows. Suffix array indexes are large compared to inverted files because the repeated information cannot be usefully factored out and because byte addresses are used rather than word-offset addresses. If the base text is large, the suffix array itself can be indexed and partial strings stored in index to avoid needing to access the base text. For very large texts, the pointers can be managed hierarchically. However, these techniques add considerable complexity to the building and searching processes. Another drawback is that there is no equivalent of ranked querying. All but simple stemming regimes are also problematic. On the other hand, suffix arrays offer increased string searching functionality compared to inverted files\u201aÄîcomplex patterns, such as wild-characters, can be handled. The principal strength of suffix arrays is that they greatly accelerategrep-style pattern matching, swapping decreased time for increased space. Worth noting is that much of the functionality offered by a suffix array can be achieved in the context of an inverted file by indexing the vocabulary either with a suffix array spanning the vocabulary strings themselves or by a secondary inverted index making use of the character bigrams or trigrams that comprise the vocabulary terms. Signature Files. Signature files are a probabilistic indexing method. For each term, s bits are set in a signature of w bits. The term descriptors for the terms that appear in each document are superimposed (i.e., OR\u201aÄôed together) to obtain a document descriptor, and the document descriptors are then stored in a signature file of size wN bits for N documents. To query on a term, the query descriptor for that term is formed; all of the documents whose document descriptors are a superset of the query descriptor are fetched; and the false matches are separated from the true matches with only the latter returned to the user as answers. Assuming that all records are the same length, that is, then contain the same number of distinct terms; all terms occurring in over 5% of records are stopped; and there is on average just one false match per single-term query, then the index size is about 20% of the text. With an unstopped index, signatures must be much wider, giving a 40%-of-text index. Variability in document length significantly complicates these calculations. With a fixed-length signature, more bits are set for long documents than short. These documents are then more likely to be selected as false matches, and because they are long, the cost of false-match checking is further increased. To get a false-match volume of one average document-length, a signature file needs to be much larger than the indicative sizes given here. The simplest organization for a signature file is a sequence of signatures, which implies that the whole index is processed in response to each query. A range of alternative organizations of two kinds have been proposed. One is bitslicing in which the signature file, viewed as a matrix, is transposed in which case it is only necessary to fetch a small number of slices\u201aÄîperhaps 10 to 15\u201aÄîin response to a query. Each slice has one bit per stored record, and so, for the Web collection, would contain 1.5MB of data. ACM Computing Surveys, Vol. 38, No. 2, Article 6, Publication date: July 2006. Inverted Files for Text Search Engines 33 Another alternative organization is the use of descriptors in which signatures are partitioned according to a small number of selected bits and only matching partitions are fetched for each query. We are unaware of any practical demonstration of the merits of such descriptor schemes. Bitslicing, however, has been explored experimentally, including a range of variations designed to reduce costs. For example, slice length can be dramatically reduced with a small increase in the number of slices fetched, although costs remain linear in the number of stored documents. Even for the relatively unsophisticated task of Boolean retrieval, signature files have several crucial defects. One is the need to eliminate false matches. For a given signature width, the number of false matches is linear in the collection size and hence, as the number of indexed documents grows, the number of documents unnecessarily fetched increases. For any reasonable parameter settings, this cost must dominate. And the longer a document, the higher the likelihood that it will be retrieved as a false match. Second, signature file indexes are large compared to compressed inverted files and are no easier to construct or maintain. Third, they require more disk accesses for short queries\u201aÄîexactly the kind that is commonplace in Web searching. And fourth, they are even more inefficient if Boolean OR and NOT operators are permitted in addition to AND. More critically, there is no sensible way of using signature files for handling ranked queries or for identifying phrases. That is, there are no situations in which signature files are the method of choice for text indexing even for exact-match Boolean style searching. 12. BEYOND AN ELEMENTARY SEARCH ENGINE We have outlined indexing and query evaluation algorithms that can be used in a practical search engine. These algorithms can be used to index large volumes of data and provide rapid response to user queries. However, in specific searching applications, further improvements in performance are available. In this section, we briefly review some of these options. Crawling. Data acquisition is a key activity in dynamic systems. In unusual cases, the revised content will be delivered as it is generated, and we need do no more than index it. For example, a commercial arrangement might result in the daily delivery of updated catalog entries for an online store. More usually, however, the owners of data change it without regard for whether or not it is indexed. Crawling is the process of seeking out changed data and feeding it back to the retrieval system for incorporation into updated indexes. In principle, crawling is easy, a set of seed URLs is used as the basis for the search, and those pages are fetched one by one. Each hyperlink within those pages is extracted and, if it has not been explored yet, appended to a queue of pending pages. Eventually, all pages reachable from the seed set will have been accessed, and the process can be repeated. However, there are many subtle issues that require attention if a crawler is to be efficient. First, not all pages are of the same importance, and, while crawling the CNN Web site at hourly intervals might be appropriate, crawling a set of University pages probably is not. Indeed, the volume of data available might mean that the crawl simply does not finish before it is necessary to start it again. In this case, a strategy for prioritizing page visits and aborting the crawl when only low-priority pages remain may be required. Second, not all pages are edited at the same rate, and editing may follow a regular pattern. An adaptive crawler might be able to significantly reduce crawl volume by identifying the update strategy that applies to pages and learning which pages are almost never modified. ACM Computing Surveys, Vol. 38, No. 2, Article 6, Publication date: July 2006. 34 J. Zobel and A. Moffat Third, there are crawling traps that need to be anticipated and avoided\u201aÄî unintentional traps such as recursive script-based Web pages that implement calendars with a \u201aÄúnext month\u201aÄù link are just one example. Fourth, the crawler needs to be sensitive to the requirements of the site it is visiting and must stagger its requests so as to avoid flooding it over a short period of time. Fifth, the crawler must be alert to the problem of duplicate pages and mirrored sites. And, finally, crawling is expensive because it involves either payment per gigabyte of data fetched (for some connection modes) whether it is useful or not, or paying for a high-capacity connection to the Internet so that the necessary bandwidth can be achieved. Caching. In many contexts, the same queries and query terms recur. For example, many queries to the Web search engines are topical, and queries to a site-specific search engine may also be clustered. (Many of the queries on the Web site of one of our universities contain the query term results. Over half of these queries are posed on the two single days after first and second semester on which student grades are released.) A search engine can take advantage of this behavior by caching. There are several kinds of information that can be cached. The inverted lists that are fetched in response to a query can be explicitly kept in memory. Alternatively, if these lists are maintained in disk blocks, the operating system is likely to cache them automatically on the basis of most-recently-used. As was noted earlier, compression helps by increasing the impact of this caching. It is tempting to store the vocabulary in memory because doing so means that a disk access is avoided for every query term. However, if the vocabulary is large, keeping it in memory reduces the space available for caching of other information and may not be beneficial overall. Relying on the operating system swapping pages of vocabulary information is almost certainly a poor decision, as the distribution of hot query terms among pages is unlikely to be clustered in a useful way. An alternative is to manage the vocabulary in a B-tree as discussed earlier and to explicitly cache recently-accessed or frequently-accessed query terms in a separate small table. Perhaps the most effective caching is of answer lists. If queries recur, it makes sense to store their answer lists rather than recompute them. Even keeping them on disk is effective as one short answer set can be fetched much more rapidly than can multiple inverted lists. For a typical search engine, most users will only view the first r answers, but it may be effective to keep the next r answers handy for the small percentage of cases in which they are requested. Another form of caching is phrase indexing. Indexing all phrases is impractical, but using term-based inverted lists to identify which documents contain a phrase is expensive. The cost of phrase query processing could be significantly reduced if inverted lists are explicitly maintained for common term combinations. That is, the users themselves, via their querying behavior, can guide the evaluation as to which phrases might be worth explicitly storing when the index is next rebuilt. One of the major bottlenecks of query evaluation is the need to fetch the documents that are presented in the answer lists; most search engines return not only a document identifier but a corresponding document summary or snippet. Typically these summaries are based on the query and thus cannot be computed ahead of time. Saving complete answer pages, including all of the required snippets, can thus be a dramatic saving. Pre-Ordering. In the context of Web retrieval, techniques such as Google\u201aÄôs PageRank can be used to determine a static score for each page to complement the dynamic score calculated by whatever similarity function is being used. The final rank ordering is then a blend of the static score which can be regarded as an a priori probability ordering that a page is relevant to queries in general, and a dynamic score which reflects the probability that a page is relevant to this particular query. ACM Computing Surveys, Vol. 38, No. 2, Article 6, Publication date: July 2006. Inverted Files for Text Search Engines 35 Static rankings are only useful in contexts where additional nontextual information can be used such as (in the case of PageRank) the link structure. The PageRank of a Web page is based on the link structure of the Web. Each page is assigned a score that simulates the actions of a random Web surfer, someone who either with probability p is equally likely to follow any of the links out of the page they are currently on, or with probability 1 \u201aàí p jumps to a new page chosen at random. An iterative computation can be used to compute the long-term probability that such a user is visiting any particular page and that probability is then used to set the PageRank. The effect is that pages with many in-links tend to be assigned high PageRank values, especially if the pages that host those links themselves have a high PageRank; pages with low in-link counts, or inlinks from only relatively improbable pages, are themselves deemed to be improbable as answers. HITS is a similar technique which scores pages as both authorities and hubs, again using a matrix computation based on the connectivity graph established by the Web\u201aÄôs hyperlinks. Loosely, a good hub is one that contains links to many good authorities, and a good authority is one that is linked to from many good hubs. Hubs are useful information aggregations and often provide some broad categorization of a whole topic, whereas authorities tend to provide detailed information about a narrower facet of a topic. Both may be useful to queriers. Pages might also be assigned static scores contributions based on how similar they are to an amalgam of previous queries, or how often users of the search service have clicked through them to read their underlying content, or how deep they are in the directory structure of that particular site. Where static weights are available from some source such as PageRank or HITS, they can potentially be used to eliminate some of the cost of ranking. For example, suppose that inverted lists are maintained in decreasing PageRank order. Then a top-r ranking could be rapidly computed by taking the Boolean intersection of the inverted lists corresponding to the query terms, terminating as soon as r documents containing all of the query terms have been found. These would be presented in decreasing PageRank order. If the user then requests more documents, presumably because the top r are unsatisfactory, then the system simply computes the top 2r, and discards the first r of them. User Feedback. Relevance feedback has been widely explored in the context of information retrieval research. In explicit feedback systems, users identify the answers that are of value (and perhaps others that are not), and this information is incorporated into a revised query, to improve the overall quality of the ranking. Much of this research assumes that queries are independent, and, in practical systems, it has proven difficult to gather relevance assessments from users. However, in a system processing large numbers of queries, it is straightforward to identify which answers users choose to view. The action of a user clicking on a link can be interpreted as a vote for a document. Such voting can be used to alter the static weights of documents and thus their ordering in the ranking generated for subsequent queries even if the subsequent queries differ from the one that triggered the click though. Index Terms. In structured documents, such as those stored as HTML, different emphasis can be placed on terms that appear in different parts of the document. For example, greater weight might be placed on terms that appear in a document\u201aÄôs<title> tags or as part of an <h1> heading. Another important difference between Web searching and more general document retrieval is that the anchor text associated with a link in one page is in many cases an accurate summary of what the target page is about. Links are usually manually ACM Computing Surveys, Vol. 38, No. 2, Article 6, Publication date: July 2006. 36 J. Zobel and A. Moffat inserted, and unless they say \u201aÄúclick here\u201aÄù, 1 represent a succinct assessment to a human author as to the content of the target page. Indexing the anchor text as if it were part of the target page\u201aÄîperhaps even as if it were a title, or heading\u201aÄîcan significantly improve retrieval effectiveness in Web search applications. Another useful technique in Web searching is indexing the URL string itself. For example, the page atwww.qantas.com shows the word Qantas as an image rather than a textual title and unless the URL were parsed into terms and indexed with the document, would risk not being searchable. Page importance can also be biased according to the length of the URL that accesses it on the assumption that URLs with fewer slashes lead to more important pages. Finally, it is worth noting that the <alt> text associated with images is a useful indication of what the image content is, and indexing of<alt> text is part of the Google image search mechanism. Manual Intervention. If some queries are particularly common, then a reasonable strategy for improving perceived performance is to manually alter the behavior of these queries. For example, it might make sense for the termQuantas to be manually associated with the Qantas page, given the high incidence of confusion over the exact name. By the same token, if the queryCNN does not lead directly towww.cnn.com as a result of the ranking heuristic, then direct manipulation to make it so could well be appropriate. One of the most common queries in the search engine of one of our institutions is the single wordlibrary; sadly, the home page of the library is only the fourteenth highest ranked answer.  "},{"aspect":"expcomparison","tweet":""}]}