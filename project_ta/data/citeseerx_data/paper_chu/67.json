{"user_name":" A Foundation for Representing and Querying Moving Objects ","user_timeline":[{"aspect":"abstract","tweet":""},{"aspect":"expanalysis","tweet":" 7. CONCLUSIONS The contribution of this paper is an integrated, comprehensive design of abstract data types involving base types, spatial types, time types, as well as consistent temporal and spatio-temporal versions of these. Embedding this in a DBMS query language, one obtains a query language for spatiotemporal data, and moving objects in particular, whose flexibility, expressivity, and ease of use is so far unmatched in the literature. Some unique aspects of our framework are the following: \u201a€”The emphasis on genericity, closure, and consistency. ACM Transactions on Database Systems, Vol. 25, No. 1, March 2000. A Foundation for Representing and Querying Moving Objects \u201a€¢ 39 \u201a€”The abstract level of modeling. This design includes the first comprehensive model of spatial data types (going beyond the study of just topological relationships) formulated entirely at the abstract infinite point set level. \u201a€”Continuous functions. This is also to our knowledge the first model that deals systematically and coherently with continuous functions as values of attribute data types. \u201a€”Lifting. The idea of defining a kernel algebra over nontemporal types that is then lifted uniformly to operations over temporal types seems to be a new and important concept to achieve consistency between nontemporal and temporal operations. Complete, precise definitions of signatures for all operations and of the semantics of types and operations have been provided. The usability of the design as a query language has been demonstrated by example applications and queries. In this paper we have restricted attention to moving spatial objects in the two-dimensional space. This is motivated by the fact that spatial data types in 2D have been in the focus of database research and are well understood. Also, the temporal versions of two-dimensional objects are embedded in a three-dimensional space, which is still easy to comprehend and visualize. An extension to moving points in the three-dimensional space would probably not be difficult. However, a comprehensive design like the one in this paper, including moving volumes, their projection into space, etc., seems much more involved and is left to future work. The next steps in the line of work suggested by this paper are (i) Design a discrete model. As mentioned earlier, the abstract model of this paper has to be instantiated by selecting discrete representations. The issues arising at this step are discussed in some detail in Erwig et al. [1999]. (ii) Given a discrete model, design appropriate data structures for the types and algorithms for the operations. (iii) Implement the data structures and algorithms in the form of a DBMS extension package for some extensible DBMS interface (e.g., as a data blade). A design of a discrete model has in the meantime been presented in Forlizzi et al. [2000], and the implementation of an extension package is underway. APPENDIX: Definition of Continuity We are interested in a generalized definition of continuity that is valid for all our temporal data types (i.e., types moving(ï¿½)), whereas the well-known classical definition refers only to real-valued functions. The definition should capture discrete changes. A discrete change occurs when, for example, a new point appears in a points value, a curve in a line value suddenly turns by 90 degrees, or a region value (\u201a€œfrom one instance to the next\u201a€) is suddenly displaced to a new position. Intuitively, discontinuity means that ACM Transactions on Database Systems, Vol. 25, No. 1, March 2000. 40 \u201a€¢ R. H. GÃ¼ting et al. the value changes in a single step without traversing all the intermediate stages. We start by slightly modifying the basic definition of continuity. Since we are interested in temporal functions, the definition is given for them directly, rather than in more abstract terms. Definition 19. Let f : A ï¿½ instant3 A ï¿½ ï¿½, and t ï¿½ A ï¿½ instant. f is ï¿½-continuous in t iff @ï¿½ ï¿½ 0 ?ï¿½ ï¿½ 0 such that @ï¿½ ï¿½ ï¿½ : ï¿½ï¿½fï¿½t ï¿½ï¿½ï¿½, fï¿½tï¿½ï¿½ ï¿½ ï¿½ where ï¿½, ï¿½, ï¿½ ï¿½ ï¿½, and ï¿½ is a function ï¿½ : A ï¿½ ï¿½ ï¿½ A ï¿½ ï¿½3ï¿½. Hence, continuity ise determined by the function ï¿½, which expresses a measure of dissimilarity of its two arguments. It should be zero iff the two values are equal, and it should approach zero when the two values get more and more similar. The definition then says that for any chosen threshold ï¿½, we can find an ï¿½-environment of t where dissimilarity is bounded by ï¿½. Definition 20. For any type ï¿½ to which the moving type constructor is applicable, the dissimilarity function ï¿½ is defined as follows: ï¿½ ï¿½ ï¿½int, string, boolï¿½ : ï¿½ï¿½x, yï¿½ ï¿½ ï¿½ 0 if x ï¿½ y 1 otherwise ï¿½ ï¿½ real : ï¿½ï¿½x, yï¿½ ï¿½ ï¿½x ï¿½ yï¿½ ï¿½ ï¿½ point : ï¿½ï¿½p1, p2ï¿½ ï¿½ dï¿½p1, p2ï¿½ ï¿½ ï¿½ points : ï¿½ï¿½p1, p2ï¿½ ï¿½ ï¿½dï¿½p, P2ï¿½ ï¿½ ï¿½dï¿½p, P1ï¿½ pï¿½P1 pï¿½P2 ï¿½ ï¿½ line : ï¿½ï¿½L 1, L 2ï¿½ ï¿½ ï¿½ cï¿½scï¿½L1ï¿½ï¿½0 1 dï¿½cï¿½uï¿½, L 2ï¿½du ï¿½ ï¿½ ï¿½ ï¿½ region : ï¿½ï¿½R 1, R 2ï¿½ ï¿½ sizeï¿½R 1\\R 2ï¿½ ï¿½ sizeï¿½R 2\\R 1ï¿½ cï¿½scï¿½L1ï¿½ï¿½0 1 dï¿½cï¿½uï¿½, L 1ï¿½du Here dï¿½ p1, p2ï¿½ denotes the Euclidean distance between two points, dï¿½ p, Pï¿½ the distance from p to the closest point in P. Similarly, for a line L, dï¿½ p, Lï¿½ denotes the distance from p to the closest point in L. Finally, sizeï¿½Rï¿½ denotes the area of a region R. This means that there are no continuous changes for the three discrete types; whenever the value changes, a discontinuity occurs. For points, dissimilarity is the sum over the distances from each point of one set to the closest point in the other set. For lines, the idea is the same; one just needs to integrate over the simple curves. For regions, dissimilarity is the area of ACM Transactions on Database Systems, Vol. 25, No. 1, March 2000. the symmetric difference. Note that the definition fulfils the requirements stated for ï¿½ above. Based on this, the values of our types moving(ï¿½) can be partitioned along the time domain into maximal continuous pieces. For a value ï¿½ ï¿½ A movingï¿½ï¿½ï¿½, we denote by ï¿½ï¿½ï¿½ï¿½ its set of maximal continuous components. ACKNOWLEDGMENTS We thank the anonymous reviewers whose careful work and suggestions for improvement have led to a much better presentation. "},{"aspect":"expdata","tweet":""},{"aspect":"background","tweet":" 1. INTRODUCTION A common characteristic of concrete, physical objects is that they have a position and an extent in space at any point in time. This applies to countries, land parcels, rivers, taxis, forest-harvesting equipment, fishing boats, air planes, glaciers, lakes, forests, birds, polar bears, and persons, to name but a few types of objects. A wide and increasing range of database applications manage such space and time-referenced objects, termed spatio-temporal objects. In these database applications, the current as well as the past and anticipated future positions and extents of the objects are frequently of interest. This brings about the need for capturing these aspects of the objects in the database. As an example, forest management involves the management of spatiotemporal objects. Forest-harvesting machines have Global Positioning System (GPS) devices attached. A harvesting machine cuts down a pine tree while holding on to the tree; it then strips off the branches while simultaneously cutting the tree into logs of specified lengths and placing the logs in different piles so that similar logs go into the same pile. During this process, the machine measures the amount and properties of the harvested wood (e.g., volumes, diameters, and lengths) and transmits this information, together with the positions of the piles, to headquarters. Together with the orders for wood, this information, along with the present locations of the harvesting machines, is then used for scheduling the pickup of already harvested wood as well as further harvesting. ACM Transactions on Database Systems, Vol. 25, No. 1, March 2000. A Foundation for Representing and Querying Moving Objects \u201a€¢ 3 Two types of spatio-temporal objects may be distinguished, namely discretely moving objects and continuously moving objects. For the former type of object, e.g., land parcels, it is relatively easy to keep track in the database of the objects\u201a€™ changing positions and extents. This may be accomplished by more or less frequent database updates, and solutions exist for capturing and querying discretely changing spatial positions and extents. For example, this may be accomplished by using separate spatial and temporal columns in relational tables. A time interval in the temporal column describes when the spatial value is valid. However, if we consider the temporal development of a spatial value as a function of time, then this strategy can only represent stepwise constant functions. Objects that change position or extent continuously, termed moving objects, for short, are pervasive; but in contrast to the discretely changing objects, they are much more difficult to accommodate in the database. Supporting these kinds of moving objects is exactly the challenge addressed by this paper. It is not feasible to capture these with separate spatial and temporal values, since we do not have stepwise constant functions any longer, and the database cannot be updated for each change to the objects\u201a€™ spatial aspect. Another tack must be adopted. The paper defines a complete framework of abstract data types for moving objects. The proposed framework is intended to serve as a precise and conceptually clean foundation for the representation and querying of spatio-temporal data. While proposals exist for spatial and temporal types, no framework has previously been proposed for spatio-temporal types that includes support for moving objects. (Section 6 positions this paper\u201a€™s contribution with respect to related research.) The framework takes at its outset a set of basic types including standard data types such as integer and Boolean; spatial data types, including point and region; and the temporal type instant. The next step is to introduce type constructors that may be applied to the basic types, thus creating new types. For example, the type constructor \u201a€œmoving\u201a€ that maps an argument type to the type that is a mapping from time to the argument type is included. This leads to types such as moving point, which is a function from instant to point. For example, a harvesting machine\u201a€™s position may be modeled as a moving point. The framework emphasizes three properties, namely: closure, simplicity, and expressiveness. For example, closure dictates that types exist for the domains and ranges of types that are functions between types. It is important to note that in a design of abstract data types like the one of this paper, the definitions of the structure of entities (e.g., values of spatial data types) and of the semantics of operations can be given at different levels of abstraction. For example, the trajectory of a moving point can be described either as a curve or as a polygonal line in two-dimensional space. In the first case, a curve is defined as an (certain kind of) infinite set of points in the plane without fixing any finite representation. In the second case, the definition uses a finite representation of a polygonal line, which in turn defines the infinite point set making up the trajectory of the ACM Transactions on Database Systems, Vol. 25, No. 1, March 2000. 4 \u201a€¢ R. H. GÃ¼ting et al. moving point. In Erwig et al. [1999], the difference between these two levels of modeling is discussed at some depth, and the terms abstract and discrete modeling are introduced for them. Basically, the advantage of the abstract level is that it is conceptually clean and simple, because one does not have to express semantics in terms of the finite representations. One is also free to later select different kinds of finite representations, e.g., polygonal lines, or descriptions based on splines. On the other hand, the additional step of fixing a finite representation is still needed. The advantage of discrete modeling is that it is closer to implementation. The design of this paper is an abstract model in this sense. However, care has been taken to define all data types and operations in such a way that an instantiation with finite representations (e.g., set of polygons for a region) is possible without problems. The proposed abstract data types may be used as column types in conventional relational DBMSs, or they may be integrated in objectoriented or object-relational DBMSs. It is also possible for a user or a third-party developer to implement abstract data types based on this paper\u201a€™s definitions in an extensible DBMS, e.g., a so-called universal server. The paper is structured as follows. Abstract data types consist of data types and operations that encapsulate the data types, i.e., they form an algebra. Section 2 discusses the embedding of such an algebra into a query language. Section 3 proceeds to present the data types in the framework; Section 4 defines the appropriate sets of operations to go with the data types; Section 5 explores the expressiveness of the resulting language within two application areas; Section 6 covers related research; and Section 7 concludes the paper and and points to and identifies promising directions for future research.  "},{"aspect":"expintro","tweet":" <title> A Foundation for Representing and Querying Moving Objects <\/title> <author> RALF HARTMUT GÃœTING FernUniversitÃ¤t Hagen MICHAEL H. BÃ–HLEN Aalborg University MARTIN ERWIG FernUniversitÃ¤t Hagen CHRISTIAN S. JENSEN Aalborg University NIKOS A. LORENTZOS Agricultural University of Athens MARKUS SCHNEIDER FernUniversitÃ¤t Hagen and MICHALIS VAZIRGIANNIS Athens University of Economics and Business <\/author>  <abstract> Spatio-temporal databases deal with geometries changing over time. The goal of our work is to provide a DBMS data model and query language capable of handling such time-dependent geometries, including those changing continuously that describe moving objects. Two fundamental abstractions are moving point and moving region, describing objects for which only the This work was partially supported by the CHOROCHRONOS project, funded by the EU under the Training and Mobility of Researchers Programme, Contract ERB FMRX-CT96-0056. Authors\u201a€™ addresses: R. H. GÃ¼ting, Praktische Informatik IV, FernUniversitÃ¤t Hagen, Hagen, D-58084, Germany; email: gueting@fernuni-hagen.de; M. H. BÃ¶hlen, Department of Computer Science, Aalborg University, Aalborg, DK-9220, Denmark; email: boehlen@cs.auc.dk; M. Erwig, Praktische Informatik IV, FernUniversitÃ¤t Hagen, Hagen, D-58084, Germany; email: erwig@fernuni-hagen.de; C. S. Jensen, Department of Computer Science, Aalborg University, Aalborg, DK-9220, Denmark; email: csj@cs.auc.dk; N. A. Lorentzos, Informatics Laboratory, Agricultural University of Athens, Iera Odos 75, Athens, 11855, Greece; email: lorentzos@auadec.aua.ariadne-t.gr; M. Schneider, Praktische Informatik IV, FernUniversitÃ¤t Hagen, Hagen, D-58084, Germany; email: markus.schneider@fernuni-hagen.de; M. Vazirgiannis, Department of Informatics, Athens University of Economics and Business, Patision 76, Athens, 10434, Greece. Permission to make digital/hard copy of part or all of this work for personal or classroom use is granted without fee provided that the copies are not made or distributed for profit or commercial advantage, the copyright notice, the title of the publication, and its date appear, and notice is given that copying is by permission of the ACM, Inc. To copy otherwise, to republish, to post on servers, or to redistribute to lists, requires prior specific permission and/or a fee. Â© 2000 ACM 0362-5915/00/0300\u201a€“0001 $5.00 ACM Transactions on Database Systems, Vol. 25, No. 1, March 2000, Pages 1\u201a€“42. 2 \u201a€¢ R. H. GÃ¼ting et al. time-dependent position, or position and extent, respectively, are of interest. We propose to represent such time-dependent geometries as attribute data types with suitable operations, that is, to provide an abstract data type extension to a DBMS data model and query language. This paper presents a design of such a system of abstract data types. It turns out that besides the main types of interest, moving point and moving region, a relatively large number of auxiliary data types are needed. For example, one needs a line type to represent the projection of a moving point into the plane, or a \u201a€œmoving real\u201a€ to represent the time-dependent distance of two moving points. It then becomes crucial to achieve (i) orthogonality in the design of the type system, i.e., type constructors can be applied uniformly; (ii) genericity and consistency of operations, i.e., operations range over as many types as possible and behave consistently; and (iii) closure and consistency between structure and operations of nontemporal and related temporal types. Satisfying these goals leads to a simple and expressive system of abstract data types that may be integrated into a query language to yield a powerful language for querying spatio-temporal data, including moving objects. The paper formally defines the types and operations, offers detailed insight into the considerations that went into the design, and exemplifies the use of the abstract data types using SQL. The paper offers a precise and conceptually clean foundation for implementing a spatio-temporal DBMS extension. Categories and Subject Descriptors: H.2.3 [Database Management]: Languages\u201a€”Query languages; H.2.8 [Database Management]: Database applications\u201a€”Spatial databases and GIS General Terms: Languages, Theory Additional Key Words and Phrases: Abstract data types, algebra, moving objects, moving point, moving region, spatio-temporal databases, spatio-temporal data types  <abstract>  <background> 1. INTRODUCTION A common characteristic of concrete, physical objects is that they have a position and an extent in space at any point in time. This applies to countries, land parcels, rivers, taxis, forest-harvesting equipment, fishing boats, air planes, glaciers, lakes, forests, birds, polar bears, and persons, to name but a few types of objects. A wide and increasing range of database applications manage such space and time-referenced objects, termed spatio-temporal objects. In these database applications, the current as well as the past and anticipated future positions and extents of the objects are frequently of interest. This brings about the need for capturing these aspects of the objects in the database. As an example, forest management involves the management of spatiotemporal objects. Forest-harvesting machines have Global Positioning System (GPS) devices attached. A harvesting machine cuts down a pine tree while holding on to the tree; it then strips off the branches while simultaneously cutting the tree into logs of specified lengths and placing the logs in different piles so that similar logs go into the same pile. During this process, the machine measures the amount and properties of the harvested wood (e.g., volumes, diameters, and lengths) and transmits this information, together with the positions of the piles, to headquarters. Together with the orders for wood, this information, along with the present locations of the harvesting machines, is then used for scheduling the pickup of already harvested wood as well as further harvesting. ACM Transactions on Database Systems, Vol. 25, No. 1, March 2000. A Foundation for Representing and Querying Moving Objects \u201a€¢ 3 Two types of spatio-temporal objects may be distinguished, namely discretely moving objects and continuously moving objects. For the former type of object, e.g., land parcels, it is relatively easy to keep track in the database of the objects\u201a€™ changing positions and extents. This may be accomplished by more or less frequent database updates, and solutions exist for capturing and querying discretely changing spatial positions and extents. For example, this may be accomplished by using separate spatial and temporal columns in relational tables. A time interval in the temporal column describes when the spatial value is valid. However, if we consider the temporal development of a spatial value as a function of time, then this strategy can only represent stepwise constant functions. Objects that change position or extent continuously, termed moving objects, for short, are pervasive; but in contrast to the discretely changing objects, they are much more difficult to accommodate in the database. Supporting these kinds of moving objects is exactly the challenge addressed by this paper. It is not feasible to capture these with separate spatial and temporal values, since we do not have stepwise constant functions any longer, and the database cannot be updated for each change to the objects\u201a€™ spatial aspect. Another tack must be adopted. The paper defines a complete framework of abstract data types for moving objects. The proposed framework is intended to serve as a precise and conceptually clean foundation for the representation and querying of spatio-temporal data. While proposals exist for spatial and temporal types, no framework has previously been proposed for spatio-temporal types that includes support for moving objects. (Section 6 positions this paper\u201a€™s contribution with respect to related research.) The framework takes at its outset a set of basic types including standard data types such as integer and Boolean; spatial data types, including point and region; and the temporal type instant. The next step is to introduce type constructors that may be applied to the basic types, thus creating new types. For example, the type constructor \u201a€œmoving\u201a€ that maps an argument type to the type that is a mapping from time to the argument type is included. This leads to types such as moving point, which is a function from instant to point. For example, a harvesting machine\u201a€™s position may be modeled as a moving point. The framework emphasizes three properties, namely: closure, simplicity, and expressiveness. For example, closure dictates that types exist for the domains and ranges of types that are functions between types. It is important to note that in a design of abstract data types like the one of this paper, the definitions of the structure of entities (e.g., values of spatial data types) and of the semantics of operations can be given at different levels of abstraction. For example, the trajectory of a moving point can be described either as a curve or as a polygonal line in two-dimensional space. In the first case, a curve is defined as an (certain kind of) infinite set of points in the plane without fixing any finite representation. In the second case, the definition uses a finite representation of a polygonal line, which in turn defines the infinite point set making up the trajectory of the ACM Transactions on Database Systems, Vol. 25, No. 1, March 2000. 4 \u201a€¢ R. H. GÃ¼ting et al. moving point. In Erwig et al. [1999], the difference between these two levels of modeling is discussed at some depth, and the terms abstract and discrete modeling are introduced for them. Basically, the advantage of the abstract level is that it is conceptually clean and simple, because one does not have to express semantics in terms of the finite representations. One is also free to later select different kinds of finite representations, e.g., polygonal lines, or descriptions based on splines. On the other hand, the additional step of fixing a finite representation is still needed. The advantage of discrete modeling is that it is closer to implementation. The design of this paper is an abstract model in this sense. However, care has been taken to define all data types and operations in such a way that an instantiation with finite representations (e.g., set of polygons for a region) is possible without problems. The proposed abstract data types may be used as column types in conventional relational DBMSs, or they may be integrated in objectoriented or object-relational DBMSs. It is also possible for a user or a third-party developer to implement abstract data types based on this paper\u201a€™s definitions in an extensible DBMS, e.g., a so-called universal server. The paper is structured as follows. Abstract data types consist of data types and operations that encapsulate the data types, i.e., they form an algebra. Section 2 discusses the embedding of such an algebra into a query language. Section 3 proceeds to present the data types in the framework; Section 4 defines the appropriate sets of operations to go with the data types; Section 5 explores the expressiveness of the resulting language within two application areas; Section 6 covers related research; and Section 7 concludes the paper and and points to and identifies promising directions for future research.  <\/background>  <problemdef> 2. PRELIMINARIES: LANGUAGE EMBEDDING In order to illustrate the use of the framework of abstract data types in queries, they must be embedded in a query language. A range of languages would suffice for this purpose, including theoretical and practical languages as well as relational, object-relational, and object-oriented languages. We do not care which language our design, which can be viewed as an application-specific sublanguage, is embedded. In the examples we show an embedding into a relational model and an SQL-like language, with which most readers should be familiar. To achieve a smooth interplay between the embedding language and an embedded system of abstract data types, a few interface facilities and notation are needed, expressible in one form or another in most objectoriented or object-relational query languages. In order not to be bound to any particular SQL standard, we briefly explain our notation for these facilities. ACM Transactions on Database Systems, Vol. 25, No. 1, March 2000. A Foundation for Representing and Querying Moving Objects \u201a€¢ 5 Assignments. The construct LET ï¿½nameï¿½ ï¿½ï¿½queryï¿½ assigns the result of query to a new object called name which can then be used in further steps of a query. Multistep queries. A query can be written as a list of assignments, separated by semicolons, followed by one or more query expressions. The latter are displayed as the result of the query. Conversions between sets of objects and atomic values. In relational terms, this means that a relation with a single tuple and a single attribute can be converted into a typed atomic value and vice-versa. We use the notation ELEMENT(ï¿½queryï¿½) and SET(ï¿½attrnameï¿½, ï¿½valueï¿½) for this. For example, the expression SET(name, \u201a€œJohn Smith\u201a€) returns a relation with an attribute name and a single tuple having John Smith as the value of that attribute. Defining derived attributes. We assume that arbitrary ADT operations over new or old data types may occur anywhere in a WHERE clause, as long as in the end a predicate is constructed, and they can be used in a SELECT clause to produce new attributes, with the notation ï¿½new attrnameï¿½ AS ï¿½expressionï¿½ Defining operations. We allow for the definition of new operations derived from existing ones, in the form LET ï¿½nameï¿½ ï¿½ ï¿½functional expressionï¿½. A functional expression has the form FUN (ï¿½parameter listï¿½) ï¿½expressionï¿½; it corresponds to lambda abstraction in functional languages. Example 1. This example shows how a new operation \u201a€œsquare\u201a€ can be defined and used. LET square ï¿½ FUN (m:integer)m*m;square(5) Defining aggregate functions. Any binary, associative, and commutative operation defined on a data type can be used as an aggregate function over a column of that data type, using the notation AGGR(ï¿½attrnameï¿½, ï¿½operatorï¿½, ï¿½neutral elementï¿½). In case the relation is empty, the neutral element is returned. In case it has a single tuple, then that single attribute value is returned; otherwise the existing values are combined by the given operator. Moreover, a name for the aggregate function can be defined by LET ï¿½nameï¿½ï¿½AGGREGATE(ï¿½operatorï¿½, ï¿½neutral elementï¿½). Example 2. Given a relation emp(name:string, salary:int, permanent:bool), we can sum all salaries by SELECT AGGR(salary, ï¿½, 0) FROM emp We can determine whether all employees have permanent positions by LET all ï¿½ AGGREGATE(and, TRUE); SELECT all(permanent) FROM emp ACM Transactions on Database Systems, Vol. 25, No. 1, March 2000. 6 \u201a€¢ R. H. GÃ¼ting et al. Table I. Signature for Stack Operations Operator Signature empty 3 STACK push STACK ï¿½ INT 3 STACK pop STACK 3 INT  <\/problemdef>  <solution> 3. SPATIO-TEMPORAL DATA TYPES In this and the next section we define a system of data types and operations, or an algebra, suitable for representing and querying geometries changing over time, and in particular, moving objects. Defining an algebra consists of two steps. In the first step we design a type system by introducing some basic types as well as some type constructors. For each type in the type system, its semantics is given by defining a carrier set. In the second step we design a collection of operations over the types of the type system. For each operation, its signature is defined, describing the syntax of the operation, i.e., the correct argument and result types, and its semantics is given by defining a function on the carrier sets of the argument types. In this section we define the type system; operations are given in Section 4. 3.1 The Type System We define the type system as a signature. Any (many-sorted) signature consists of sorts and operators, where the sorts control the applicability of operators (see, e.g., Loeckx et al. [1996]). A signature generates a set of terms. Signatures are well known from the definition of abstract data types. For example, in the description of a stack we have sorts STACK, INT, and BOOL, and operators push, pop, and empty, as shown in Table I. A term of this signature is push(empty, 8). When we use a signature for defining a type system, the sorts are called kinds and describe certain subsets of types, and in the role of operators we have type constructors. The terms generated by the signature describe exactly the types available in our type system. For more background on this technique for defining type systems and algebras, see GÃ¼ting [1993]. Table II shows the signature defining our type system. Here, kinds are written in capitals and type constructors in italics. Terms, and therefore types, generated by this signature are, e.g., int, region, moving(point), range(int), etc. The range type constructor is applicable to all the types in the kind BASE and all types in kind TIME, hence all types that can be constructed by it are range(int), range(real), range (string), range(bool), and range(instant). Type constructors with no arguments, for example region, are types already and are called constant types. One can see that quite a few types are around. Although the focus of interest are the spatio-temporal types, especially moving(point) and moving(region), to obtain a closed system of operations it is necessary to include the related spatial, time, and base types into the design. ACM Transactions on Database Systems, Vol. 25, No. 1, March 2000. A Foundation for Representing and Querying Moving Objects \u201a€¢ 7 Table II. Signature Describing the Type System Type constructor Signature int, real, string, bool 3 BASE point, points, line, region 3 SPATIAL instant 3 TIME moving, intime BASE ï¿½ SPATIAL 3 TEMPORAL range BASE ï¿½ TIME 3 RANGE So far we have just introduced some names for types. In the sequel we describe their semantics first informally, and then formally by defining carrier sets. We start with the constant types and then discuss (proper) type constructors. 3.1.1 Base Types. The base types are int, real, string, and bool. All base types have the usual interpretation, except that each domain is extended by the value ï¿½ (undefined). Definition 1. For a type ï¿½ its carrier set is denoted by Aï¿½. The carrier sets for the types int, real, string, and bool, are defined as A int\u201a€“ï¿½ï¿½ï¿½ï¿½ï¿½, A real\u201a€“ï¿½ï¿½ï¿½ï¿½ï¿½, A string\u201a€“V * ï¿½ ï¿½ï¿½ï¿½, where V is a finite alphabet, A bool\u201a€“ï¿½FALSE, TRUEï¿½ ï¿½ ï¿½ï¿½ï¿½. We sometimes need to talk about the carrier set without the undefined value. As a shorthand for this, we define Aï¿½ ï¿½\u201a€“A ï¿½\\ï¿½ï¿½ï¿½. 3.1.2 Spatial Types. Basic conceptual entities that have been identified in spatial database research are point, line, and region [GÃ¼ting 1994]. In our design we use four types called point, points, line, and region. They are illustrated in Figure 1. Informally, these types have the following meaning. A value of type point represents a point in the Euclidean plane or is undefined. A points value is a finite set of points. A line value is a finite set of continuous curves in the plane. A region is a finite set of disjoint parts called faces, each of which may have holes. It is allowed that a face lies within a hole of another face. Each of the three set types may be empty. Formal definitions are based on the point set paradigm and on point set topology. The point set paradigm expresses that space is composed of infinitely many points and that spatial objects are distinguished subsets of space which are viewed as entities. Point set topology provides concepts of continuity and closeness and allows one to identify special topological structures of a point set like its interior, closure, boundary, and exterior. ACM Transactions on Database Systems, Vol. 25, No. 1, March 2000. 8 \u201a€¢ R. H. GÃ¼ting et al. a point value a points value a line value a region value Fig. 1. The spatial data types. We assume the reader is familiar with basic concepts of topology 1 [Gaal 1964]. Point and point set types are still quite simple: Definition 2. The carrier sets for the types point and points are: A points\u201a€“ï¿½ 2 ï¿½ ï¿½ï¿½ï¿½, A points\u201a€“ï¿½P ï¿½ ï¿½ 2 ï¿½ P is finiteï¿½ For the definition of lines, we need the concept of a curve. Definition 3. A curve is a continuous mapping f : ï¿½0, 1ï¿½3ï¿½ 2 such that @a, b ï¿½ ï¿½0, 1ï¿½ : fï¿½aï¿½ ï¿½ fï¿½bï¿½faï¿½b\u201aˆ¨ï¿½a, bï¿½ ï¿½ ï¿½0, 1ï¿½. Let rngï¿½ f ï¿½ ï¿½ ï¿½p ï¿½ ï¿½ 2 ï¿½ ?a ï¿½ ï¿½0, 1ï¿½ : fï¿½aï¿½ ï¿½ pï¿½. Two curves f, g are called equivalent iff rngï¿½ f ï¿½ ï¿½ rngï¿½gï¿½. The points fï¿½0ï¿½ and fï¿½1ï¿½ are called the end points of f. Iffï¿½0ï¿½ ï¿½ fï¿½1ï¿½ ï¿½ p, then we say f is a loop in p. This definition allows loops (fï¿½0ï¿½ ï¿½ fï¿½1ï¿½), but forbids equality of different interior points and equality of an interior with an end point. The curves that we want to deal with must be simple in the sense that the intersection of two curves yields only a finite number of proper intersection points (disregarding common parts that are curves themselves). This is ensured by the following definitions. Definition 4. Let Q ï¿½ ï¿½ 2 and p ï¿½ Q. p is called isolated Q :N?ï¿½ ï¿½ ï¿½, ï¿½ ï¿½ 0:Uï¿½ p, ï¿½ï¿½ ï¿½ ï¿½Q\\ï¿½pï¿½ï¿½ ï¿½ \u201a€. Here Uï¿½ p, ï¿½ï¿½ denotes an open disk around p with radius ï¿½. The set of all isolated points in Q is denoted as isolatedï¿½Qï¿½. Definition 5. Let C be the set of all curves w.r.t. Def. 3. A class of curves Cï¿½ ï¿½ C is called simple :N @c 1, c 2 ï¿½ Cï¿½ : isolatedï¿½rngï¿½c 1ï¿½ ï¿½ rngï¿½c 2ï¿½ï¿½ is finite. 1 In the simple Euclidean spaces considered in this paper, these notions can be characterized as follows. Let X be the space (i.e., ï¿½ or ï¿½ 2 ) and S ï¿½ X. For ï¿½ ï¿½ 0, let Uï¿½x, ï¿½ï¿½ ï¿½ ï¿½ p ï¿½ X ï¿½ dï¿½ p, xï¿½ ï¿½ ï¿½ï¿½ be an ï¿½-disk around x, where d is the distance metric. A point x ï¿½ X belongs to the interior of S, denoted S o , if there exists an ï¿½-disk around x contained in S. It belongs to the boundary of S, denoted ï¿½S, if every ï¿½-disk around x intersects both S and the complement of S. It belongs to the exterior of S, denoted S e , if it is in the interior of the complement of S. The closure of S is S ï¿½ ï¿½S. A set is closed if it contains its boundary. Hence any set S partitions the space X into three disjoint parts S o , ï¿½S, and S e . ACM Transactions on Database Systems, Vol. 25, No. 1, March 2000. A Foundation for Representing and Querying Moving Objects \u201a€¢ 9 The line data type is to represent any finite union of curves from some class of simple curves. When the abstract design of data types given in this paper is implemented by some discrete design (as explained in the introduction), some class of curves will be selected for representation, for example, polygonal lines, curves described by cubic functions, etc. We just require that the class of curves selected has this simplicity property. This is needed, for example, to ensure that the intersection operation between two line values yields a finite set of points representable by the points data type. A finite union of curves basically yields a graph structure embedded into the plane (whose nodes are intersections of curves and whose edges are intersection-free pieces of curves). Given a set of points of such a graph, there are many different sets of curves resulting in this point set. For example, a path over the graph could be interpreted as a single curve or as being composed of several curves. The following definitions ensure that (i) a line value is a point set in the plane that can be described as a finite union of curves, and (ii) there is a unique collection of curves that can serve as a \u201a€œcanonical\u201a€ representation of this point set. Definition 6. Let f, g be curves. They are quasi-disjoint iff @a, b ï¿½ ï¿½0, 1ï¿½ : fï¿½aï¿½ ï¿½ fï¿½bï¿½. They meet in a point p iff ?a, b ï¿½ ï¿½0, 1ï¿½ : fï¿½aï¿½ ï¿½ p ï¿½ gï¿½bï¿½. Definition 7. Let S be a class of curves. A C-complex over S is a finite set of curves C ï¿½ S such that (1) @f, g ï¿½ C, f ï¿½ g: f and g are quasi-disjoint. (2) @f, g ï¿½ C, f ï¿½ g: f and g meet in p f ï¿½?h ï¿½ C, f ï¿½ h ï¿½ g such that f and h meet in p) \u201aˆ¨ (f or g is a loop in p). The set of points of this C-complex is denoted pointsï¿½Cï¿½, isï¿½ cï¿½Crngï¿½cï¿½. The set of all C-complexes over S is denoted by CCï¿½Sï¿½. The second condition ensures that whenever two curves meet in a point p, then at least three (ends) of these curves must meet at this point, and so it is not possible to merge the two curves into one. Definition 8. Let S be a simple class of curves. The carrier set of the line data type is A line\u201a€“ï¿½Q ï¿½ ï¿½ 2 ï¿½ ?C ï¿½ CCï¿½Sï¿½ : pointsï¿½Cï¿½ ï¿½ Qï¿½ Since for a given line value Q there is a unique 2 C-complex C with pointsï¿½Cï¿½ ï¿½ Q, we can denote it by scï¿½Qï¿½ (the simple curves of Q). 2 To be precise, the C-complex is uniquely determined up to the equivalence of the curves in it. Essentially this means that the graph structure (as a set of curves corresponding to edges) is uniquely determined; but for the definition of a single edge, one C-complex may have a curve f and another one a curve g, where f and g are equivalent, i.e., rngï¿½ f ï¿½ ï¿½ rngï¿½gï¿½. The graph structure is uniquely determined because edges (curves) intersect only in their end points and are maximal. ACM Transactions on Database Systems, Vol. 25, No. 1, March 2000. 10 \u201a€¢ R. H. GÃ¼ting et al. For some operations we need a notion of components of a line value. Let meet* denote the transitive closure of the meet relationship on curves. This is an equivalence relation that partitions a C-complex into connected components, denoted components(C) (each of which is a C-complex as well). For a line value Q, the decomposition into corresponding point sets is defined as blocksï¿½Qï¿½ ï¿½ ï¿½pointsï¿½Cï¿½ï¿½ ï¿½Cï¿½ ï¿½ componentsï¿½scï¿½Qï¿½ï¿½ï¿½. A region value is defined as a point set in the plane with a certain structure. Similarly as for line, we first define the structure, called an R-complex now, and its associated point set, and then define a region as a point set that could belong to such an R-complex. Again, for a region point set, its R-complex is uniquely defined. For the definition, we need the concept of a regular closed set. A set Q ï¿½ ï¿½ 2 is called regular closed if the closure of its interior coincides with the set itself, i.e., Q ï¿½ closureï¿½Q o ï¿½. The reason for this regularization process is that regions should not have geometric anomalies such as an isolated or dangling line or point features and missing lines and points in the form of cuts and punctures. Definition 9. Two regular closed sets Q and R are called quasi-disjoint: N Q ï¿½ R is finite. Definition 10. Let S be a class of curves. An R-complex over S is a finite set R of nonempty, regular closed sets, such that (1) Any two distinct elements of R are quasi-disjoint. (2) @r ï¿½ R, ?c ï¿½ CCï¿½Sï¿½ : ï¿½r ï¿½ pointsï¿½cï¿½. Here ï¿½r denotes the boundary of r. Each element of the R-complex is called a face. The union of all points of all faces is denoted pointsï¿½Rï¿½. The set of all R-complexes over S is denoted RCï¿½Sï¿½. Hence, a region can be viewed as a finite set of components called faces. Any two faces of a region are disjoint except for finitely many \u201a€œtouching points\u201a€ at the boundary. Moreover, the definition ensures that boundaries of faces are simple in the same sense that lines are simple. For example, the intersection of two regions will also produce only finitely many isolated intersection points. Note that the boundary of a face has outer as well as possibly inner parts, i.e., the face may have holes. Definition 11. Let S be a simple class of curves. The carrier set of the region data type is defined as A region\u201a€“ï¿½Q ï¿½ ï¿½ 2 ï¿½ ?R ï¿½ RCï¿½Sï¿½ : Q ï¿½ pointsï¿½Rï¿½ï¿½ We require that the same class S of curves is used in defining the line and the region type. Since for a given region value Q, its R-complex is uniquely defined, we can denote it by faces(Q). ACM Transactions on Database Systems, Vol. 25, No. 1, March 2000. A Foundation for Representing and Querying Moving Objects \u201a€¢ 11 We extend the shorthand Aï¿½ to the spatial data types, and in fact to all types whose carrier set contains sets of values. For these types ï¿½, we define Aï¿½ ï¿½\u201a€“A ï¿½\\ï¿½\u201a€ï¿½. 3.1.3 Time Type. Type instant represents a point in time or is undefined. Time is considered to be linear and continuous, i.e., isomorphic to the real numbers. Definition 12. The carrier set for instant is A instant\u201a€“ï¿½ï¿½ï¿½ï¿½ï¿½ 3.1.4 Temporal Types. From the base types and spatial types, we want to derive corresponding temporal types. The type constructor moving is used for this purpose. It yields for any given type ï¿½ a mapping from time to ï¿½. More precisely, this means the following: Definition 13. Let ï¿½ be a data type to which the moving type constructor is applicable, with carrier set A ï¿½. Then the carrier set for moving(ï¿½), is defined as follows: A movingï¿½ï¿½ï¿½\u201a€“ï¿½f\u201aªf : A ï¿½ instant3A ï¿½ ï¿½ is a partial function \u201aˆ§ ï¿½ï¿½fï¿½ is finiteï¿½ Hence, each value f from the carrier set of moving(ï¿½) is a function describing the development over time of a value from the carrier set of ï¿½. The condition \u201a€œ ï¿½ï¿½ f ï¿½ is finite\u201a€ says that f consists of only a finite number of continuous components. This is made precise in the Appendix, where a generalized notion of continuity is defined. This condition is needed (i) to ensure that projections of moving objects (e.g., into the 2D plane) have only a finite number of components; (ii) for the decompose operation defined below; and (iii) as a precondition to make the design implementable. For all \u201a€œmoving\u201a€ types we introduce extra names by prefixing the argument type with an \u201a€œm\u201a€, that is, mpoint, mpoints, mline, mregion, mint, mreal, mstring, and mbool. This is just to shorten some signatures. The temporal types obtained through the moving type constructor are functions, or infinite sets of pairs (instant, value). It is practical to have a type for representing any single element of such a function, i.e., a single (instant, value)-pair, for example, to represent the result of a time-slice operation. The intime type constructor converts a given type ï¿½ into a type that associates instants of time with values of ï¿½. Definition 14. Let ï¿½ be a data type to which the intime type constructor is applicable with carrier set A ï¿½. Then the carrier set for intime(ï¿½), is defined as follows: A intimeï¿½ï¿½ï¿½\u201a€“A instant ï¿½ A ï¿½ ACM Transactions on Database Systems, Vol. 25, No. 1, March 2000. 12 \u201a€¢ R. H. GÃ¼ting et al. 3.1.5 Range Types (Sets of Intervals). For all temporal types we would like to have operations that correspond to projections into the domain and the range of the functions. For the moving counterparts of the base types, e.g., moving(real) (whose values come from a one-dimensional domain), the projections are, or can be, compactly represented as sets of intervals over the one-dimensional domain. Hence, we are interested in types to represent sets of intervals over the real numbers, over the integers, etc. Such types are obtained through a range type constructor. Definition 15. Let ï¿½ be a data type to which the range type constructor is applicable (and hence on which a total order ï¿½ exists). An ï¿½-interval is a set X ï¿½ A ï¿½ ï¿½ such that @x, y ï¿½ X, @z ï¿½ A ï¿½ ï¿½ : x ï¿½ z ï¿½ yfzï¿½X. Two ï¿½-intervals are adjacent, if they are disjoint and their union is an ï¿½-interval. An ï¿½-range is a finite set of disjoint, nonadjacent intervals. For an ï¿½-range R, pointsï¿½Rï¿½ denotes the union of all its intervals. Intervals may include their left and/or right boundaries or not, and so be left-open, etc. Definition 16. Let ï¿½ be any data type to which the range type constructor is applicable. Then the carrier set for range(ï¿½) is A rangeï¿½ï¿½ï¿½\u201a€“ï¿½X ï¿½ A ï¿½ ï¿½ ï¿½ ? an ï¿½-range R : X ï¿½ pointsï¿½Rï¿½ï¿½ Again, a range value X has a unique associated ï¿½-range denoted by intvlsï¿½ X ï¿½. Because we are particularly interested in ranges over the time domain, we introduce a special name for this type: periods ï¿½ rangeï¿½instantï¿½. 3.2 Rationale for this Design The most important design principles that led to this particular choice of data types are the following: (1) Closure and consistency between nontemporal and temporal types. For all base types and all spatial types, corresponding temporal types are introduced through the moving constructor. The use of the type constructor, instead of ad-hoc definition of temporal types, ensures consistency. (2) Closure under projection. For all temporal types, data types must be available to represent the results of projections into the (time) domain and range, as well as the result of a time-slice operation. (3) Uniform support of point vs. point set view. All data types belong to either a one-dimensional or a two-dimensional space. This third principle requires that, in each space, we have data types to represent a single value (called a point) and a set of values (a point set). This is the basis for the definition of generic operations described in the next section, and is explained in more detail there. A deeper discussion of design considerations can be found in GÃ¼ting et al. [1998]. ACM Transactions on Database Systems, Vol. 25, No. 1, March 2000. 4. OPERATIONS A Foundation for Representing and Querying Moving Objects \u201a€¢ 13 4.1 Overview The design of the operations adheres to three principles: (i) design operations that are as generic as possible; (ii) achieve consistency between operations on nontemporal and temporal types; and (iii) capture the interesting phenomena. The first principle is crucial, as our type system is quite large. To avoid a proliferation of operations, it is mandatory to find a unifying view of collections of types. The basic approach to achieve this is to relate each type to either a one-dimensional or a two-dimensional space and to consider all values either as single elements or subsets of the respective space. For example, type int describes single elements of the one-dimensional space of integers, while range(int) describes sets of integers. Similarly, point describes single elements of two-dimensional space, whereas points, line, and region describe subsets of the two-dimensional space. Second, in order to achieve consistency of operations on nontemporal and temporal types, we proceed in two steps. In the first, we define operations on nontemporal types. In the second, we systematically extend operations defined in the first step to the temporal variants of the respective types. This is called lifting. Third, in order to obtain a powerful query language, it is necessary to include operations that address the most important concepts from various domains (or branches of mathematics). Whereas simple set theory and first-order logic are certainly the most fundamental and best-understood parts of query languages, we also need to have operations based on order relationships, topology, metric spaces, etc. There is no clear recipe to achieve closure of interesting phenomena; nevertheless, this should not keep us from having concepts and operations such as distance, size of a region, relationships of boundaries, and the like. Section 4 is structured as follows. Section 4.2 develops an algebra over nontemporal types, based on the generic point and point set (value vs. subset of space) view of these types. The classes of operations considered are shown in Table III, which also gives an overview of operations by just listing their names. Section 4.3 defines operations on temporal types. The classes of operations are shown in Table IV. Finally, an operation that is based on our data types is needed, but requires a manipulation of a set of objects in the database (e.g., a relation). It is called decompose and is treated in Section 4.4. 4.2 Operations on Nontemporal Types In this section we first carefully study operations on nontemporal types. Although the focus of the paper is on the treatment of moving objects, and hence on temporal types, this first step is crucial because later all these operations will, by the process of lifting, become operations on temporal types as well. The following design is adapted to that purpose. ACM Transactions on Database Systems, Vol. 25, No. 1, March 2000. 14 \u201a€¢ R. H. GÃ¼ting et al. Table III. Classes of Operations on Nontemporal Types Class Operations Predicates isempty ï¿½, ï¿½, intersects, inside ï¿½, ï¿½, ï¿½, ï¿½, before touches, attached, overlaps, on_border, in_interior Set Operations intersection, union, minus crossings, touch_points, common _border Aggregation min, max, avg, center, single Numeric no_components, size, perimeter, duration, length, area Distance and Direction distance, direction Base Type Specific and, or, not Table IV. Classes of Operations on Temporal Types Class Operations Projection to Domain/Range deftime, rangevalues, locations, trajectory routes, traversed, inst, val Interaction with Domain/Range atinstant, atperiods, initial, final, present at, atmin, atmax, passes When when Lifting (all new operations inferred) Rate of Change derivative, speed, turn, velocity As motivated above, we take the view that we are dealing with single values and sets of these values in one-dimensional and two-dimensional spaces. The types can then be classified according to Table V. (Remember that by temporal types we mean types representing functions of time. Types instant and periods are not temporal types in this sense.) Table V shows that we are dealing with five different one-dimensional spaces called Integer, Boolean, etc., and one two-dimensional space called 2D. For example, the two types belonging to space Integer are int and range(int). One-dimensional spaces are further classified as being discrete or continuous. The distinction between one-dimensional and two-dimensional spaces is relevant because only the one-dimensional spaces have a (natural) total order. The distinction between discrete and continuous one-dimensional spaces is important for certain numeric operations. To have a uniform terminology in any of the respective spaces, we call a single element a point and a subset of the space a point set, and we classify types accordingly as point types or point set types. Example 3. We introduce the following example relations for use within this section, representing cities, countries, rivers, and highways in Europe. city(name:string, pop:int, center:point) country(name:string, area:region) river(name:string, route:line) highway(name:string, route:line) 4.2.1 Notation for Signatures. Let us briefly introduce notation for signatures that are partly based on Table V. In defining operation signa- ACM Transactions on Database Systems, Vol. 25, No. 1, March 2000. A Foundation for Representing and Querying Moving Objects \u201a€¢ 15 Table V. Classification of Nontemporal Types 1D Spaces 2D Space discrete continuous Integer Boolean String Real Time 2D point int bool string real instant point point set range(int) range(bool) range(string) range(real) periods points, line, region tures and semantics, ï¿½ and ï¿½ are type variables, ranging over all point and all point set types of Table V, respectively. If several type variables occur in a signature (e.g., for binary operations), then they are always assumed to range over types of the same space. Hence, in a signature ï¿½ ï¿½ ï¿½3ï¿½we can, for example, select the one-dimensional space Integer and instantiate ï¿½ to int and ï¿½ to range(int). Or we can select the two-dimensional space 2D where we can instantiate ï¿½ to point and ï¿½ to either points, line, orregion. A signature ï¿½ 1 ï¿½ ï¿½ 23ï¿½ means that the type variables ï¿½ 1 and ï¿½ 2 can be instantiated independently; nevertheless, they have to range over the same space. In contrast, a signature ï¿½ ï¿½ ï¿½3ï¿½says that both arguments have to be of the same type. The notation ï¿½ R ï¿½3ï¿½is used if any order of the two argument types is valid, hence it is an abbreviation for signatures ï¿½ ï¿½ ï¿½3ï¿½and ï¿½ ï¿½ ï¿½3ï¿½. Some operations are restricted to certain classes of spaces; these classes are denoted as 1D ï¿½ {Integer, Boolean, String, Real, Time}, 2D ï¿½ {2D}, 1Dcont ï¿½ {Real, Time}, 1Dnum ï¿½ {Integer, Real, Time}, and cont ï¿½ {Real, Time, 2D}. A signature is restricted to a class of spaces by putting the name of the class behind it in square brackets. For example, a signature ï¿½3ï¿½ [1D] is valid for all one-dimensional spaces. A single operation may have several functionalities (signatures). Sometimes, for a generic operation, there exist more appropriate names for arguments of more specific types. For example, there is a size operation for any point set type; however, for type periods, it makes more sense to call this size duration. In such a case, we introduce the more specific name as an alias with the notation size[duration]. In defining semantics, u, v, ... denote single values of a ï¿½ type, and U, V, ... generic sets of values (point sets) of a ï¿½ type. For binary operations, u or U refers to the first and v or V to the second argument. Furthermore, b (B) ranges over values (sets of values) of base types, and predicates are denoted by p. Weuseï¿½ to range over moving objects and tï¿½Tï¿½ to range over instant values (periods). For the definition of the semantics of operations, we generally assume strict evaluation, i.e., for any function f op defining the semantics of an operation op we assume f opï¿½. ..,ï¿½, ...ï¿½ ï¿½ ï¿½. We will therefore not handle undefined arguments explicitly in definitions. ACM Transactions on Database Systems, Vol. 25, No. 1, March 2000. 16 \u201a€¢ R. H. GÃ¼ting et al. Table VI. Unary Predicates Operation Signature Semantics isempty[undefined] ï¿½ 3 bool u ï¿½ ï¿½ ï¿½ 3 bool U ï¿½ \u201a€ The syntax for operations in queries is the prefix notation op(arg1, ...,argn). Exceptions are the comparison operators ï¿½, ï¿½, etc., and the Boolean operators and and or, for which it is customary to have infix notation. For two operators, when and decompose, a special syntax is defined explicitly below. 4.2.2 Predicates. We consider unary and binary predicates. On this abstract level, there are not many unary predicates one can think of. For a single point, we can ask whether it is undefined, and for a point set, we can ask whether it is empty. The generic predicate isempty is used for this purpose (Table VI). To achieve some completeness, the design of binary predicates is based on the following strategy. First, we consider possible relationships between two points (single values), two point sets, and a point vs. a point set in the respective space. Second, orthogonal to this, predicates are based on three different concepts, namely set theory, order relationships, and topology. Order means total order here, which is available only in one-dimensional spaces. Topology means considering for a point set U its boundary ï¿½U and interior U o . This design space for binary predicates is shown in Table VII. The idea is to systematically evaluate the possible interactions between single values and sets and, based on that, to introduce (names for) operations. For example, we find that checking whether boundaries intersect is important, and then introduce touches as a name for this. Note that operations in the middle column are available in one-dimensional (ordered) spaces in addition to those in the other columns. As a result, we obtain the signature in Table VIII. We have not offered any predicates related to distance or direction (e.g., \u201a€œnorth\u201a€). However, such predicates can be obtained via numeric evaluations (see Section 4.2.6). A discussion of the completeness of the predicates can be found in GÃ¼ting et al. [1998]. 4.2.3 Set Operations. Set operations are fundamental and are available for all point-set types. Where feasible, we also allow set operations on point types, thus allowing expressions such as u minus v and U minus u. Singleton sets or empty sets that result from this use are interpreted as point values. This is possible because all domains include the undefined value (ï¿½), whose meaning we identify with the empty set. Permitting set operations on point types is especially useful in the context of temporal types, as we shall see later. There is no union operation on two single ACM Transactions on Database Systems, Vol. 25, No. 1, March 2000. point vs. point point set vs. point set point vs. point set A Foundation for Representing and Querying Moving Objects \u201a€¢ 17 Table VII. Analysis of Binary Predicates Set Theory Order (1D Spaces) Topology u ï¿½ v, u ï¿½ v u ï¿½ v, u ï¿½ v u ï¿½ v, u ï¿½ v U ï¿½ V, U ï¿½ V U before V ï¿½U ï¿½ ï¿½V ï¿½ \u201a€ (touches) U ï¿½ V ï¿½ \u201a€ (intersects) ï¿½U ï¿½ V o ï¿½ \u201a€ (attached) U ï¿½ V (inside) U o ï¿½ V o ï¿½ \u201a€ (overlaps) u ï¿½ U (inside) u before V u ï¿½ ï¿½U (on_border) U before v u ï¿½ U o (in_interior) Table VIII. Binary Predicates Operation Signature Semantics ï¿½, ï¿½ ï¿½ ï¿½ ï¿½ 3 bool u ï¿½ v, u ï¿½ v ï¿½ 1 ï¿½ ï¿½ 2 3 bool U ï¿½ V, U ï¿½ V intersects ï¿½ 1 ï¿½ ï¿½ 2 3 bool U ï¿½ V ï¿½ \u201a€ inside ï¿½ 1 ï¿½ ï¿½ 2 3 bool U ï¿½ V ï¿½ ï¿½ ï¿½ 3 bool u ï¿½ V ï¿½, ï¿½, ï¿½, ï¿½ ï¿½ ï¿½ ï¿½ 3 bool [1D] u ï¿½ v etc. before ï¿½ 1 ï¿½ ï¿½ 2 3 bool [1D] @u ï¿½ U, @v ï¿½ V : u ï¿½ v ï¿½ ï¿½ ï¿½ 3 bool [1D] @v ï¿½ V : u ï¿½ v ï¿½ ï¿½ ï¿½ 3 bool [1D] @u ï¿½ U : u ï¿½ v touches ï¿½ 1 ï¿½ ï¿½ 2 3 bool ï¿½U ï¿½ ï¿½V ï¿½ \u201a€ attached ï¿½ 1 ï¿½ ï¿½ 2 3 bool ï¿½U ï¿½ V o ï¿½ \u201a€ overlaps ï¿½ 1 ï¿½ ï¿½ 2 3 bool U o ï¿½ V o ï¿½ \u201a€ on_border ï¿½ ï¿½ ï¿½ 3 bool u ï¿½ ï¿½U in_interior ï¿½ ï¿½ ï¿½ 3 bool u ï¿½ U o points because the result could be two points, which cannot be represented as a value of point type. Defining set operations on a combination of one- and two-dimensional point sets is more involved. This is because we are using arbitrary closed or open sets in the one-dimensional space, whereas only closed point sets (points, line, and region) exist in the two-dimensional case. The restriction to closed point sets in the two-dimensional case is a natural and common one. Regions lacking part of their boundary or interior points or curves appear unnatural. On the other hand, in the one-dimensional space it is necessary to admit open intervals, since these are the domains of temporal (function) types. When a value changes at time t from a to b, we have to decide what exactly the value is at time t. If at time t it is already b, then we have a right-open time interval (with value a) up to time t, and a left-closed interval with value b starting at t. This justifies a different treatment of one- and two-dimensional point sets. Because our two-dimensional types are closed, it is necessary to apply a closure operation after applying the set operations on such entities, which adds all points on the boundary of an open set. ACM Transactions on Database Systems, Vol. 25, No. 1, March 2000. 18 \u201a€¢ R. H. GÃ¼ting et al. Whereas in all the one-dimensional spaces there is only a single point set type, in two-dimensional space there are three. This requires an analysis of which argument type combinations make sense (return interesting results), and what the result types are. Generally, if we apply set operations to values of different types, we get results that are a mixture of zero-, one-, and two-dimensional point sets, i.e., points, lines, and proper regions. Usually, one is mainly interested in the results of the highest dimension. This is reflected in the concept of regularized set operations [Tilove 1980]. For example, the regularized intersection removes all lower-dimensional pieces from the result of the corresponding intersection result. We also adopt regularization in our framework as the semantics of the three standard set operations, union, minus, and intersection, in two dimensions. On different argument type combinations, the three set operations behave as follows: \u201a€”Union of arguments of equal types has the usual semantics. Due to regularization, for unions on different types, the result is the higherdimensional argument. This result is not interesting, since we know it already. Hence, we define union for equal types only. \u201a€”Difference always results in the type of the first argument. Closure has to be applied to the result. Only those combinations of argument types return new results where the dimension of the second argument is equal or higher to that of the first. If the dimension of the second argument is smaller, then by closure, the first argument value is returned unchanged. We allow difference on all type combinations, even though some of them are not relevant. \u201a€”Intersection produces results of all dimensions smaller or equal to the dimension of the lowest-dimensional argument. For example, the intersection of a line value with a region value may result in points and lines. We define the intersection operator for all type combinations with regularized semantics, i.e., it returns the highest-dimensional part of the result. To make other kinds of results available, we introduce specialized operators, called, e.g., common_border or touch_points. As a result, we obtain the signatures shown in Table IX (some notation used in the column \u201a€œSemantics\u201a€ is explained below). They are divided into five groups, the first two concerning point/point and point vs. point-set interaction. The last three groups deal with point-set/point-set interaction in one- and two-dimensional spaces; the last group introduces specialized intersection operations to obtain lower-dimensional results. The notation minï¿½ï¿½ 1, ï¿½2ï¿½ refers to taking the minimum in an assumed \u201a€œdimensional\u201a€ order points ï¿½ line ï¿½ region. The definition of semantics in Table IX uses predicates is2D and is1D to check whether the argument is of a two-dimensional or one-dimensional ACM Transactions on Database Systems, Vol. 25, No. 1, March 2000. A Foundation for Representing and Querying Moving Objects \u201a€¢ 19 type, respectively. Also, the notations ï¿½ï¿½Qï¿½, Qo , and ï¿½Q are used for closure, interior, and boundary of Q, respectively. For example, in the second group of operations, the second definition for minus says that in two dimensions, after subtracting a point v from a point set U, the closure is applied, whereas in one dimension the result is taken directly. Definitions for intersection that did not fit into the table are as follows. Definition 17. The semantics of intersection operations is defined as follows. Let P, L, and R, possibly indexed, denote arguments of type points, line, and region, respectively. Let Q be an argument of any of the three types. For commutative operations we give the definition for one order of the arguments only, as it is identical for the other order. Definitions are ordered by argument combinations. f intersectionï¿½P, Qï¿½\u201a€“Pï¿½Q Table IX. Set Operations Operation Signature Semantics intersection ï¿½ ï¿½ ï¿½ 3 ï¿½ if u ï¿½ v then u else ï¿½ minus ï¿½ ï¿½ ï¿½ 3 ï¿½ if u ï¿½ v then ï¿½ else u intersection ï¿½ R ï¿½ 3 ï¿½ if u ï¿½ V then u else ï¿½ minus ï¿½ ï¿½ ï¿½ 3 ï¿½ if u ï¿½ V then ï¿½ else u ï¿½ ï¿½ ï¿½ 3 ï¿½ if is2Dï¿½U ï¿½ then ï¿½ï¿½U\\ï¿½vï¿½ï¿½ else U\\ï¿½vï¿½ union ï¿½ R ï¿½ 3 ï¿½ if is1Dï¿½V ï¿½ or typeï¿½V ï¿½ ï¿½ points then V ï¿½ ï¿½uï¿½ else V intersection, ï¿½ ï¿½ ï¿½ 3 ï¿½ [1D] U ï¿½ V, U\\V, U ï¿½ V minus, union intersection ï¿½ 1 ï¿½ ï¿½ 2 3 minï¿½ï¿½ 1, ï¿½ 2ï¿½ [2D] see Def. 17 minus ï¿½ 1 ï¿½ ï¿½ 2 3 ï¿½ 1 [2D] ï¿½ï¿½Q 1\\Q 2ï¿½ union ï¿½ ï¿½ ï¿½ 3 ï¿½ [2D] Q 1 ï¿½ Q 2 crossings line ï¿½ line 3 points see Def. 17 touch_points region R line 3 points region ï¿½ region 3 points common_border region ï¿½ region 3 line f crossingsï¿½L 1, L 2ï¿½\u201a€“ï¿½p ï¿½ L 1 ï¿½ L 2\u201aªp is isolated in L 1 ï¿½ L 2ï¿½ f intersectionï¿½L 1, L 2ï¿½\u201a€“ï¿½L 1 ï¿½ L 2ï¿½\\f crossingsï¿½L 1, L 2ï¿½ f touchï¿½pointsï¿½L, Rï¿½\u201a€“ï¿½p ï¿½ L ï¿½ R\u201aªp is isolated in L ï¿½ Rï¿½ f intersectionï¿½L, Rï¿½\u201a€“ï¿½L ï¿½ Rï¿½\\f touchï¿½pointsï¿½L, Rï¿½ f intersectionï¿½R 1, R 2ï¿½\u201a€“ï¿½ï¿½ï¿½R 1 ï¿½ R 2ï¿½ o ï¿½ f commonï¿½borderï¿½R 1, R 2ï¿½\u201a€“f intersectionï¿½ï¿½R 1, ï¿½R 2ï¿½ f touchï¿½pointsï¿½R 1, R 2ï¿½\u201a€“f crossingsï¿½ï¿½R 1, ï¿½R 2ï¿½ ACM Transactions on Database Systems, Vol. 25, No. 1, March 2000. 20 \u201a€¢ R. H. GÃ¼ting et al. Table X. Aggregate Operations Operation Signature Semantics min, max ï¿½ 3 ï¿½ [1D] minï¿½ï¿½ï¿½U ï¿½ï¿½, maxï¿½ï¿½ï¿½U ï¿½ï¿½ avg ï¿½ 3 ï¿½ [1Dnum] 1 supï¿½T ï¿½ï¿½infï¿½T ï¿½ Tï¿½intvlsï¿½U ï¿½ ï¿½intvlsï¿½U ï¿½ï¿½ï¿½ 2 avg[center] points 3 ï¿½ [2D] 1 pï¿½U nï¿½ pï¿½ avg[center] line 3 ï¿½ [2D] 1 cï¿½scï¿½U ï¿½ ï¿½U ï¿½ï¿½ cï¿½ï¿½cï¿½ avg[center] region 3 ï¿½ [2D] 1 Mï¿½U ï¿½x, yï¿½dU where M ï¿½ ï¿½ dU U single ï¿½ 3 ï¿½ if ?u : U ï¿½ ï¿½uï¿½ then u else ï¿½ The following example shows how with union and intersection we also have the corresponding aggregate functions over sets of objects (relations) available. Example 4. \u201a€œDetermine the region of Europe from the regions of its countries.\u201a€ LET sum ï¿½ AGGREGATE(union, TheEmptyRegion); LET Europe ï¿½ SELECT sum(area) FROM country This makes use of the facility for constructing aggregate functions described in Section 2. TheEmptyRegion is some empty region constant defined in the database. 4.2.4 Aggregation. Aggregation reduces sets of points to points (Table X). In one-dimensional space, where total orders are available, closed sets have minimum and maximum values, and functions (min and max) that extract these are provided. For open and half-open intervals, we choose to let these functions return infimum and supremum values, i.e., the maximum and minimum of their closure. This is preferable over returning undefined values. In all domains that have addition, we can compute the average (avg). In 2D, the average is based on vector addition, and is usually called the center (of gravity). It is often useful to have a \u201a€œcasting\u201a€ operation available to transform a singleton set into its single value. For example, some operations have to return set types, although the result is often expected to be a single value. The operation single does this conversion. Example 5. The query \u201a€œFind the point where highway A1 crosses the river Rhine!\u201a€ can be expressed as: LET RhineA1 ï¿½ ELEMENT( SELECT single(crossings (R.route, H.route)) FROM river R, highway H WHERE R.name ï¿½ \u201a€œRhine\u201a€ and H.name ï¿½ \u201a€œA1\u201a€ and R.route intersects H.route) ACM Transactions on Database Systems, Vol. 25, No. 1, March 2000. A Foundation for Representing and Querying Moving Objects \u201a€¢ 21 The result can be used as a point value in further queries, whereas crossings returns a points value. In the definition of semantics, the one for the average of a line value needs some explanation. Recall that scï¿½U ï¿½ denotes the set of simple curves from which line U is built. We define the x- and y-projections of a curve c: @u ï¿½ ï¿½0, 1ï¿½ : cxï¿½uï¿½ ï¿½ x and cyï¿½uï¿½ ï¿½ y iff cï¿½uï¿½ ï¿½ ï¿½x, yï¿½. Then the length of a curve c, denoted ï¿½cï¿½, is defined as 1 ï¿½cï¿½ ï¿½ï¿½ 0 ï¿½cï¿½ xï¿½uï¿½ 2 ï¿½ cï¿½ yï¿½uï¿½ 2 du where, e.g., cï¿½ x is the derivative of c x, that is, dc xï¿½uï¿½ ï¿½ du. The length of a line U, denoted ï¿½U ï¿½, is given by the sum of the lengths of its curves, hence ï¿½U ï¿½ ï¿½ ï¿½cï¿½scï¿½U ï¿½ï¿½cï¿½. The average of a curve c is defined as a point vector: 1 cï¿½ ï¿½ï¿½ cï¿½uï¿½ ï¿½du 0 In the definition of avg (or center) of a region, integration is done over pieces of the region according to the general formula ï¿½ S fï¿½x, yï¿½dS which integrates a function f defined on the two-dimensional plane over an arbitrary region S. In this case integration is done over the vectors ï¿½x, yï¿½ for each piece dU. 4.2.5 Numeric Properties of Sets. For sets of points, some well-known numeric properties exist (Table XI). For example, the number of components (no_components) is the number of disjoint maximal connected subsets, i.e., the number of faces for a region, connected components for a line graph, and intervals for a onedimensional point set. The size is defined for all continuous set types (i.e., for range(real), periods, line, and region). For one-dimensional types, the size is the sum of the lengths of component intervals; for line, it is the length; and for region, it is the area. For the region type, we are additionally interested in the size of the boundary, called perimeter. Example 6. \u201a€œList for each country its total size and the number of disjoint land areas.\u201a€ SELECT name, area(area), no_components(area) FROM country ACM Transactions on Database Systems, Vol. 25, No. 1, March 2000. 22 \u201a€¢ R. H. GÃ¼ting et al. Table XI. Numeric Operations Operation Signature Semantics no_components ï¿½ 3 int [1D] ï¿½intvlsï¿½U ï¿½ï¿½ no_components points 3 int ï¿½Uï¿½ no_components line 3 int ï¿½blocksï¿½U ï¿½ï¿½ no_components size[duration] region ï¿½ 3 int 3 real [1Dcont] ï¿½facesï¿½U ï¿½ï¿½ ï¿½Tï¿½intvlsï¿½U ï¿½supï¿½T ï¿½ ï¿½ infï¿½T ï¿½ size[length] line 3 real ï¿½U ï¿½ size[area] region 3 real ï¿½UdU perimeter region 3 real flengthï¿½ï¿½U ï¿½ Table XII. Distance and Direction Operations Operation Signature Semantics distance ï¿½ ï¿½ ï¿½ 3 real [1Dcont] ï¿½u ï¿½ vï¿½ ï¿½ R ï¿½ 3 real [1Dcont] minï¿½ï¿½u ï¿½ vï¿½\u201aªv ï¿½ Vï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ 3 real [1Dcont] 3 real [2D] minï¿½ï¿½u ï¿½ vï¿½\u201aªu ï¿½ U, v ï¿½ Vï¿½ distï¿½u, vï¿½ ï¿½ ï¿½ï¿½u.x ï¿½ v.xï¿½ 2 ï¿½ ï¿½u.y ï¿½ v.yï¿½ 2 ï¿½ R ï¿½ 3 real [2D] minï¿½distï¿½u, vï¿½\u201aªv ï¿½ Vï¿½ ï¿½ ï¿½ ï¿½ 3 real [2D] minï¿½distï¿½u, vï¿½\u201aªu ï¿½ U, v ï¿½ Vï¿½ direction point ï¿½ point 3 real see below Example 7. \u201a€œHow long is the common border of France and Germany?\u201a€ LET France ï¿½ ELEMENT(SELECT area FROM country WHERE name ï¿½ \u201a€œFrance\u201a€); LET Germany ï¿½ ELEMENT(SELECT area FROM country WHERE name ï¿½ \u201a€œGermany\u201a€); length(common_border(France, Germany)) 4.2.6 Distance and Direction. A distance measure exists for all continuous types. The distance function determines the minimum distance between the closest pair of points from the first and second arguments. The distance between two points is the absolute value of the difference in one-dimensional space and the Euclidean distance in two-dimensional space. The time domain inherits arithmetics from the domain of real numbers, to which it is isomorphic. The direction between points is sometimes of interest. A direction function is thus included that returns the angle of the line from the first to the second point, measured in degrees (0 ï¿½ angle ï¿½ 360). Hence, if q is exactly north of p, then directionï¿½ p, qï¿½ ï¿½ 90.Ifp ï¿½ q, then the direction operation returns the undefined value ï¿½. A formal definition is straightforward, but a bit lengthy and omitted here; it can be found in GÃ¼ting et al. [1998]. Example 8. \u201a€œFind all cities north of and within 200 kms of Munich!\u201a€ LET Munich ï¿½ ELEMENT(SELECT center FROM city WHERE name ï¿½ \u201a€œMunich\u201a€); SELECT name FROM city ACM Transactions on Database Systems, Vol. 25, No. 1, March 2000. A Foundation for Representing and Querying Moving Objects \u201a€¢ 23 Table XIII. Boolean Operations Operation Signature Semantics and, or bool ï¿½ bool 3 bool as usual (with strict evaluation) not bool 3 bool Table XIV. Operations for Projection of Temporal Values into Domain and Range Operation Signature Semantics deftime movingï¿½ï¿½ï¿½ 3 periods domï¿½ï¿½ï¿½ rangevalues movingï¿½ï¿½ï¿½ 3 rangeï¿½ï¿½ï¿½ [1D] rngï¿½ï¿½ï¿½ locations movingï¿½pointï¿½ 3 points isolatedï¿½rngï¿½ï¿½ï¿½ï¿½ movingï¿½pointsï¿½ 3 points isolatedï¿½ï¿½ rngï¿½ï¿½ï¿½ï¿½ trajectory movingï¿½pointï¿½ 3 line rngï¿½ï¿½ï¿½\\f locationsï¿½ï¿½ï¿½ movingï¿½pointsï¿½ 3 line ï¿½ rngï¿½ï¿½ï¿½\\f locationsï¿½ï¿½ï¿½ traversed movingï¿½lineï¿½ 3 region ï¿½ï¿½ï¿½ï¿½ rngï¿½ï¿½ï¿½ï¿½ ï¿½ï¿½ movingï¿½regionï¿½ 3 region ï¿½ rngï¿½ï¿½ï¿½ routes movingï¿½lineï¿½ 3 line ï¿½ï¿½ï¿½ rngï¿½ï¿½ï¿½ï¿½\\f traversedï¿½ï¿½ï¿½ inst intimeï¿½ï¿½ï¿½ 3 instant t where u ï¿½ ï¿½t, vï¿½ val intimeï¿½ï¿½ï¿½ 3 ï¿½ v where u ï¿½ ï¿½t, vï¿½ WHERE distance(center, Munich) ï¿½ 200 and direction(Munich, center) ï¿½ï¿½ 45 and direction(Munich, center) ï¿½ï¿½ 135 In this way we can express direction relationships such as north, south, etc., via numeric relationships. 4.2.7 Specific Operations for Base Types. Some operations on base types are needed that are not related to the point/point set view. We mention them because they have to be included in the scope of operations to be lifted, i.e., the kernel algebra (see Table XIII). 4.2.8 Scope of the Kernel Algebra. The kernel algebra is defined to consist of the types in BASE ï¿½ SPATIAL, together with all operations defined in Section 4.2, restricted to these types. 4.3 Operations on Temporal Types Values of temporal types (i.e., types moving(ï¿½)) are partial functions of the form f : Ainstant3 Aï¿½ ï¿½. In the following sections we discuss operations for projection into domain and range, interaction with values from domain and range, the when operation, lifting, and operations related to rate of change. 4.3.1 Projection to Domain and Range. For values of all moving types (which are functions), operations are provided that yield the domain and range of these functions (Table XIV). The domain function deftime returns the times for which a function is defined. In one-dimensional space, operation rangevalues returns values assumed over time as a set of intervals. For the two-dimensional types, ACM Transactions on Database Systems, Vol. 25, No. 1, March 2000. 24 \u201a€¢ R. H. GÃ¼ting et al. operations are offered to return the parts of the projections corresponding to our data types. For example, the projection of a moving point into the plane may consist of points and of lines; these can be obtained separately by operations locations and trajectory, respectively. In particular, if a moving point (or point set) changes its position in discrete steps only, then locations returns its projection as a points value. Operation routes similarly returns the projection of a discretely moving line value. The more natural projections of continuously moving objects are obtained by operations trajectory and traversed. For values of intime types, the two trivial projection operations inst and val are offered, yielding the two components. All the infinite point sets that result from domain and range projections are represented in collapsed form by the corresponding point set types. For example, a set of instants is represented as a periods value, and an infinite set of regions is represented by the union of the points of the regions, which is represented in turn as a region value. That these projections can be represented as finite collections of intervals, faces, etc., and hence correspond to our data types, is due to the continuity condition required for types moving(ï¿½) (see Section 3.1.4). The design is complete in that all projection values in domain and range can be obtained. This was one of the major principles in the design of the type system, as discussed in Section 3.2. For defining the semantics of operations on temporal types, a little more notation is needed. For a partial function f : A3B we write fï¿½xï¿½ ï¿½ ï¿½ whenever f is undefined for x ï¿½ A. To adjust the undefined value ï¿½ for values of type points, line, and region to \u201a€, we use the function: x1ï¿½ï¿½ï¿½ \u201a€ if x ï¿½ ï¿½ \u201aˆ§ ï¿½ ï¿½ ï¿½points, line, regionï¿½ x otherwise The domain of f is given by domï¿½ f ï¿½ ï¿½ ï¿½ x ï¿½ A ï¿½ fï¿½xï¿½ ï¿½ ï¿½ï¿½. Similarly, the range of f is defined by rngï¿½ f ï¿½ ï¿½ ï¿½y ï¿½ B ï¿½ ?x ï¿½ A : fï¿½xï¿½ ï¿½ yï¿½. If the elements of rngï¿½ f ï¿½ are sets, then we write ï¿½ rngï¿½ f ï¿½ as an abbreviation of the union of all these sets, i.e., ï¿½ rngï¿½ f ï¿½ ï¿½ ï¿½ Yï¿½rngï¿½ f ï¿½ Y. Example 9. To illustrate operations on temporal types, we use the example relations: flight(airline: string, no:int, from:string, to:string, route:mpoint) weather(name: string, kind:string, area:mregion) site(name: string, pos:point) Attributes airline and no of the relation flight identify a flight. In addition, the relation records the names of the departure and destination cities and the route taken for each flight. The last attribute is of type moving(point). We assume that a flight\u201a€™s route is defined only for the times the plane is in flight and not when it is on the ground. ACM Transactions on Database Systems, Vol. 25, No. 1, March 2000. A Foundation for Representing and Querying Moving Objects \u201a€¢ 25 The relation weather records weather events such as high pressure areas, storms, or temperature maps. Some of these events are given names to identify them. The attribute kind gives the type of weather event, such as \u201a€œsnow-cloud\u201a€ or \u201a€œtornado,\u201a€ and the area attribute provides the evolving extent of each weather event. Relation site contains positions of certain well-known sites such as the Eiffel tower, Big Ben, etc. Example 10. With the operations of this section we can formulate the following queries: \u201a€œHow long is the part of the route of flight LH 257 that lies within France?\u201a€ LET route257 ï¿½ ELEMENT( SELECT route FROM flight WHERE airline ï¿½ \u201a€œLH\u201a€ and no ï¿½ 257); length(intersection(France, trajectory(route257)) \u201a€œWhat are the departure and arrival times of flight LH 257?\u201a€ min(deftime(route257)); max(deftime(route257)); Example 11. \u201a€œAt what time and distance does flight 257 pass the Eiffel tower?\u201a€ We assume a closest operator with signature mpoint ï¿½ point 3 intime(point), which returns time and position when a moving point is closest to a given fixed point in the plane. We will later show how such an operator can be defined in terms of others. LET EiffelTower ï¿½ ELEMENT(SELECT pos FROM site WHERE name ï¿½ \u201a€œEiffel Tower\u201a€); LET pass ï¿½ closest(route257, EiffelTower); inst(pass); distance(EiffelTower, val(pass)) 4.3.2 Interaction with Points and Point Sets in Domain and Range. In this section we systematically study operations that relate the functional values of moving types with values either in their (time) domain or their range. For example, a moving point moves through the two-dimensional plane; does it pass a given point or region in this plane? Does a moving real ever assume the given value 3.5? Besides comparison, one can also restrict the moving entity to the given domain or range values, e.g., get the part of the moving point when it was within the region, or determine the value of the moving real at time t or within time interval ï¿½t 1, t 2ï¿½. In Table XV, the first group of operations concerns interaction with time domain values, the second interaction with range values. Operations atinstant and atperiods restrict a moving entity to a given instant, resulting in a pair (instant, value), or to a given set of time intervals, respectively. The atinstant operation is similar to the timeslice operator found in most temporal relational algebras (see, e.g., McKenzie and Snodgrass [1991]; Ã–zsoyoglu and Snodgrass [1995]). Operations initial and final return the first and last (instant, value) pair, respectively. Operation present allows one to check whether the moving value exists at a given instant, or is ever present during a given set of time intervals. ACM Transactions on Database Systems, Vol. 25, No. 1, March 2000. 26 \u201a€¢ R. H. GÃ¼ting et al. Table XV. Interaction of Temporal Values With Values in Domain and Range Operation Signature Semantics atinstant movingï¿½ï¿½ï¿½ ï¿½ instant 3 intimeï¿½ï¿½ï¿½ ï¿½t, ï¿½ï¿½tï¿½1ï¿½ï¿½ atperiods movingï¿½ï¿½ï¿½ ï¿½ periods 3 movingï¿½ï¿½ï¿½ ï¿½ï¿½t, yï¿½ ï¿½ ï¿½ ï¿½ t ï¿½ Tï¿½ initial final present movingï¿½ï¿½ï¿½ movingï¿½ï¿½ï¿½ movingï¿½ï¿½ï¿½ ï¿½ instant 3 intimeï¿½ï¿½ï¿½ 3 intimeï¿½ï¿½ï¿½ 3 bool lim ï¿½ï¿½tï¿½ t3infï¿½domï¿½ï¿½ï¿½ï¿½ lim ï¿½ï¿½tï¿½ t3supï¿½domï¿½ï¿½ï¿½ï¿½ ï¿½ï¿½tï¿½ ï¿½ ï¿½ present movingï¿½ï¿½ï¿½ ï¿½ periods 3 bool fatperiodsï¿½ï¿½, T ï¿½ ï¿½ \u201a€ at movingï¿½ï¿½ï¿½ ï¿½ ï¿½ 3 movingï¿½ï¿½ï¿½ [1D] ï¿½ï¿½t, yï¿½ ï¿½ ï¿½ ï¿½ y ï¿½ bï¿½ at movingï¿½ï¿½ï¿½ ï¿½ rangeï¿½ï¿½ï¿½ 3 movingï¿½ï¿½ï¿½ [1D] ï¿½ï¿½t, yï¿½ ï¿½ ï¿½ ï¿½ y ï¿½ Bï¿½ at movingï¿½ï¿½ï¿½ ï¿½ point 3 mpoint [2D] ï¿½ï¿½t, yï¿½ ï¿½ ï¿½ ï¿½ y ï¿½ uï¿½ at movingï¿½ï¿½ï¿½ ï¿½ ï¿½ 3 movingï¿½ï¿½ï¿½ [2D] ï¿½ï¿½t, yï¿½ ï¿½ ï¿½ ï¿½ y ï¿½ Uï¿½ atmin movingï¿½ï¿½ï¿½ 3 movingï¿½ï¿½ï¿½ [1D] ï¿½ï¿½t, yï¿½ ï¿½ ï¿½ ï¿½ y ï¿½ minï¿½rngï¿½ï¿½ï¿½ï¿½ï¿½ atmax movingï¿½ï¿½ï¿½ 3 movingï¿½ï¿½ï¿½ [1D] ï¿½ï¿½t, yï¿½ ï¿½ ï¿½ ï¿½ y ï¿½ maxï¿½rngï¿½ï¿½ï¿½ï¿½ï¿½ passes movingï¿½ï¿½ï¿½ ï¿½ ï¿½ 3 bool f atï¿½ï¿½, xï¿½ ï¿½ \u201a€ In the second group, the purpose of at is again restriction (such as atinstant, atperiods), this time to values in the range. For one-dimensional space, restriction by either a point or a point-set value returns a value of the given moving type. For example, we can reduce a moving real to the times when its value was between 3 and 4. In two dimensions, the resulting moving type is obtained by taking the minimum of the two argument types ï¿½ and ï¿½ with respect to the order point ï¿½ points ï¿½ line ï¿½ region. For example, the restriction of a moving(region) byapoint will result in a moving( point). This is analogous to the definition of result types for intersection in two dimensions in Section 4.2.3. In one-dimensional spaces, operations atmin and atmax restrict the moving value to the times when it is minimal or maximal with respect to the total order on this space. Operation passes allows one to check whether the moving value ever assumed (one of) the value(s) given as a second argument. For the definition of semantics, notation for the arguments is defined in Section 4.2.1. In particular, ï¿½ is a function argument and a function is a set of (argument, value) pairs. All of these operations are of interest from a language design point of view. Some of them are derived, however, so they can be expressed by other operations in the design. For example, we have present(f, t)ï¿½not(isempty(val(at instant(f, t)))) Example 12. \u201a€œWhen and where did flight 257 enter the territory of France ?\u201a€ LET entry ï¿½ initial (at(route257, France)); inst(entry); val(entry) Example 13. \u201a€œFor which periods of time was the Eiffel Tower within snow storm \u201a€˜Lizzy\u201a€™ ?\u201a€ LET Lizzy ï¿½ ELEMENT(SELECT area FROM weather WHERE name ï¿½ \u201a€œLizzy\u201a€ and kind ï¿½ \u201a€œsnow storm\u201a€); deftime(at(Lizzy, EiffelTower)) ACM Transactions on Database Systems, Vol. 25, No. 1, March 2000. A Foundation for Representing and Querying Moving Objects \u201a€¢ 27 4.3.3 The Elusive when Operation. We now consider (speculate about) an extremely powerful, yet conceptually quite simple, operation called when, whose signature is shown in Table XVI. The idea is that we can restrict a time-dependent value to the periods when its range value fulfils some property specified as a predicate. If we had such an operator, we could express a query such as \u201a€œRestrict a moving region mr to the times when its area was greater 1000\u201a€ as mr when [FUN (r:region) area(r) ï¿½ 1000] Here the result would again be of type mregion. Whereas such an operation would be very powerful and desirable, it is questionable whether such a definition makes any sense. This is because the operator has to call for evaluation of the parameter predicate infinitely many times, since our moving entities are functions over a continuous domain. Looping over an infinite domain is inherently impossible. So for the moment this operation seems impossible to implement. 4.3.4 Lifting Operations to Time-Dependent Operations. Section 4.2 systematically defines operations on nontemporal types, the kernel algebra. This section uniformly lifts these operations to apply to the corresponding moving (temporal) types. Consider an operation to be lifted. The idea is to allow any argument of the operation to be made temporal and to return a temporal type. More specifically, the lifted version of an operation with signature ï¿½1 ï¿½ ... ï¿½ ï¿½k3ï¿½ has signatures ï¿½ï¿½ 1 ï¿½ ... ï¿½ ï¿½ï¿½ k3movingï¿½ï¿½ï¿½ with ï¿½ï¿½ ï¿½ ï¿½ï¿½ i, movingï¿½ï¿½ iï¿½ï¿½. So each of the argument types may change into a timedependent type that will transform the result type into a time-dependent type as well. The operations that result from lifting are given the same name as the operation they originate from. For example, the intersection operation with signature is lifted to the signatures Table XVI. The when Operation Operation Signature Semantics Syntax when movingï¿½ï¿½ï¿½ ï¿½ ï¿½ï¿½3boolï¿½3movingï¿½ï¿½ï¿½ ï¿½ï¿½t, yï¿½ ï¿½ ï¿½ ï¿½ pï¿½ yï¿½ï¿½ arg1opï¿½arg2ï¿½ region ï¿½ point3point mregion ï¿½ point 3 mpoint region ï¿½ mpoint3mpoint, and mregion ï¿½ mpoint3mpoint. To define the semantics of lifting, we note that an operation op : ï¿½ 1 ï¿½ ...ï¿½ ï¿½ k3ï¿½ can be lifted with respect to any combination of argument ACM Transactions on Database Systems, Vol. 25, No. 1, March 2000. 28 \u201a€¢ R. H. GÃ¼ting et al. types. Such a combination can be conveniently described by a set of indices L ï¿½ ï¿½1,...,kï¿½ for the lifted parameters, and we define L ï¿½i ï¿½ ï¿½ movingï¿½ï¿½iï¿½ if i ï¿½ L ï¿½i otherwise L Thus, the signature of any lifted version of op can be written as op : ï¿½1 L ï¿½ ... ï¿½ ï¿½k 3 movingï¿½ï¿½ï¿½. Iffop is the semantics of op, we now have to L define the semantics of fop for each possible lifting L. For this, we define what it means to apply a possibly lifted value to an instant-value: L xi ï¿½tï¿½ ï¿½ ï¿½ xiï¿½tï¿½ if i ï¿½ L xi otherwise L Now we can define the functions fop pointwise by L L L fopï¿½x1,...,xkï¿½ ï¿½ ï¿½ï¿½t, fopï¿½x1ï¿½tï¿½,...,xk ï¿½tï¿½ï¿½ï¿½\u201aªt ï¿½ Ainstantï¿½ This lifting of operations generalizes existing operations that did not appear to be of great utility to operations that are quite useful. For example, an operator that determines the intersection of a region with a point may not be of great interest, but the operation that determines the intersection between a region and an mpoint (\u201a€œget the part of the mpoint within the region\u201a€) is quite useful. This explains why Section 4.2.3 takes care to define the set operations for all argument types, including single points. The fact that now all operations of the kernel algebra are also available as time-dependent operations results in a very powerful query language. Here are some examples. Example 14. We can formulate pretty involved queries such as \u201a€œFor how long did the moving point mp move along the boundary of region r?\u201a€ duration(deftime(at(on_border(mp, r), TRUE))) Here predicate on_border yields a result of type mbool. This result is defined for all times that mp is defined and has value TRUE or FALSE. Operation at reduces the definition time of this mbool to the times when it has value TRUE. Example 15. \u201a€œDetermine the periods of time when snow storm \u201a€˜Lizzy\u201a€™ consisted of exactly three separate areas.\u201a€ deftime(at(no_components(Lizzy) ï¿½ 3, TRUE)) Again, this works because \u201a€˜Lizzy\u201a€™ is of type mregion, hence the lifted versions of no_components and equality apply. Example 16. We are now able to define the closest operator of Example 11 within a query: LET closestï¿½ FUN (mp:mpoint, p:point) atinstant(mp, inst(initial(atmin(distance(mp, p))))) ACM Transactions on Database Systems, Vol. 25, No. 1, March 2000. A Foundation for Representing and Querying Moving Objects \u201a€¢ 29 This depends on the lifted distance operator. We reduce the resulting mreal to the times when it is minimal, take the first such (instant, value) pair and then the instant from this pair. Finally, the original moving point is taken at this instant. Lifting is the key to achieving the goal of consistency and closure between nontemporal and temporal operations, as explained in Section 4.1. 4.3.5 The Elusive when Revisited. After lifting the operations of the kernel algebra, it turns out that we have another way of expressing the query of Section 4.3.3: \u201a€œRestrict a moving region mr to the times when its size was greater 1000\u201a€. Using when, this was written as mr when[FUN (r:region) area (r) ï¿½ 1000] Using the lifted versions of area and ï¿½ , this is equivalent to atperiods(mr, deftime(at(area(mr) ï¿½ 1000, TRUE))) Why is it suddenly possible to realize the effect of the apparently unimplementable when? The reason is that we did not try to evaluate the parameter expression area(r) ï¿½ 1000 on infinitely many instances of parameter r, but instead evaluated its \u201a€œlifted version\u201a€ area(mr) ï¿½ 1000 on the original argument mr of when. In terms of implementation, there are two different functions (algorithms) for area, one that is applicable to region values, and one that is applicable directly to mregion values. We do not call the first algorithm (applicable to region values) infinitely many times, but instead the latter (applicable to mregion values) just once. This is in fact a general technique for translating when queries. It is applicable for all parameter expressions of when that are formed using operations of the kernel algebra only. The translation is x when[FUN(y:ï¿½) p(y)] ï¿½ atperiods(x, deftime(at(p(y)ï¿½, TRUE))) The substitution ï¿½ ï¿½ ï¿½y ï¿½ xï¿½, applied to p(y), replaces each occurrence of y with the original moving object x (of type moving(ï¿½)). Hence, when can be implemented by rewriting it in this way. So based on lifting and rewriting, we have in fact obtained an effective implementation of the when operator. 4.3.6 Rate of Change. An important property of any time-dependent value is its rate of change, i.e., its derivative. To determine which of our data types this concept is applicable to, consider the definition of the derivative, given next. fï¿½t ï¿½ï¿½tï¿½ ï¿½ fï¿½tï¿½ fï¿½ï¿½tï¿½ ï¿½ lim ï¿½t30 ï¿½t This definition, and thus the notion of derivation, is applicable to any temporal type movingï¿½ï¿½ï¿½ with a range type ï¿½ that (i) supports a difference operation and (ii) supports division by a value of type real. ACM Transactions on Database Systems, Vol. 25, No. 1, March 2000. 30 \u201a€¢ R. H. GÃ¼ting et al. Table XVII. Derivative Operations Operation Signature Semantics derivative speed turn velocity mreal mpoint mpoint mpoint 3 real 3 mreal 3 mreal 3 mpoint ï¿½ï¿½ where ï¿½ï¿½ï¿½tï¿½ ï¿½ lim ï¿½ï¿½ï¿½t ï¿½ ï¿½ï¿½ ï¿½ ï¿½ï¿½tï¿½ï¿½ï¿½ ï¿½ ï¿½30 ï¿½ï¿½ where ï¿½ï¿½ï¿½tï¿½ ï¿½ lim f ï¿½30 distanceï¿½ï¿½ï¿½t ï¿½ ï¿½ï¿½, ï¿½ï¿½tï¿½ï¿½ï¿½ ï¿½ ï¿½ï¿½ where ï¿½ï¿½ï¿½tï¿½ ï¿½ lim f ï¿½30 directionï¿½ï¿½ï¿½t ï¿½ ï¿½ï¿½, ï¿½ï¿½tï¿½ï¿½ï¿½ ï¿½ ï¿½ï¿½ where ï¿½ï¿½ï¿½tï¿½ ï¿½ lim ï¿½ï¿½ï¿½t ï¿½ ï¿½ï¿½ ï¿½ ï¿½ï¿½tï¿½ï¿½ï¿½ ï¿½ ï¿½30 Type real clearly qualifies as a range type. For type point, at least three operations may assume the role of difference in the definition, namely the Euclidean distance, the direction between two points, and the vector difference (viewing points as 2D vectors). This leads to three different derivative operations, which we call speed, turn, and velocity, respectively (see Table XVII). Note that we can get the acceleration of a moving point mp as a number by derivative(speed(mp)) and as a vector, or moving point, by velocity(velocity(mp)). The notion of derivation does not apply to the discrete data types int, string, and bool because there is no division available (for string and bool, a difference operation is also absent). There is also no obvious way to define difference and division for regions, although some ideas for this are discussed in GÃ¼ting et al. [1998]. Example 17. Nevertheless, one can still observe, for example, the growth rate of a moving region: \u201a€œAt what time did snow storm Lizzy expand most?\u201a€ inst(initial(atmax(derivative(area(Lizzy))))) Example 18. \u201a€œShow on a map the parts of the route of flight 257 when the plane\u201a€™s speed exceeds 800 km/h.\u201a€ trajectory(atperiods(route257, deftime(at(speed(route257) ï¿½800,TRUE)))) Of course, the background of the map still has to be produced by a different tool or query. 4.4 Operations on Sets of Objects All operations defined in Sections 4.2 and 4.3 apply to \u201a€œatomic\u201a€ data types only, i.e., attribute data types with respect to a DBMS data model. All data types of our design, as described in Section 3, and including the temporal ones, are atomic in this sense. However, sometimes in the design of data types for new applications there are operations of interest that cannot be formulated in terms of the atomic data types alone, but need to manipulate a set of database objects (with attributes of the new data types) as a whole. An example in spatial databases is the computation of a Voronoi diagram. Such data type related operations on sets of objects have been introduced earlier, for example, in the ROSE algebra [GÃ¼ting and Schneider 1995]. In the design of this paper we need only a single set operator, called decompose. Its purpose is to make the components of values of point set types accessible within a query. \u201a€œComponents\u201a€ refers to connected compo- ACM Transactions on Database Systems, Vol. 25, No. 1, March 2000. A Foundation for Representing and Querying Moving Objects \u201a€¢ 31 Table XVIII. Operations on Sets of Database Objects Operation Signature Semantics decompose setï¿½ï¿½ 1ï¿½ ï¿½ ï¿½ï¿½ 13ï¿½ï¿½ ï¿½ ident 3 setï¿½ï¿½ 2ï¿½ see Def. 18 setï¿½ï¿½ 1ï¿½ ï¿½ ï¿½ï¿½ 13movingï¿½ï¿½ï¿½ï¿½ ï¿½ ident 3 setï¿½ï¿½ 2ï¿½ see Def. 18 nents; all our point set types are defined to have a structure that consists of a finite number of connected components. For any range type, a component is a single interval; for the types points, line, and region, a component is a single point, a maximal connected subgraph, and a face, respectively (this is defined formally below). Decomposition basically transforms a value of some point set type ï¿½ into a set of values of the same type ï¿½ such that each value in the result set contains a single component. Similarly, decompose makes the connected components of temporal data types available. Here a component is a maximal continuous part of the function value. As a manipulation of a set of database objects, this is treated as follows. The first argument of decompose is a set of database objects (e.g., a set of tuples in the relational model). The second argument is a function (e.g., an attribute name) that maps an object (e.g., a tuple) into a value of some point set type. The third argument is an identifier, used as a name for a new attribute. The result set of objects is produced as follows: For each object u with an attribute value that has k components, decompose returns k copies of u, each of which is extended by one of the k component values (under the new attribute). The signature is shown in Table XVIII. The syntax for applying this operator is arg 1 opï¿½arg 2, arg 3ï¿½. The semantics can be defined formally as follows. Let S be a value of any of our point set types, and ï¿½ a value of a temporal type. We first define a generic function comp to decompose S or ï¿½ into a finite set of values of the same type, namely: ï¿½ intvlsï¿½Sï¿½ compï¿½Sï¿½ ï¿½ compï¿½ï¿½ï¿½ ï¿½ï¿½ï¿½ï¿½ï¿½ if S is of type rangeï¿½ï¿½ï¿½ ï¿½ï¿½pï¿½\u201aªp ï¿½ Sï¿½ if S is of type points blocksï¿½Sï¿½ if S is of type line facesï¿½Sï¿½ if S is of type region Here ï¿½ï¿½ï¿½ï¿½ is the function that determines the maximal continuous components of a moving object ï¿½ as defined in the Appendix. Let O ï¿½ ï¿½o 1,...,o nï¿½ be a set of database objects (e.g., tuples) and let attr be a function yielding an attribute value of a database object o ï¿½ O. Let name be a name for the new attribute. Furthermore, let Q be a function that appends an attribute value to a database object, or an attribute to an object type. Then ACM Transactions on Database Systems, Vol. 25, No. 1, March 2000. 32 \u201a€¢ R. H. GÃ¼ting et al. f decomposeï¿½O, attr, nameï¿½ ï¿½ ï¿½o Q v\u201aªo ï¿½ O, v ï¿½ compï¿½attrï¿½oï¿½ï¿½ï¿½ The type mapping performed by the decompose operator is ï¿½ decomposeï¿½setï¿½ï¿½ 1ï¿½, ï¿½ 13ï¿½, nameï¿½ ï¿½ setï¿½ï¿½ 1 Q ï¿½name, ï¿½ï¿½ï¿½ That is, the result is a set of objects with an additional attribute \u201a€œname\u201a€ of type ï¿½. Example 19. Consider the relation country(name:string, area:region) introduced earlier. The query country decompose[area,part] returns a relation with schema (name: string, area: region, part: region) Example 20. This example illustrates decomposition of a temporal value. Let us assume that flight 257 alternates between being over land areas of Europe and over the sea. We would like to see a list of time periods, ordered by duration, when flight 257 was over land. LET land257 ï¿½ SET(route, at(route257, Europe)) decompose[route, piece]; SELECT start AS min(deftime(piece)), duration AS duration(deftime(piece)) end AS max(deftime(piece)), FROM land257 ORDER BY duration Here the at operation restricts flight 257 to the parts above Europe (whose area was computed earlier in Example 4). The SET constructor transforms this into a relation with one tuple and a single attribute route containing this value. Then decompose is applied to this relation, which puts each component of the moving point into a separate tuple. The relation land257 created in this way is then processed in the next part of the query. <\/solution>  <experiment> "},{"aspect":"problemdef","tweet":" 2. PRELIMINARIES: LANGUAGE EMBEDDING In order to illustrate the use of the framework of abstract data types in queries, they must be embedded in a query language. A range of languages would suffice for this purpose, including theoretical and practical languages as well as relational, object-relational, and object-oriented languages. We do not care which language our design, which can be viewed as an application-specific sublanguage, is embedded. In the examples we show an embedding into a relational model and an SQL-like language, with which most readers should be familiar. To achieve a smooth interplay between the embedding language and an embedded system of abstract data types, a few interface facilities and notation are needed, expressible in one form or another in most objectoriented or object-relational query languages. In order not to be bound to any particular SQL standard, we briefly explain our notation for these facilities. ACM Transactions on Database Systems, Vol. 25, No. 1, March 2000. A Foundation for Representing and Querying Moving Objects \u201a€¢ 5 Assignments. The construct LET ï¿½nameï¿½ ï¿½ï¿½queryï¿½ assigns the result of query to a new object called name which can then be used in further steps of a query. Multistep queries. A query can be written as a list of assignments, separated by semicolons, followed by one or more query expressions. The latter are displayed as the result of the query. Conversions between sets of objects and atomic values. In relational terms, this means that a relation with a single tuple and a single attribute can be converted into a typed atomic value and vice-versa. We use the notation ELEMENT(ï¿½queryï¿½) and SET(ï¿½attrnameï¿½, ï¿½valueï¿½) for this. For example, the expression SET(name, \u201a€œJohn Smith\u201a€) returns a relation with an attribute name and a single tuple having John Smith as the value of that attribute. Defining derived attributes. We assume that arbitrary ADT operations over new or old data types may occur anywhere in a WHERE clause, as long as in the end a predicate is constructed, and they can be used in a SELECT clause to produce new attributes, with the notation ï¿½new attrnameï¿½ AS ï¿½expressionï¿½ Defining operations. We allow for the definition of new operations derived from existing ones, in the form LET ï¿½nameï¿½ ï¿½ ï¿½functional expressionï¿½. A functional expression has the form FUN (ï¿½parameter listï¿½) ï¿½expressionï¿½; it corresponds to lambda abstraction in functional languages. Example 1. This example shows how a new operation \u201a€œsquare\u201a€ can be defined and used. LET square ï¿½ FUN (m:integer)m*m;square(5) Defining aggregate functions. Any binary, associative, and commutative operation defined on a data type can be used as an aggregate function over a column of that data type, using the notation AGGR(ï¿½attrnameï¿½, ï¿½operatorï¿½, ï¿½neutral elementï¿½). In case the relation is empty, the neutral element is returned. In case it has a single tuple, then that single attribute value is returned; otherwise the existing values are combined by the given operator. Moreover, a name for the aggregate function can be defined by LET ï¿½nameï¿½ï¿½AGGREGATE(ï¿½operatorï¿½, ï¿½neutral elementï¿½). Example 2. Given a relation emp(name:string, salary:int, permanent:bool), we can sum all salaries by SELECT AGGR(salary, ï¿½, 0) FROM emp We can determine whether all employees have permanent positions by LET all ï¿½ AGGREGATE(and, TRUE); SELECT all(permanent) FROM emp ACM Transactions on Database Systems, Vol. 25, No. 1, March 2000. 6 \u201a€¢ R. H. GÃ¼ting et al. Table I. Signature for Stack Operations Operator Signature empty 3 STACK push STACK ï¿½ INT 3 STACK pop STACK 3 INT  "},{"aspect":"solution","tweet":" 3. SPATIO-TEMPORAL DATA TYPES In this and the next section we define a system of data types and operations, or an algebra, suitable for representing and querying geometries changing over time, and in particular, moving objects. Defining an algebra consists of two steps. In the first step we design a type system by introducing some basic types as well as some type constructors. For each type in the type system, its semantics is given by defining a carrier set. In the second step we design a collection of operations over the types of the type system. For each operation, its signature is defined, describing the syntax of the operation, i.e., the correct argument and result types, and its semantics is given by defining a function on the carrier sets of the argument types. In this section we define the type system; operations are given in Section 4. 3.1 The Type System We define the type system as a signature. Any (many-sorted) signature consists of sorts and operators, where the sorts control the applicability of operators (see, e.g., Loeckx et al. [1996]). A signature generates a set of terms. Signatures are well known from the definition of abstract data types. For example, in the description of a stack we have sorts STACK, INT, and BOOL, and operators push, pop, and empty, as shown in Table I. A term of this signature is push(empty, 8). When we use a signature for defining a type system, the sorts are called kinds and describe certain subsets of types, and in the role of operators we have type constructors. The terms generated by the signature describe exactly the types available in our type system. For more background on this technique for defining type systems and algebras, see GÃ¼ting [1993]. Table II shows the signature defining our type system. Here, kinds are written in capitals and type constructors in italics. Terms, and therefore types, generated by this signature are, e.g., int, region, moving(point), range(int), etc. The range type constructor is applicable to all the types in the kind BASE and all types in kind TIME, hence all types that can be constructed by it are range(int), range(real), range (string), range(bool), and range(instant). Type constructors with no arguments, for example region, are types already and are called constant types. One can see that quite a few types are around. Although the focus of interest are the spatio-temporal types, especially moving(point) and moving(region), to obtain a closed system of operations it is necessary to include the related spatial, time, and base types into the design. ACM Transactions on Database Systems, Vol. 25, No. 1, March 2000. A Foundation for Representing and Querying Moving Objects \u201a€¢ 7 Table II. Signature Describing the Type System Type constructor Signature int, real, string, bool 3 BASE point, points, line, region 3 SPATIAL instant 3 TIME moving, intime BASE ï¿½ SPATIAL 3 TEMPORAL range BASE ï¿½ TIME 3 RANGE So far we have just introduced some names for types. In the sequel we describe their semantics first informally, and then formally by defining carrier sets. We start with the constant types and then discuss (proper) type constructors. 3.1.1 Base Types. The base types are int, real, string, and bool. All base types have the usual interpretation, except that each domain is extended by the value ï¿½ (undefined). Definition 1. For a type ï¿½ its carrier set is denoted by Aï¿½. The carrier sets for the types int, real, string, and bool, are defined as A int\u201a€“ï¿½ï¿½ï¿½ï¿½ï¿½, A real\u201a€“ï¿½ï¿½ï¿½ï¿½ï¿½, A string\u201a€“V * ï¿½ ï¿½ï¿½ï¿½, where V is a finite alphabet, A bool\u201a€“ï¿½FALSE, TRUEï¿½ ï¿½ ï¿½ï¿½ï¿½. We sometimes need to talk about the carrier set without the undefined value. As a shorthand for this, we define Aï¿½ ï¿½\u201a€“A ï¿½\\ï¿½ï¿½ï¿½. 3.1.2 Spatial Types. Basic conceptual entities that have been identified in spatial database research are point, line, and region [GÃ¼ting 1994]. In our design we use four types called point, points, line, and region. They are illustrated in Figure 1. Informally, these types have the following meaning. A value of type point represents a point in the Euclidean plane or is undefined. A points value is a finite set of points. A line value is a finite set of continuous curves in the plane. A region is a finite set of disjoint parts called faces, each of which may have holes. It is allowed that a face lies within a hole of another face. Each of the three set types may be empty. Formal definitions are based on the point set paradigm and on point set topology. The point set paradigm expresses that space is composed of infinitely many points and that spatial objects are distinguished subsets of space which are viewed as entities. Point set topology provides concepts of continuity and closeness and allows one to identify special topological structures of a point set like its interior, closure, boundary, and exterior. ACM Transactions on Database Systems, Vol. 25, No. 1, March 2000. 8 \u201a€¢ R. H. GÃ¼ting et al. a point value a points value a line value a region value Fig. 1. The spatial data types. We assume the reader is familiar with basic concepts of topology 1 [Gaal 1964]. Point and point set types are still quite simple: Definition 2. The carrier sets for the types point and points are: A points\u201a€“ï¿½ 2 ï¿½ ï¿½ï¿½ï¿½, A points\u201a€“ï¿½P ï¿½ ï¿½ 2 ï¿½ P is finiteï¿½ For the definition of lines, we need the concept of a curve. Definition 3. A curve is a continuous mapping f : ï¿½0, 1ï¿½3ï¿½ 2 such that @a, b ï¿½ ï¿½0, 1ï¿½ : fï¿½aï¿½ ï¿½ fï¿½bï¿½faï¿½b\u201aˆ¨ï¿½a, bï¿½ ï¿½ ï¿½0, 1ï¿½. Let rngï¿½ f ï¿½ ï¿½ ï¿½p ï¿½ ï¿½ 2 ï¿½ ?a ï¿½ ï¿½0, 1ï¿½ : fï¿½aï¿½ ï¿½ pï¿½. Two curves f, g are called equivalent iff rngï¿½ f ï¿½ ï¿½ rngï¿½gï¿½. The points fï¿½0ï¿½ and fï¿½1ï¿½ are called the end points of f. Iffï¿½0ï¿½ ï¿½ fï¿½1ï¿½ ï¿½ p, then we say f is a loop in p. This definition allows loops (fï¿½0ï¿½ ï¿½ fï¿½1ï¿½), but forbids equality of different interior points and equality of an interior with an end point. The curves that we want to deal with must be simple in the sense that the intersection of two curves yields only a finite number of proper intersection points (disregarding common parts that are curves themselves). This is ensured by the following definitions. Definition 4. Let Q ï¿½ ï¿½ 2 and p ï¿½ Q. p is called isolated Q :N?ï¿½ ï¿½ ï¿½, ï¿½ ï¿½ 0:Uï¿½ p, ï¿½ï¿½ ï¿½ ï¿½Q\\ï¿½pï¿½ï¿½ ï¿½ \u201a€. Here Uï¿½ p, ï¿½ï¿½ denotes an open disk around p with radius ï¿½. The set of all isolated points in Q is denoted as isolatedï¿½Qï¿½. Definition 5. Let C be the set of all curves w.r.t. Def. 3. A class of curves Cï¿½ ï¿½ C is called simple :N @c 1, c 2 ï¿½ Cï¿½ : isolatedï¿½rngï¿½c 1ï¿½ ï¿½ rngï¿½c 2ï¿½ï¿½ is finite. 1 In the simple Euclidean spaces considered in this paper, these notions can be characterized as follows. Let X be the space (i.e., ï¿½ or ï¿½ 2 ) and S ï¿½ X. For ï¿½ ï¿½ 0, let Uï¿½x, ï¿½ï¿½ ï¿½ ï¿½ p ï¿½ X ï¿½ dï¿½ p, xï¿½ ï¿½ ï¿½ï¿½ be an ï¿½-disk around x, where d is the distance metric. A point x ï¿½ X belongs to the interior of S, denoted S o , if there exists an ï¿½-disk around x contained in S. It belongs to the boundary of S, denoted ï¿½S, if every ï¿½-disk around x intersects both S and the complement of S. It belongs to the exterior of S, denoted S e , if it is in the interior of the complement of S. The closure of S is S ï¿½ ï¿½S. A set is closed if it contains its boundary. Hence any set S partitions the space X into three disjoint parts S o , ï¿½S, and S e . ACM Transactions on Database Systems, Vol. 25, No. 1, March 2000. A Foundation for Representing and Querying Moving Objects \u201a€¢ 9 The line data type is to represent any finite union of curves from some class of simple curves. When the abstract design of data types given in this paper is implemented by some discrete design (as explained in the introduction), some class of curves will be selected for representation, for example, polygonal lines, curves described by cubic functions, etc. We just require that the class of curves selected has this simplicity property. This is needed, for example, to ensure that the intersection operation between two line values yields a finite set of points representable by the points data type. A finite union of curves basically yields a graph structure embedded into the plane (whose nodes are intersections of curves and whose edges are intersection-free pieces of curves). Given a set of points of such a graph, there are many different sets of curves resulting in this point set. For example, a path over the graph could be interpreted as a single curve or as being composed of several curves. The following definitions ensure that (i) a line value is a point set in the plane that can be described as a finite union of curves, and (ii) there is a unique collection of curves that can serve as a \u201a€œcanonical\u201a€ representation of this point set. Definition 6. Let f, g be curves. They are quasi-disjoint iff @a, b ï¿½ ï¿½0, 1ï¿½ : fï¿½aï¿½ ï¿½ fï¿½bï¿½. They meet in a point p iff ?a, b ï¿½ ï¿½0, 1ï¿½ : fï¿½aï¿½ ï¿½ p ï¿½ gï¿½bï¿½. Definition 7. Let S be a class of curves. A C-complex over S is a finite set of curves C ï¿½ S such that (1) @f, g ï¿½ C, f ï¿½ g: f and g are quasi-disjoint. (2) @f, g ï¿½ C, f ï¿½ g: f and g meet in p f ï¿½?h ï¿½ C, f ï¿½ h ï¿½ g such that f and h meet in p) \u201aˆ¨ (f or g is a loop in p). The set of points of this C-complex is denoted pointsï¿½Cï¿½, isï¿½ cï¿½Crngï¿½cï¿½. The set of all C-complexes over S is denoted by CCï¿½Sï¿½. The second condition ensures that whenever two curves meet in a point p, then at least three (ends) of these curves must meet at this point, and so it is not possible to merge the two curves into one. Definition 8. Let S be a simple class of curves. The carrier set of the line data type is A line\u201a€“ï¿½Q ï¿½ ï¿½ 2 ï¿½ ?C ï¿½ CCï¿½Sï¿½ : pointsï¿½Cï¿½ ï¿½ Qï¿½ Since for a given line value Q there is a unique 2 C-complex C with pointsï¿½Cï¿½ ï¿½ Q, we can denote it by scï¿½Qï¿½ (the simple curves of Q). 2 To be precise, the C-complex is uniquely determined up to the equivalence of the curves in it. Essentially this means that the graph structure (as a set of curves corresponding to edges) is uniquely determined; but for the definition of a single edge, one C-complex may have a curve f and another one a curve g, where f and g are equivalent, i.e., rngï¿½ f ï¿½ ï¿½ rngï¿½gï¿½. The graph structure is uniquely determined because edges (curves) intersect only in their end points and are maximal. ACM Transactions on Database Systems, Vol. 25, No. 1, March 2000. 10 \u201a€¢ R. H. GÃ¼ting et al. For some operations we need a notion of components of a line value. Let meet* denote the transitive closure of the meet relationship on curves. This is an equivalence relation that partitions a C-complex into connected components, denoted components(C) (each of which is a C-complex as well). For a line value Q, the decomposition into corresponding point sets is defined as blocksï¿½Qï¿½ ï¿½ ï¿½pointsï¿½Cï¿½ï¿½ ï¿½Cï¿½ ï¿½ componentsï¿½scï¿½Qï¿½ï¿½ï¿½. A region value is defined as a point set in the plane with a certain structure. Similarly as for line, we first define the structure, called an R-complex now, and its associated point set, and then define a region as a point set that could belong to such an R-complex. Again, for a region point set, its R-complex is uniquely defined. For the definition, we need the concept of a regular closed set. A set Q ï¿½ ï¿½ 2 is called regular closed if the closure of its interior coincides with the set itself, i.e., Q ï¿½ closureï¿½Q o ï¿½. The reason for this regularization process is that regions should not have geometric anomalies such as an isolated or dangling line or point features and missing lines and points in the form of cuts and punctures. Definition 9. Two regular closed sets Q and R are called quasi-disjoint: N Q ï¿½ R is finite. Definition 10. Let S be a class of curves. An R-complex over S is a finite set R of nonempty, regular closed sets, such that (1) Any two distinct elements of R are quasi-disjoint. (2) @r ï¿½ R, ?c ï¿½ CCï¿½Sï¿½ : ï¿½r ï¿½ pointsï¿½cï¿½. Here ï¿½r denotes the boundary of r. Each element of the R-complex is called a face. The union of all points of all faces is denoted pointsï¿½Rï¿½. The set of all R-complexes over S is denoted RCï¿½Sï¿½. Hence, a region can be viewed as a finite set of components called faces. Any two faces of a region are disjoint except for finitely many \u201a€œtouching points\u201a€ at the boundary. Moreover, the definition ensures that boundaries of faces are simple in the same sense that lines are simple. For example, the intersection of two regions will also produce only finitely many isolated intersection points. Note that the boundary of a face has outer as well as possibly inner parts, i.e., the face may have holes. Definition 11. Let S be a simple class of curves. The carrier set of the region data type is defined as A region\u201a€“ï¿½Q ï¿½ ï¿½ 2 ï¿½ ?R ï¿½ RCï¿½Sï¿½ : Q ï¿½ pointsï¿½Rï¿½ï¿½ We require that the same class S of curves is used in defining the line and the region type. Since for a given region value Q, its R-complex is uniquely defined, we can denote it by faces(Q). ACM Transactions on Database Systems, Vol. 25, No. 1, March 2000. A Foundation for Representing and Querying Moving Objects \u201a€¢ 11 We extend the shorthand Aï¿½ to the spatial data types, and in fact to all types whose carrier set contains sets of values. For these types ï¿½, we define Aï¿½ ï¿½\u201a€“A ï¿½\\ï¿½\u201a€ï¿½. 3.1.3 Time Type. Type instant represents a point in time or is undefined. Time is considered to be linear and continuous, i.e., isomorphic to the real numbers. Definition 12. The carrier set for instant is A instant\u201a€“ï¿½ï¿½ï¿½ï¿½ï¿½ 3.1.4 Temporal Types. From the base types and spatial types, we want to derive corresponding temporal types. The type constructor moving is used for this purpose. It yields for any given type ï¿½ a mapping from time to ï¿½. More precisely, this means the following: Definition 13. Let ï¿½ be a data type to which the moving type constructor is applicable, with carrier set A ï¿½. Then the carrier set for moving(ï¿½), is defined as follows: A movingï¿½ï¿½ï¿½\u201a€“ï¿½f\u201aªf : A ï¿½ instant3A ï¿½ ï¿½ is a partial function \u201aˆ§ ï¿½ï¿½fï¿½ is finiteï¿½ Hence, each value f from the carrier set of moving(ï¿½) is a function describing the development over time of a value from the carrier set of ï¿½. The condition \u201a€œ ï¿½ï¿½ f ï¿½ is finite\u201a€ says that f consists of only a finite number of continuous components. This is made precise in the Appendix, where a generalized notion of continuity is defined. This condition is needed (i) to ensure that projections of moving objects (e.g., into the 2D plane) have only a finite number of components; (ii) for the decompose operation defined below; and (iii) as a precondition to make the design implementable. For all \u201a€œmoving\u201a€ types we introduce extra names by prefixing the argument type with an \u201a€œm\u201a€, that is, mpoint, mpoints, mline, mregion, mint, mreal, mstring, and mbool. This is just to shorten some signatures. The temporal types obtained through the moving type constructor are functions, or infinite sets of pairs (instant, value). It is practical to have a type for representing any single element of such a function, i.e., a single (instant, value)-pair, for example, to represent the result of a time-slice operation. The intime type constructor converts a given type ï¿½ into a type that associates instants of time with values of ï¿½. Definition 14. Let ï¿½ be a data type to which the intime type constructor is applicable with carrier set A ï¿½. Then the carrier set for intime(ï¿½), is defined as follows: A intimeï¿½ï¿½ï¿½\u201a€“A instant ï¿½ A ï¿½ ACM Transactions on Database Systems, Vol. 25, No. 1, March 2000. 12 \u201a€¢ R. H. GÃ¼ting et al. 3.1.5 Range Types (Sets of Intervals). For all temporal types we would like to have operations that correspond to projections into the domain and the range of the functions. For the moving counterparts of the base types, e.g., moving(real) (whose values come from a one-dimensional domain), the projections are, or can be, compactly represented as sets of intervals over the one-dimensional domain. Hence, we are interested in types to represent sets of intervals over the real numbers, over the integers, etc. Such types are obtained through a range type constructor. Definition 15. Let ï¿½ be a data type to which the range type constructor is applicable (and hence on which a total order ï¿½ exists). An ï¿½-interval is a set X ï¿½ A ï¿½ ï¿½ such that @x, y ï¿½ X, @z ï¿½ A ï¿½ ï¿½ : x ï¿½ z ï¿½ yfzï¿½X. Two ï¿½-intervals are adjacent, if they are disjoint and their union is an ï¿½-interval. An ï¿½-range is a finite set of disjoint, nonadjacent intervals. For an ï¿½-range R, pointsï¿½Rï¿½ denotes the union of all its intervals. Intervals may include their left and/or right boundaries or not, and so be left-open, etc. Definition 16. Let ï¿½ be any data type to which the range type constructor is applicable. Then the carrier set for range(ï¿½) is A rangeï¿½ï¿½ï¿½\u201a€“ï¿½X ï¿½ A ï¿½ ï¿½ ï¿½ ? an ï¿½-range R : X ï¿½ pointsï¿½Rï¿½ï¿½ Again, a range value X has a unique associated ï¿½-range denoted by intvlsï¿½ X ï¿½. Because we are particularly interested in ranges over the time domain, we introduce a special name for this type: periods ï¿½ rangeï¿½instantï¿½. 3.2 Rationale for this Design The most important design principles that led to this particular choice of data types are the following: (1) Closure and consistency between nontemporal and temporal types. For all base types and all spatial types, corresponding temporal types are introduced through the moving constructor. The use of the type constructor, instead of ad-hoc definition of temporal types, ensures consistency. (2) Closure under projection. For all temporal types, data types must be available to represent the results of projections into the (time) domain and range, as well as the result of a time-slice operation. (3) Uniform support of point vs. point set view. All data types belong to either a one-dimensional or a two-dimensional space. This third principle requires that, in each space, we have data types to represent a single value (called a point) and a set of values (a point set). This is the basis for the definition of generic operations described in the next section, and is explained in more detail there. A deeper discussion of design considerations can be found in GÃ¼ting et al. [1998]. ACM Transactions on Database Systems, Vol. 25, No. 1, March 2000. 4. OPERATIONS A Foundation for Representing and Querying Moving Objects \u201a€¢ 13 4.1 Overview The design of the operations adheres to three principles: (i) design operations that are as generic as possible; (ii) achieve consistency between operations on nontemporal and temporal types; and (iii) capture the interesting phenomena. The first principle is crucial, as our type system is quite large. To avoid a proliferation of operations, it is mandatory to find a unifying view of collections of types. The basic approach to achieve this is to relate each type to either a one-dimensional or a two-dimensional space and to consider all values either as single elements or subsets of the respective space. For example, type int describes single elements of the one-dimensional space of integers, while range(int) describes sets of integers. Similarly, point describes single elements of two-dimensional space, whereas points, line, and region describe subsets of the two-dimensional space. Second, in order to achieve consistency of operations on nontemporal and temporal types, we proceed in two steps. In the first, we define operations on nontemporal types. In the second, we systematically extend operations defined in the first step to the temporal variants of the respective types. This is called lifting. Third, in order to obtain a powerful query language, it is necessary to include operations that address the most important concepts from various domains (or branches of mathematics). Whereas simple set theory and first-order logic are certainly the most fundamental and best-understood parts of query languages, we also need to have operations based on order relationships, topology, metric spaces, etc. There is no clear recipe to achieve closure of interesting phenomena; nevertheless, this should not keep us from having concepts and operations such as distance, size of a region, relationships of boundaries, and the like. Section 4 is structured as follows. Section 4.2 develops an algebra over nontemporal types, based on the generic point and point set (value vs. subset of space) view of these types. The classes of operations considered are shown in Table III, which also gives an overview of operations by just listing their names. Section 4.3 defines operations on temporal types. The classes of operations are shown in Table IV. Finally, an operation that is based on our data types is needed, but requires a manipulation of a set of objects in the database (e.g., a relation). It is called decompose and is treated in Section 4.4. 4.2 Operations on Nontemporal Types In this section we first carefully study operations on nontemporal types. Although the focus of the paper is on the treatment of moving objects, and hence on temporal types, this first step is crucial because later all these operations will, by the process of lifting, become operations on temporal types as well. The following design is adapted to that purpose. ACM Transactions on Database Systems, Vol. 25, No. 1, March 2000. 14 \u201a€¢ R. H. GÃ¼ting et al. Table III. Classes of Operations on Nontemporal Types Class Operations Predicates isempty ï¿½, ï¿½, intersects, inside ï¿½, ï¿½, ï¿½, ï¿½, before touches, attached, overlaps, on_border, in_interior Set Operations intersection, union, minus crossings, touch_points, common _border Aggregation min, max, avg, center, single Numeric no_components, size, perimeter, duration, length, area Distance and Direction distance, direction Base Type Specific and, or, not Table IV. Classes of Operations on Temporal Types Class Operations Projection to Domain/Range deftime, rangevalues, locations, trajectory routes, traversed, inst, val Interaction with Domain/Range atinstant, atperiods, initial, final, present at, atmin, atmax, passes When when Lifting (all new operations inferred) Rate of Change derivative, speed, turn, velocity As motivated above, we take the view that we are dealing with single values and sets of these values in one-dimensional and two-dimensional spaces. The types can then be classified according to Table V. (Remember that by temporal types we mean types representing functions of time. Types instant and periods are not temporal types in this sense.) Table V shows that we are dealing with five different one-dimensional spaces called Integer, Boolean, etc., and one two-dimensional space called 2D. For example, the two types belonging to space Integer are int and range(int). One-dimensional spaces are further classified as being discrete or continuous. The distinction between one-dimensional and two-dimensional spaces is relevant because only the one-dimensional spaces have a (natural) total order. The distinction between discrete and continuous one-dimensional spaces is important for certain numeric operations. To have a uniform terminology in any of the respective spaces, we call a single element a point and a subset of the space a point set, and we classify types accordingly as point types or point set types. Example 3. We introduce the following example relations for use within this section, representing cities, countries, rivers, and highways in Europe. city(name:string, pop:int, center:point) country(name:string, area:region) river(name:string, route:line) highway(name:string, route:line) 4.2.1 Notation for Signatures. Let us briefly introduce notation for signatures that are partly based on Table V. In defining operation signa- ACM Transactions on Database Systems, Vol. 25, No. 1, March 2000. A Foundation for Representing and Querying Moving Objects \u201a€¢ 15 Table V. Classification of Nontemporal Types 1D Spaces 2D Space discrete continuous Integer Boolean String Real Time 2D point int bool string real instant point point set range(int) range(bool) range(string) range(real) periods points, line, region tures and semantics, ï¿½ and ï¿½ are type variables, ranging over all point and all point set types of Table V, respectively. If several type variables occur in a signature (e.g., for binary operations), then they are always assumed to range over types of the same space. Hence, in a signature ï¿½ ï¿½ ï¿½3ï¿½we can, for example, select the one-dimensional space Integer and instantiate ï¿½ to int and ï¿½ to range(int). Or we can select the two-dimensional space 2D where we can instantiate ï¿½ to point and ï¿½ to either points, line, orregion. A signature ï¿½ 1 ï¿½ ï¿½ 23ï¿½ means that the type variables ï¿½ 1 and ï¿½ 2 can be instantiated independently; nevertheless, they have to range over the same space. In contrast, a signature ï¿½ ï¿½ ï¿½3ï¿½says that both arguments have to be of the same type. The notation ï¿½ R ï¿½3ï¿½is used if any order of the two argument types is valid, hence it is an abbreviation for signatures ï¿½ ï¿½ ï¿½3ï¿½and ï¿½ ï¿½ ï¿½3ï¿½. Some operations are restricted to certain classes of spaces; these classes are denoted as 1D ï¿½ {Integer, Boolean, String, Real, Time}, 2D ï¿½ {2D}, 1Dcont ï¿½ {Real, Time}, 1Dnum ï¿½ {Integer, Real, Time}, and cont ï¿½ {Real, Time, 2D}. A signature is restricted to a class of spaces by putting the name of the class behind it in square brackets. For example, a signature ï¿½3ï¿½ [1D] is valid for all one-dimensional spaces. A single operation may have several functionalities (signatures). Sometimes, for a generic operation, there exist more appropriate names for arguments of more specific types. For example, there is a size operation for any point set type; however, for type periods, it makes more sense to call this size duration. In such a case, we introduce the more specific name as an alias with the notation size[duration]. In defining semantics, u, v, ... denote single values of a ï¿½ type, and U, V, ... generic sets of values (point sets) of a ï¿½ type. For binary operations, u or U refers to the first and v or V to the second argument. Furthermore, b (B) ranges over values (sets of values) of base types, and predicates are denoted by p. Weuseï¿½ to range over moving objects and tï¿½Tï¿½ to range over instant values (periods). For the definition of the semantics of operations, we generally assume strict evaluation, i.e., for any function f op defining the semantics of an operation op we assume f opï¿½. ..,ï¿½, ...ï¿½ ï¿½ ï¿½. We will therefore not handle undefined arguments explicitly in definitions. ACM Transactions on Database Systems, Vol. 25, No. 1, March 2000. 16 \u201a€¢ R. H. GÃ¼ting et al. Table VI. Unary Predicates Operation Signature Semantics isempty[undefined] ï¿½ 3 bool u ï¿½ ï¿½ ï¿½ 3 bool U ï¿½ \u201a€ The syntax for operations in queries is the prefix notation op(arg1, ...,argn). Exceptions are the comparison operators ï¿½, ï¿½, etc., and the Boolean operators and and or, for which it is customary to have infix notation. For two operators, when and decompose, a special syntax is defined explicitly below. 4.2.2 Predicates. We consider unary and binary predicates. On this abstract level, there are not many unary predicates one can think of. For a single point, we can ask whether it is undefined, and for a point set, we can ask whether it is empty. The generic predicate isempty is used for this purpose (Table VI). To achieve some completeness, the design of binary predicates is based on the following strategy. First, we consider possible relationships between two points (single values), two point sets, and a point vs. a point set in the respective space. Second, orthogonal to this, predicates are based on three different concepts, namely set theory, order relationships, and topology. Order means total order here, which is available only in one-dimensional spaces. Topology means considering for a point set U its boundary ï¿½U and interior U o . This design space for binary predicates is shown in Table VII. The idea is to systematically evaluate the possible interactions between single values and sets and, based on that, to introduce (names for) operations. For example, we find that checking whether boundaries intersect is important, and then introduce touches as a name for this. Note that operations in the middle column are available in one-dimensional (ordered) spaces in addition to those in the other columns. As a result, we obtain the signature in Table VIII. We have not offered any predicates related to distance or direction (e.g., \u201a€œnorth\u201a€). However, such predicates can be obtained via numeric evaluations (see Section 4.2.6). A discussion of the completeness of the predicates can be found in GÃ¼ting et al. [1998]. 4.2.3 Set Operations. Set operations are fundamental and are available for all point-set types. Where feasible, we also allow set operations on point types, thus allowing expressions such as u minus v and U minus u. Singleton sets or empty sets that result from this use are interpreted as point values. This is possible because all domains include the undefined value (ï¿½), whose meaning we identify with the empty set. Permitting set operations on point types is especially useful in the context of temporal types, as we shall see later. There is no union operation on two single ACM Transactions on Database Systems, Vol. 25, No. 1, March 2000. point vs. point point set vs. point set point vs. point set A Foundation for Representing and Querying Moving Objects \u201a€¢ 17 Table VII. Analysis of Binary Predicates Set Theory Order (1D Spaces) Topology u ï¿½ v, u ï¿½ v u ï¿½ v, u ï¿½ v u ï¿½ v, u ï¿½ v U ï¿½ V, U ï¿½ V U before V ï¿½U ï¿½ ï¿½V ï¿½ \u201a€ (touches) U ï¿½ V ï¿½ \u201a€ (intersects) ï¿½U ï¿½ V o ï¿½ \u201a€ (attached) U ï¿½ V (inside) U o ï¿½ V o ï¿½ \u201a€ (overlaps) u ï¿½ U (inside) u before V u ï¿½ ï¿½U (on_border) U before v u ï¿½ U o (in_interior) Table VIII. Binary Predicates Operation Signature Semantics ï¿½, ï¿½ ï¿½ ï¿½ ï¿½ 3 bool u ï¿½ v, u ï¿½ v ï¿½ 1 ï¿½ ï¿½ 2 3 bool U ï¿½ V, U ï¿½ V intersects ï¿½ 1 ï¿½ ï¿½ 2 3 bool U ï¿½ V ï¿½ \u201a€ inside ï¿½ 1 ï¿½ ï¿½ 2 3 bool U ï¿½ V ï¿½ ï¿½ ï¿½ 3 bool u ï¿½ V ï¿½, ï¿½, ï¿½, ï¿½ ï¿½ ï¿½ ï¿½ 3 bool [1D] u ï¿½ v etc. before ï¿½ 1 ï¿½ ï¿½ 2 3 bool [1D] @u ï¿½ U, @v ï¿½ V : u ï¿½ v ï¿½ ï¿½ ï¿½ 3 bool [1D] @v ï¿½ V : u ï¿½ v ï¿½ ï¿½ ï¿½ 3 bool [1D] @u ï¿½ U : u ï¿½ v touches ï¿½ 1 ï¿½ ï¿½ 2 3 bool ï¿½U ï¿½ ï¿½V ï¿½ \u201a€ attached ï¿½ 1 ï¿½ ï¿½ 2 3 bool ï¿½U ï¿½ V o ï¿½ \u201a€ overlaps ï¿½ 1 ï¿½ ï¿½ 2 3 bool U o ï¿½ V o ï¿½ \u201a€ on_border ï¿½ ï¿½ ï¿½ 3 bool u ï¿½ ï¿½U in_interior ï¿½ ï¿½ ï¿½ 3 bool u ï¿½ U o points because the result could be two points, which cannot be represented as a value of point type. Defining set operations on a combination of one- and two-dimensional point sets is more involved. This is because we are using arbitrary closed or open sets in the one-dimensional space, whereas only closed point sets (points, line, and region) exist in the two-dimensional case. The restriction to closed point sets in the two-dimensional case is a natural and common one. Regions lacking part of their boundary or interior points or curves appear unnatural. On the other hand, in the one-dimensional space it is necessary to admit open intervals, since these are the domains of temporal (function) types. When a value changes at time t from a to b, we have to decide what exactly the value is at time t. If at time t it is already b, then we have a right-open time interval (with value a) up to time t, and a left-closed interval with value b starting at t. This justifies a different treatment of one- and two-dimensional point sets. Because our two-dimensional types are closed, it is necessary to apply a closure operation after applying the set operations on such entities, which adds all points on the boundary of an open set. ACM Transactions on Database Systems, Vol. 25, No. 1, March 2000. 18 \u201a€¢ R. H. GÃ¼ting et al. Whereas in all the one-dimensional spaces there is only a single point set type, in two-dimensional space there are three. This requires an analysis of which argument type combinations make sense (return interesting results), and what the result types are. Generally, if we apply set operations to values of different types, we get results that are a mixture of zero-, one-, and two-dimensional point sets, i.e., points, lines, and proper regions. Usually, one is mainly interested in the results of the highest dimension. This is reflected in the concept of regularized set operations [Tilove 1980]. For example, the regularized intersection removes all lower-dimensional pieces from the result of the corresponding intersection result. We also adopt regularization in our framework as the semantics of the three standard set operations, union, minus, and intersection, in two dimensions. On different argument type combinations, the three set operations behave as follows: \u201a€”Union of arguments of equal types has the usual semantics. Due to regularization, for unions on different types, the result is the higherdimensional argument. This result is not interesting, since we know it already. Hence, we define union for equal types only. \u201a€”Difference always results in the type of the first argument. Closure has to be applied to the result. Only those combinations of argument types return new results where the dimension of the second argument is equal or higher to that of the first. If the dimension of the second argument is smaller, then by closure, the first argument value is returned unchanged. We allow difference on all type combinations, even though some of them are not relevant. \u201a€”Intersection produces results of all dimensions smaller or equal to the dimension of the lowest-dimensional argument. For example, the intersection of a line value with a region value may result in points and lines. We define the intersection operator for all type combinations with regularized semantics, i.e., it returns the highest-dimensional part of the result. To make other kinds of results available, we introduce specialized operators, called, e.g., common_border or touch_points. As a result, we obtain the signatures shown in Table IX (some notation used in the column \u201a€œSemantics\u201a€ is explained below). They are divided into five groups, the first two concerning point/point and point vs. point-set interaction. The last three groups deal with point-set/point-set interaction in one- and two-dimensional spaces; the last group introduces specialized intersection operations to obtain lower-dimensional results. The notation minï¿½ï¿½ 1, ï¿½2ï¿½ refers to taking the minimum in an assumed \u201a€œdimensional\u201a€ order points ï¿½ line ï¿½ region. The definition of semantics in Table IX uses predicates is2D and is1D to check whether the argument is of a two-dimensional or one-dimensional ACM Transactions on Database Systems, Vol. 25, No. 1, March 2000. A Foundation for Representing and Querying Moving Objects \u201a€¢ 19 type, respectively. Also, the notations ï¿½ï¿½Qï¿½, Qo , and ï¿½Q are used for closure, interior, and boundary of Q, respectively. For example, in the second group of operations, the second definition for minus says that in two dimensions, after subtracting a point v from a point set U, the closure is applied, whereas in one dimension the result is taken directly. Definitions for intersection that did not fit into the table are as follows. Definition 17. The semantics of intersection operations is defined as follows. Let P, L, and R, possibly indexed, denote arguments of type points, line, and region, respectively. Let Q be an argument of any of the three types. For commutative operations we give the definition for one order of the arguments only, as it is identical for the other order. Definitions are ordered by argument combinations. f intersectionï¿½P, Qï¿½\u201a€“Pï¿½Q Table IX. Set Operations Operation Signature Semantics intersection ï¿½ ï¿½ ï¿½ 3 ï¿½ if u ï¿½ v then u else ï¿½ minus ï¿½ ï¿½ ï¿½ 3 ï¿½ if u ï¿½ v then ï¿½ else u intersection ï¿½ R ï¿½ 3 ï¿½ if u ï¿½ V then u else ï¿½ minus ï¿½ ï¿½ ï¿½ 3 ï¿½ if u ï¿½ V then ï¿½ else u ï¿½ ï¿½ ï¿½ 3 ï¿½ if is2Dï¿½U ï¿½ then ï¿½ï¿½U\\ï¿½vï¿½ï¿½ else U\\ï¿½vï¿½ union ï¿½ R ï¿½ 3 ï¿½ if is1Dï¿½V ï¿½ or typeï¿½V ï¿½ ï¿½ points then V ï¿½ ï¿½uï¿½ else V intersection, ï¿½ ï¿½ ï¿½ 3 ï¿½ [1D] U ï¿½ V, U\\V, U ï¿½ V minus, union intersection ï¿½ 1 ï¿½ ï¿½ 2 3 minï¿½ï¿½ 1, ï¿½ 2ï¿½ [2D] see Def. 17 minus ï¿½ 1 ï¿½ ï¿½ 2 3 ï¿½ 1 [2D] ï¿½ï¿½Q 1\\Q 2ï¿½ union ï¿½ ï¿½ ï¿½ 3 ï¿½ [2D] Q 1 ï¿½ Q 2 crossings line ï¿½ line 3 points see Def. 17 touch_points region R line 3 points region ï¿½ region 3 points common_border region ï¿½ region 3 line f crossingsï¿½L 1, L 2ï¿½\u201a€“ï¿½p ï¿½ L 1 ï¿½ L 2\u201aªp is isolated in L 1 ï¿½ L 2ï¿½ f intersectionï¿½L 1, L 2ï¿½\u201a€“ï¿½L 1 ï¿½ L 2ï¿½\\f crossingsï¿½L 1, L 2ï¿½ f touchï¿½pointsï¿½L, Rï¿½\u201a€“ï¿½p ï¿½ L ï¿½ R\u201aªp is isolated in L ï¿½ Rï¿½ f intersectionï¿½L, Rï¿½\u201a€“ï¿½L ï¿½ Rï¿½\\f touchï¿½pointsï¿½L, Rï¿½ f intersectionï¿½R 1, R 2ï¿½\u201a€“ï¿½ï¿½ï¿½R 1 ï¿½ R 2ï¿½ o ï¿½ f commonï¿½borderï¿½R 1, R 2ï¿½\u201a€“f intersectionï¿½ï¿½R 1, ï¿½R 2ï¿½ f touchï¿½pointsï¿½R 1, R 2ï¿½\u201a€“f crossingsï¿½ï¿½R 1, ï¿½R 2ï¿½ ACM Transactions on Database Systems, Vol. 25, No. 1, March 2000. 20 \u201a€¢ R. H. GÃ¼ting et al. Table X. Aggregate Operations Operation Signature Semantics min, max ï¿½ 3 ï¿½ [1D] minï¿½ï¿½ï¿½U ï¿½ï¿½, maxï¿½ï¿½ï¿½U ï¿½ï¿½ avg ï¿½ 3 ï¿½ [1Dnum] 1 supï¿½T ï¿½ï¿½infï¿½T ï¿½ Tï¿½intvlsï¿½U ï¿½ ï¿½intvlsï¿½U ï¿½ï¿½ï¿½ 2 avg[center] points 3 ï¿½ [2D] 1 pï¿½U nï¿½ pï¿½ avg[center] line 3 ï¿½ [2D] 1 cï¿½scï¿½U ï¿½ ï¿½U ï¿½ï¿½ cï¿½ï¿½cï¿½ avg[center] region 3 ï¿½ [2D] 1 Mï¿½U ï¿½x, yï¿½dU where M ï¿½ ï¿½ dU U single ï¿½ 3 ï¿½ if ?u : U ï¿½ ï¿½uï¿½ then u else ï¿½ The following example shows how with union and intersection we also have the corresponding aggregate functions over sets of objects (relations) available. Example 4. \u201a€œDetermine the region of Europe from the regions of its countries.\u201a€ LET sum ï¿½ AGGREGATE(union, TheEmptyRegion); LET Europe ï¿½ SELECT sum(area) FROM country This makes use of the facility for constructing aggregate functions described in Section 2. TheEmptyRegion is some empty region constant defined in the database. 4.2.4 Aggregation. Aggregation reduces sets of points to points (Table X). In one-dimensional space, where total orders are available, closed sets have minimum and maximum values, and functions (min and max) that extract these are provided. For open and half-open intervals, we choose to let these functions return infimum and supremum values, i.e., the maximum and minimum of their closure. This is preferable over returning undefined values. In all domains that have addition, we can compute the average (avg). In 2D, the average is based on vector addition, and is usually called the center (of gravity). It is often useful to have a \u201a€œcasting\u201a€ operation available to transform a singleton set into its single value. For example, some operations have to return set types, although the result is often expected to be a single value. The operation single does this conversion. Example 5. The query \u201a€œFind the point where highway A1 crosses the river Rhine!\u201a€ can be expressed as: LET RhineA1 ï¿½ ELEMENT( SELECT single(crossings (R.route, H.route)) FROM river R, highway H WHERE R.name ï¿½ \u201a€œRhine\u201a€ and H.name ï¿½ \u201a€œA1\u201a€ and R.route intersects H.route) ACM Transactions on Database Systems, Vol. 25, No. 1, March 2000. A Foundation for Representing and Querying Moving Objects \u201a€¢ 21 The result can be used as a point value in further queries, whereas crossings returns a points value. In the definition of semantics, the one for the average of a line value needs some explanation. Recall that scï¿½U ï¿½ denotes the set of simple curves from which line U is built. We define the x- and y-projections of a curve c: @u ï¿½ ï¿½0, 1ï¿½ : cxï¿½uï¿½ ï¿½ x and cyï¿½uï¿½ ï¿½ y iff cï¿½uï¿½ ï¿½ ï¿½x, yï¿½. Then the length of a curve c, denoted ï¿½cï¿½, is defined as 1 ï¿½cï¿½ ï¿½ï¿½ 0 ï¿½cï¿½ xï¿½uï¿½ 2 ï¿½ cï¿½ yï¿½uï¿½ 2 du where, e.g., cï¿½ x is the derivative of c x, that is, dc xï¿½uï¿½ ï¿½ du. The length of a line U, denoted ï¿½U ï¿½, is given by the sum of the lengths of its curves, hence ï¿½U ï¿½ ï¿½ ï¿½cï¿½scï¿½U ï¿½ï¿½cï¿½. The average of a curve c is defined as a point vector: 1 cï¿½ ï¿½ï¿½ cï¿½uï¿½ ï¿½du 0 In the definition of avg (or center) of a region, integration is done over pieces of the region according to the general formula ï¿½ S fï¿½x, yï¿½dS which integrates a function f defined on the two-dimensional plane over an arbitrary region S. In this case integration is done over the vectors ï¿½x, yï¿½ for each piece dU. 4.2.5 Numeric Properties of Sets. For sets of points, some well-known numeric properties exist (Table XI). For example, the number of components (no_components) is the number of disjoint maximal connected subsets, i.e., the number of faces for a region, connected components for a line graph, and intervals for a onedimensional point set. The size is defined for all continuous set types (i.e., for range(real), periods, line, and region). For one-dimensional types, the size is the sum of the lengths of component intervals; for line, it is the length; and for region, it is the area. For the region type, we are additionally interested in the size of the boundary, called perimeter. Example 6. \u201a€œList for each country its total size and the number of disjoint land areas.\u201a€ SELECT name, area(area), no_components(area) FROM country ACM Transactions on Database Systems, Vol. 25, No. 1, March 2000. 22 \u201a€¢ R. H. GÃ¼ting et al. Table XI. Numeric Operations Operation Signature Semantics no_components ï¿½ 3 int [1D] ï¿½intvlsï¿½U ï¿½ï¿½ no_components points 3 int ï¿½Uï¿½ no_components line 3 int ï¿½blocksï¿½U ï¿½ï¿½ no_components size[duration] region ï¿½ 3 int 3 real [1Dcont] ï¿½facesï¿½U ï¿½ï¿½ ï¿½Tï¿½intvlsï¿½U ï¿½supï¿½T ï¿½ ï¿½ infï¿½T ï¿½ size[length] line 3 real ï¿½U ï¿½ size[area] region 3 real ï¿½UdU perimeter region 3 real flengthï¿½ï¿½U ï¿½ Table XII. Distance and Direction Operations Operation Signature Semantics distance ï¿½ ï¿½ ï¿½ 3 real [1Dcont] ï¿½u ï¿½ vï¿½ ï¿½ R ï¿½ 3 real [1Dcont] minï¿½ï¿½u ï¿½ vï¿½\u201aªv ï¿½ Vï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ 3 real [1Dcont] 3 real [2D] minï¿½ï¿½u ï¿½ vï¿½\u201aªu ï¿½ U, v ï¿½ Vï¿½ distï¿½u, vï¿½ ï¿½ ï¿½ï¿½u.x ï¿½ v.xï¿½ 2 ï¿½ ï¿½u.y ï¿½ v.yï¿½ 2 ï¿½ R ï¿½ 3 real [2D] minï¿½distï¿½u, vï¿½\u201aªv ï¿½ Vï¿½ ï¿½ ï¿½ ï¿½ 3 real [2D] minï¿½distï¿½u, vï¿½\u201aªu ï¿½ U, v ï¿½ Vï¿½ direction point ï¿½ point 3 real see below Example 7. \u201a€œHow long is the common border of France and Germany?\u201a€ LET France ï¿½ ELEMENT(SELECT area FROM country WHERE name ï¿½ \u201a€œFrance\u201a€); LET Germany ï¿½ ELEMENT(SELECT area FROM country WHERE name ï¿½ \u201a€œGermany\u201a€); length(common_border(France, Germany)) 4.2.6 Distance and Direction. A distance measure exists for all continuous types. The distance function determines the minimum distance between the closest pair of points from the first and second arguments. The distance between two points is the absolute value of the difference in one-dimensional space and the Euclidean distance in two-dimensional space. The time domain inherits arithmetics from the domain of real numbers, to which it is isomorphic. The direction between points is sometimes of interest. A direction function is thus included that returns the angle of the line from the first to the second point, measured in degrees (0 ï¿½ angle ï¿½ 360). Hence, if q is exactly north of p, then directionï¿½ p, qï¿½ ï¿½ 90.Ifp ï¿½ q, then the direction operation returns the undefined value ï¿½. A formal definition is straightforward, but a bit lengthy and omitted here; it can be found in GÃ¼ting et al. [1998]. Example 8. \u201a€œFind all cities north of and within 200 kms of Munich!\u201a€ LET Munich ï¿½ ELEMENT(SELECT center FROM city WHERE name ï¿½ \u201a€œMunich\u201a€); SELECT name FROM city ACM Transactions on Database Systems, Vol. 25, No. 1, March 2000. A Foundation for Representing and Querying Moving Objects \u201a€¢ 23 Table XIII. Boolean Operations Operation Signature Semantics and, or bool ï¿½ bool 3 bool as usual (with strict evaluation) not bool 3 bool Table XIV. Operations for Projection of Temporal Values into Domain and Range Operation Signature Semantics deftime movingï¿½ï¿½ï¿½ 3 periods domï¿½ï¿½ï¿½ rangevalues movingï¿½ï¿½ï¿½ 3 rangeï¿½ï¿½ï¿½ [1D] rngï¿½ï¿½ï¿½ locations movingï¿½pointï¿½ 3 points isolatedï¿½rngï¿½ï¿½ï¿½ï¿½ movingï¿½pointsï¿½ 3 points isolatedï¿½ï¿½ rngï¿½ï¿½ï¿½ï¿½ trajectory movingï¿½pointï¿½ 3 line rngï¿½ï¿½ï¿½\\f locationsï¿½ï¿½ï¿½ movingï¿½pointsï¿½ 3 line ï¿½ rngï¿½ï¿½ï¿½\\f locationsï¿½ï¿½ï¿½ traversed movingï¿½lineï¿½ 3 region ï¿½ï¿½ï¿½ï¿½ rngï¿½ï¿½ï¿½ï¿½ ï¿½ï¿½ movingï¿½regionï¿½ 3 region ï¿½ rngï¿½ï¿½ï¿½ routes movingï¿½lineï¿½ 3 line ï¿½ï¿½ï¿½ rngï¿½ï¿½ï¿½ï¿½\\f traversedï¿½ï¿½ï¿½ inst intimeï¿½ï¿½ï¿½ 3 instant t where u ï¿½ ï¿½t, vï¿½ val intimeï¿½ï¿½ï¿½ 3 ï¿½ v where u ï¿½ ï¿½t, vï¿½ WHERE distance(center, Munich) ï¿½ 200 and direction(Munich, center) ï¿½ï¿½ 45 and direction(Munich, center) ï¿½ï¿½ 135 In this way we can express direction relationships such as north, south, etc., via numeric relationships. 4.2.7 Specific Operations for Base Types. Some operations on base types are needed that are not related to the point/point set view. We mention them because they have to be included in the scope of operations to be lifted, i.e., the kernel algebra (see Table XIII). 4.2.8 Scope of the Kernel Algebra. The kernel algebra is defined to consist of the types in BASE ï¿½ SPATIAL, together with all operations defined in Section 4.2, restricted to these types. 4.3 Operations on Temporal Types Values of temporal types (i.e., types moving(ï¿½)) are partial functions of the form f : Ainstant3 Aï¿½ ï¿½. In the following sections we discuss operations for projection into domain and range, interaction with values from domain and range, the when operation, lifting, and operations related to rate of change. 4.3.1 Projection to Domain and Range. For values of all moving types (which are functions), operations are provided that yield the domain and range of these functions (Table XIV). The domain function deftime returns the times for which a function is defined. In one-dimensional space, operation rangevalues returns values assumed over time as a set of intervals. For the two-dimensional types, ACM Transactions on Database Systems, Vol. 25, No. 1, March 2000. 24 \u201a€¢ R. H. GÃ¼ting et al. operations are offered to return the parts of the projections corresponding to our data types. For example, the projection of a moving point into the plane may consist of points and of lines; these can be obtained separately by operations locations and trajectory, respectively. In particular, if a moving point (or point set) changes its position in discrete steps only, then locations returns its projection as a points value. Operation routes similarly returns the projection of a discretely moving line value. The more natural projections of continuously moving objects are obtained by operations trajectory and traversed. For values of intime types, the two trivial projection operations inst and val are offered, yielding the two components. All the infinite point sets that result from domain and range projections are represented in collapsed form by the corresponding point set types. For example, a set of instants is represented as a periods value, and an infinite set of regions is represented by the union of the points of the regions, which is represented in turn as a region value. That these projections can be represented as finite collections of intervals, faces, etc., and hence correspond to our data types, is due to the continuity condition required for types moving(ï¿½) (see Section 3.1.4). The design is complete in that all projection values in domain and range can be obtained. This was one of the major principles in the design of the type system, as discussed in Section 3.2. For defining the semantics of operations on temporal types, a little more notation is needed. For a partial function f : A3B we write fï¿½xï¿½ ï¿½ ï¿½ whenever f is undefined for x ï¿½ A. To adjust the undefined value ï¿½ for values of type points, line, and region to \u201a€, we use the function: x1ï¿½ï¿½ï¿½ \u201a€ if x ï¿½ ï¿½ \u201aˆ§ ï¿½ ï¿½ ï¿½points, line, regionï¿½ x otherwise The domain of f is given by domï¿½ f ï¿½ ï¿½ ï¿½ x ï¿½ A ï¿½ fï¿½xï¿½ ï¿½ ï¿½ï¿½. Similarly, the range of f is defined by rngï¿½ f ï¿½ ï¿½ ï¿½y ï¿½ B ï¿½ ?x ï¿½ A : fï¿½xï¿½ ï¿½ yï¿½. If the elements of rngï¿½ f ï¿½ are sets, then we write ï¿½ rngï¿½ f ï¿½ as an abbreviation of the union of all these sets, i.e., ï¿½ rngï¿½ f ï¿½ ï¿½ ï¿½ Yï¿½rngï¿½ f ï¿½ Y. Example 9. To illustrate operations on temporal types, we use the example relations: flight(airline: string, no:int, from:string, to:string, route:mpoint) weather(name: string, kind:string, area:mregion) site(name: string, pos:point) Attributes airline and no of the relation flight identify a flight. In addition, the relation records the names of the departure and destination cities and the route taken for each flight. The last attribute is of type moving(point). We assume that a flight\u201a€™s route is defined only for the times the plane is in flight and not when it is on the ground. ACM Transactions on Database Systems, Vol. 25, No. 1, March 2000. A Foundation for Representing and Querying Moving Objects \u201a€¢ 25 The relation weather records weather events such as high pressure areas, storms, or temperature maps. Some of these events are given names to identify them. The attribute kind gives the type of weather event, such as \u201a€œsnow-cloud\u201a€ or \u201a€œtornado,\u201a€ and the area attribute provides the evolving extent of each weather event. Relation site contains positions of certain well-known sites such as the Eiffel tower, Big Ben, etc. Example 10. With the operations of this section we can formulate the following queries: \u201a€œHow long is the part of the route of flight LH 257 that lies within France?\u201a€ LET route257 ï¿½ ELEMENT( SELECT route FROM flight WHERE airline ï¿½ \u201a€œLH\u201a€ and no ï¿½ 257); length(intersection(France, trajectory(route257)) \u201a€œWhat are the departure and arrival times of flight LH 257?\u201a€ min(deftime(route257)); max(deftime(route257)); Example 11. \u201a€œAt what time and distance does flight 257 pass the Eiffel tower?\u201a€ We assume a closest operator with signature mpoint ï¿½ point 3 intime(point), which returns time and position when a moving point is closest to a given fixed point in the plane. We will later show how such an operator can be defined in terms of others. LET EiffelTower ï¿½ ELEMENT(SELECT pos FROM site WHERE name ï¿½ \u201a€œEiffel Tower\u201a€); LET pass ï¿½ closest(route257, EiffelTower); inst(pass); distance(EiffelTower, val(pass)) 4.3.2 Interaction with Points and Point Sets in Domain and Range. In this section we systematically study operations that relate the functional values of moving types with values either in their (time) domain or their range. For example, a moving point moves through the two-dimensional plane; does it pass a given point or region in this plane? Does a moving real ever assume the given value 3.5? Besides comparison, one can also restrict the moving entity to the given domain or range values, e.g., get the part of the moving point when it was within the region, or determine the value of the moving real at time t or within time interval ï¿½t 1, t 2ï¿½. In Table XV, the first group of operations concerns interaction with time domain values, the second interaction with range values. Operations atinstant and atperiods restrict a moving entity to a given instant, resulting in a pair (instant, value), or to a given set of time intervals, respectively. The atinstant operation is similar to the timeslice operator found in most temporal relational algebras (see, e.g., McKenzie and Snodgrass [1991]; Ã–zsoyoglu and Snodgrass [1995]). Operations initial and final return the first and last (instant, value) pair, respectively. Operation present allows one to check whether the moving value exists at a given instant, or is ever present during a given set of time intervals. ACM Transactions on Database Systems, Vol. 25, No. 1, March 2000. 26 \u201a€¢ R. H. GÃ¼ting et al. Table XV. Interaction of Temporal Values With Values in Domain and Range Operation Signature Semantics atinstant movingï¿½ï¿½ï¿½ ï¿½ instant 3 intimeï¿½ï¿½ï¿½ ï¿½t, ï¿½ï¿½tï¿½1ï¿½ï¿½ atperiods movingï¿½ï¿½ï¿½ ï¿½ periods 3 movingï¿½ï¿½ï¿½ ï¿½ï¿½t, yï¿½ ï¿½ ï¿½ ï¿½ t ï¿½ Tï¿½ initial final present movingï¿½ï¿½ï¿½ movingï¿½ï¿½ï¿½ movingï¿½ï¿½ï¿½ ï¿½ instant 3 intimeï¿½ï¿½ï¿½ 3 intimeï¿½ï¿½ï¿½ 3 bool lim ï¿½ï¿½tï¿½ t3infï¿½domï¿½ï¿½ï¿½ï¿½ lim ï¿½ï¿½tï¿½ t3supï¿½domï¿½ï¿½ï¿½ï¿½ ï¿½ï¿½tï¿½ ï¿½ ï¿½ present movingï¿½ï¿½ï¿½ ï¿½ periods 3 bool fatperiodsï¿½ï¿½, T ï¿½ ï¿½ \u201a€ at movingï¿½ï¿½ï¿½ ï¿½ ï¿½ 3 movingï¿½ï¿½ï¿½ [1D] ï¿½ï¿½t, yï¿½ ï¿½ ï¿½ ï¿½ y ï¿½ bï¿½ at movingï¿½ï¿½ï¿½ ï¿½ rangeï¿½ï¿½ï¿½ 3 movingï¿½ï¿½ï¿½ [1D] ï¿½ï¿½t, yï¿½ ï¿½ ï¿½ ï¿½ y ï¿½ Bï¿½ at movingï¿½ï¿½ï¿½ ï¿½ point 3 mpoint [2D] ï¿½ï¿½t, yï¿½ ï¿½ ï¿½ ï¿½ y ï¿½ uï¿½ at movingï¿½ï¿½ï¿½ ï¿½ ï¿½ 3 movingï¿½ï¿½ï¿½ [2D] ï¿½ï¿½t, yï¿½ ï¿½ ï¿½ ï¿½ y ï¿½ Uï¿½ atmin movingï¿½ï¿½ï¿½ 3 movingï¿½ï¿½ï¿½ [1D] ï¿½ï¿½t, yï¿½ ï¿½ ï¿½ ï¿½ y ï¿½ minï¿½rngï¿½ï¿½ï¿½ï¿½ï¿½ atmax movingï¿½ï¿½ï¿½ 3 movingï¿½ï¿½ï¿½ [1D] ï¿½ï¿½t, yï¿½ ï¿½ ï¿½ ï¿½ y ï¿½ maxï¿½rngï¿½ï¿½ï¿½ï¿½ï¿½ passes movingï¿½ï¿½ï¿½ ï¿½ ï¿½ 3 bool f atï¿½ï¿½, xï¿½ ï¿½ \u201a€ In the second group, the purpose of at is again restriction (such as atinstant, atperiods), this time to values in the range. For one-dimensional space, restriction by either a point or a point-set value returns a value of the given moving type. For example, we can reduce a moving real to the times when its value was between 3 and 4. In two dimensions, the resulting moving type is obtained by taking the minimum of the two argument types ï¿½ and ï¿½ with respect to the order point ï¿½ points ï¿½ line ï¿½ region. For example, the restriction of a moving(region) byapoint will result in a moving( point). This is analogous to the definition of result types for intersection in two dimensions in Section 4.2.3. In one-dimensional spaces, operations atmin and atmax restrict the moving value to the times when it is minimal or maximal with respect to the total order on this space. Operation passes allows one to check whether the moving value ever assumed (one of) the value(s) given as a second argument. For the definition of semantics, notation for the arguments is defined in Section 4.2.1. In particular, ï¿½ is a function argument and a function is a set of (argument, value) pairs. All of these operations are of interest from a language design point of view. Some of them are derived, however, so they can be expressed by other operations in the design. For example, we have present(f, t)ï¿½not(isempty(val(at instant(f, t)))) Example 12. \u201a€œWhen and where did flight 257 enter the territory of France ?\u201a€ LET entry ï¿½ initial (at(route257, France)); inst(entry); val(entry) Example 13. \u201a€œFor which periods of time was the Eiffel Tower within snow storm \u201a€˜Lizzy\u201a€™ ?\u201a€ LET Lizzy ï¿½ ELEMENT(SELECT area FROM weather WHERE name ï¿½ \u201a€œLizzy\u201a€ and kind ï¿½ \u201a€œsnow storm\u201a€); deftime(at(Lizzy, EiffelTower)) ACM Transactions on Database Systems, Vol. 25, No. 1, March 2000. A Foundation for Representing and Querying Moving Objects \u201a€¢ 27 4.3.3 The Elusive when Operation. We now consider (speculate about) an extremely powerful, yet conceptually quite simple, operation called when, whose signature is shown in Table XVI. The idea is that we can restrict a time-dependent value to the periods when its range value fulfils some property specified as a predicate. If we had such an operator, we could express a query such as \u201a€œRestrict a moving region mr to the times when its area was greater 1000\u201a€ as mr when [FUN (r:region) area(r) ï¿½ 1000] Here the result would again be of type mregion. Whereas such an operation would be very powerful and desirable, it is questionable whether such a definition makes any sense. This is because the operator has to call for evaluation of the parameter predicate infinitely many times, since our moving entities are functions over a continuous domain. Looping over an infinite domain is inherently impossible. So for the moment this operation seems impossible to implement. 4.3.4 Lifting Operations to Time-Dependent Operations. Section 4.2 systematically defines operations on nontemporal types, the kernel algebra. This section uniformly lifts these operations to apply to the corresponding moving (temporal) types. Consider an operation to be lifted. The idea is to allow any argument of the operation to be made temporal and to return a temporal type. More specifically, the lifted version of an operation with signature ï¿½1 ï¿½ ... ï¿½ ï¿½k3ï¿½ has signatures ï¿½ï¿½ 1 ï¿½ ... ï¿½ ï¿½ï¿½ k3movingï¿½ï¿½ï¿½ with ï¿½ï¿½ ï¿½ ï¿½ï¿½ i, movingï¿½ï¿½ iï¿½ï¿½. So each of the argument types may change into a timedependent type that will transform the result type into a time-dependent type as well. The operations that result from lifting are given the same name as the operation they originate from. For example, the intersection operation with signature is lifted to the signatures Table XVI. The when Operation Operation Signature Semantics Syntax when movingï¿½ï¿½ï¿½ ï¿½ ï¿½ï¿½3boolï¿½3movingï¿½ï¿½ï¿½ ï¿½ï¿½t, yï¿½ ï¿½ ï¿½ ï¿½ pï¿½ yï¿½ï¿½ arg1opï¿½arg2ï¿½ region ï¿½ point3point mregion ï¿½ point 3 mpoint region ï¿½ mpoint3mpoint, and mregion ï¿½ mpoint3mpoint. To define the semantics of lifting, we note that an operation op : ï¿½ 1 ï¿½ ...ï¿½ ï¿½ k3ï¿½ can be lifted with respect to any combination of argument ACM Transactions on Database Systems, Vol. 25, No. 1, March 2000. 28 \u201a€¢ R. H. GÃ¼ting et al. types. Such a combination can be conveniently described by a set of indices L ï¿½ ï¿½1,...,kï¿½ for the lifted parameters, and we define L ï¿½i ï¿½ ï¿½ movingï¿½ï¿½iï¿½ if i ï¿½ L ï¿½i otherwise L Thus, the signature of any lifted version of op can be written as op : ï¿½1 L ï¿½ ... ï¿½ ï¿½k 3 movingï¿½ï¿½ï¿½. Iffop is the semantics of op, we now have to L define the semantics of fop for each possible lifting L. For this, we define what it means to apply a possibly lifted value to an instant-value: L xi ï¿½tï¿½ ï¿½ ï¿½ xiï¿½tï¿½ if i ï¿½ L xi otherwise L Now we can define the functions fop pointwise by L L L fopï¿½x1,...,xkï¿½ ï¿½ ï¿½ï¿½t, fopï¿½x1ï¿½tï¿½,...,xk ï¿½tï¿½ï¿½ï¿½\u201aªt ï¿½ Ainstantï¿½ This lifting of operations generalizes existing operations that did not appear to be of great utility to operations that are quite useful. For example, an operator that determines the intersection of a region with a point may not be of great interest, but the operation that determines the intersection between a region and an mpoint (\u201a€œget the part of the mpoint within the region\u201a€) is quite useful. This explains why Section 4.2.3 takes care to define the set operations for all argument types, including single points. The fact that now all operations of the kernel algebra are also available as time-dependent operations results in a very powerful query language. Here are some examples. Example 14. We can formulate pretty involved queries such as \u201a€œFor how long did the moving point mp move along the boundary of region r?\u201a€ duration(deftime(at(on_border(mp, r), TRUE))) Here predicate on_border yields a result of type mbool. This result is defined for all times that mp is defined and has value TRUE or FALSE. Operation at reduces the definition time of this mbool to the times when it has value TRUE. Example 15. \u201a€œDetermine the periods of time when snow storm \u201a€˜Lizzy\u201a€™ consisted of exactly three separate areas.\u201a€ deftime(at(no_components(Lizzy) ï¿½ 3, TRUE)) Again, this works because \u201a€˜Lizzy\u201a€™ is of type mregion, hence the lifted versions of no_components and equality apply. Example 16. We are now able to define the closest operator of Example 11 within a query: LET closestï¿½ FUN (mp:mpoint, p:point) atinstant(mp, inst(initial(atmin(distance(mp, p))))) ACM Transactions on Database Systems, Vol. 25, No. 1, March 2000. A Foundation for Representing and Querying Moving Objects \u201a€¢ 29 This depends on the lifted distance operator. We reduce the resulting mreal to the times when it is minimal, take the first such (instant, value) pair and then the instant from this pair. Finally, the original moving point is taken at this instant. Lifting is the key to achieving the goal of consistency and closure between nontemporal and temporal operations, as explained in Section 4.1. 4.3.5 The Elusive when Revisited. After lifting the operations of the kernel algebra, it turns out that we have another way of expressing the query of Section 4.3.3: \u201a€œRestrict a moving region mr to the times when its size was greater 1000\u201a€. Using when, this was written as mr when[FUN (r:region) area (r) ï¿½ 1000] Using the lifted versions of area and ï¿½ , this is equivalent to atperiods(mr, deftime(at(area(mr) ï¿½ 1000, TRUE))) Why is it suddenly possible to realize the effect of the apparently unimplementable when? The reason is that we did not try to evaluate the parameter expression area(r) ï¿½ 1000 on infinitely many instances of parameter r, but instead evaluated its \u201a€œlifted version\u201a€ area(mr) ï¿½ 1000 on the original argument mr of when. In terms of implementation, there are two different functions (algorithms) for area, one that is applicable to region values, and one that is applicable directly to mregion values. We do not call the first algorithm (applicable to region values) infinitely many times, but instead the latter (applicable to mregion values) just once. This is in fact a general technique for translating when queries. It is applicable for all parameter expressions of when that are formed using operations of the kernel algebra only. The translation is x when[FUN(y:ï¿½) p(y)] ï¿½ atperiods(x, deftime(at(p(y)ï¿½, TRUE))) The substitution ï¿½ ï¿½ ï¿½y ï¿½ xï¿½, applied to p(y), replaces each occurrence of y with the original moving object x (of type moving(ï¿½)). Hence, when can be implemented by rewriting it in this way. So based on lifting and rewriting, we have in fact obtained an effective implementation of the when operator. 4.3.6 Rate of Change. An important property of any time-dependent value is its rate of change, i.e., its derivative. To determine which of our data types this concept is applicable to, consider the definition of the derivative, given next. fï¿½t ï¿½ï¿½tï¿½ ï¿½ fï¿½tï¿½ fï¿½ï¿½tï¿½ ï¿½ lim ï¿½t30 ï¿½t This definition, and thus the notion of derivation, is applicable to any temporal type movingï¿½ï¿½ï¿½ with a range type ï¿½ that (i) supports a difference operation and (ii) supports division by a value of type real. ACM Transactions on Database Systems, Vol. 25, No. 1, March 2000. 30 \u201a€¢ R. H. GÃ¼ting et al. Table XVII. Derivative Operations Operation Signature Semantics derivative speed turn velocity mreal mpoint mpoint mpoint 3 real 3 mreal 3 mreal 3 mpoint ï¿½ï¿½ where ï¿½ï¿½ï¿½tï¿½ ï¿½ lim ï¿½ï¿½ï¿½t ï¿½ ï¿½ï¿½ ï¿½ ï¿½ï¿½tï¿½ï¿½ï¿½ ï¿½ ï¿½30 ï¿½ï¿½ where ï¿½ï¿½ï¿½tï¿½ ï¿½ lim f ï¿½30 distanceï¿½ï¿½ï¿½t ï¿½ ï¿½ï¿½, ï¿½ï¿½tï¿½ï¿½ï¿½ ï¿½ ï¿½ï¿½ where ï¿½ï¿½ï¿½tï¿½ ï¿½ lim f ï¿½30 directionï¿½ï¿½ï¿½t ï¿½ ï¿½ï¿½, ï¿½ï¿½tï¿½ï¿½ï¿½ ï¿½ ï¿½ï¿½ where ï¿½ï¿½ï¿½tï¿½ ï¿½ lim ï¿½ï¿½ï¿½t ï¿½ ï¿½ï¿½ ï¿½ ï¿½ï¿½tï¿½ï¿½ï¿½ ï¿½ ï¿½30 Type real clearly qualifies as a range type. For type point, at least three operations may assume the role of difference in the definition, namely the Euclidean distance, the direction between two points, and the vector difference (viewing points as 2D vectors). This leads to three different derivative operations, which we call speed, turn, and velocity, respectively (see Table XVII). Note that we can get the acceleration of a moving point mp as a number by derivative(speed(mp)) and as a vector, or moving point, by velocity(velocity(mp)). The notion of derivation does not apply to the discrete data types int, string, and bool because there is no division available (for string and bool, a difference operation is also absent). There is also no obvious way to define difference and division for regions, although some ideas for this are discussed in GÃ¼ting et al. [1998]. Example 17. Nevertheless, one can still observe, for example, the growth rate of a moving region: \u201a€œAt what time did snow storm Lizzy expand most?\u201a€ inst(initial(atmax(derivative(area(Lizzy))))) Example 18. \u201a€œShow on a map the parts of the route of flight 257 when the plane\u201a€™s speed exceeds 800 km/h.\u201a€ trajectory(atperiods(route257, deftime(at(speed(route257) ï¿½800,TRUE)))) Of course, the background of the map still has to be produced by a different tool or query. 4.4 Operations on Sets of Objects All operations defined in Sections 4.2 and 4.3 apply to \u201a€œatomic\u201a€ data types only, i.e., attribute data types with respect to a DBMS data model. All data types of our design, as described in Section 3, and including the temporal ones, are atomic in this sense. However, sometimes in the design of data types for new applications there are operations of interest that cannot be formulated in terms of the atomic data types alone, but need to manipulate a set of database objects (with attributes of the new data types) as a whole. An example in spatial databases is the computation of a Voronoi diagram. Such data type related operations on sets of objects have been introduced earlier, for example, in the ROSE algebra [GÃ¼ting and Schneider 1995]. In the design of this paper we need only a single set operator, called decompose. Its purpose is to make the components of values of point set types accessible within a query. \u201a€œComponents\u201a€ refers to connected compo- ACM Transactions on Database Systems, Vol. 25, No. 1, March 2000. A Foundation for Representing and Querying Moving Objects \u201a€¢ 31 Table XVIII. Operations on Sets of Database Objects Operation Signature Semantics decompose setï¿½ï¿½ 1ï¿½ ï¿½ ï¿½ï¿½ 13ï¿½ï¿½ ï¿½ ident 3 setï¿½ï¿½ 2ï¿½ see Def. 18 setï¿½ï¿½ 1ï¿½ ï¿½ ï¿½ï¿½ 13movingï¿½ï¿½ï¿½ï¿½ ï¿½ ident 3 setï¿½ï¿½ 2ï¿½ see Def. 18 nents; all our point set types are defined to have a structure that consists of a finite number of connected components. For any range type, a component is a single interval; for the types points, line, and region, a component is a single point, a maximal connected subgraph, and a face, respectively (this is defined formally below). Decomposition basically transforms a value of some point set type ï¿½ into a set of values of the same type ï¿½ such that each value in the result set contains a single component. Similarly, decompose makes the connected components of temporal data types available. Here a component is a maximal continuous part of the function value. As a manipulation of a set of database objects, this is treated as follows. The first argument of decompose is a set of database objects (e.g., a set of tuples in the relational model). The second argument is a function (e.g., an attribute name) that maps an object (e.g., a tuple) into a value of some point set type. The third argument is an identifier, used as a name for a new attribute. The result set of objects is produced as follows: For each object u with an attribute value that has k components, decompose returns k copies of u, each of which is extended by one of the k component values (under the new attribute). The signature is shown in Table XVIII. The syntax for applying this operator is arg 1 opï¿½arg 2, arg 3ï¿½. The semantics can be defined formally as follows. Let S be a value of any of our point set types, and ï¿½ a value of a temporal type. We first define a generic function comp to decompose S or ï¿½ into a finite set of values of the same type, namely: ï¿½ intvlsï¿½Sï¿½ compï¿½Sï¿½ ï¿½ compï¿½ï¿½ï¿½ ï¿½ï¿½ï¿½ï¿½ï¿½ if S is of type rangeï¿½ï¿½ï¿½ ï¿½ï¿½pï¿½\u201aªp ï¿½ Sï¿½ if S is of type points blocksï¿½Sï¿½ if S is of type line facesï¿½Sï¿½ if S is of type region Here ï¿½ï¿½ï¿½ï¿½ is the function that determines the maximal continuous components of a moving object ï¿½ as defined in the Appendix. Let O ï¿½ ï¿½o 1,...,o nï¿½ be a set of database objects (e.g., tuples) and let attr be a function yielding an attribute value of a database object o ï¿½ O. Let name be a name for the new attribute. Furthermore, let Q be a function that appends an attribute value to a database object, or an attribute to an object type. Then ACM Transactions on Database Systems, Vol. 25, No. 1, March 2000. 32 \u201a€¢ R. H. GÃ¼ting et al. f decomposeï¿½O, attr, nameï¿½ ï¿½ ï¿½o Q v\u201aªo ï¿½ O, v ï¿½ compï¿½attrï¿½oï¿½ï¿½ï¿½ The type mapping performed by the decompose operator is ï¿½ decomposeï¿½setï¿½ï¿½ 1ï¿½, ï¿½ 13ï¿½, nameï¿½ ï¿½ setï¿½ï¿½ 1 Q ï¿½name, ï¿½ï¿½ï¿½ That is, the result is a set of objects with an additional attribute \u201a€œname\u201a€ of type ï¿½. Example 19. Consider the relation country(name:string, area:region) introduced earlier. The query country decompose[area,part] returns a relation with schema (name: string, area: region, part: region) Example 20. This example illustrates decomposition of a temporal value. Let us assume that flight 257 alternates between being over land areas of Europe and over the sea. We would like to see a list of time periods, ordered by duration, when flight 257 was over land. LET land257 ï¿½ SET(route, at(route257, Europe)) decompose[route, piece]; SELECT start AS min(deftime(piece)), duration AS duration(deftime(piece)) end AS max(deftime(piece)), FROM land257 ORDER BY duration Here the at operation restricts flight 257 to the parts above Europe (whose area was computed earlier in Example 4). The SET constructor transforms this into a relation with one tuple and a single attribute route containing this value. Then decompose is applied to this relation, which puts each component of the moving point into a separate tuple. The relation land257 created in this way is then processed in the next part of the query. "},{"aspect":"expcomparison","tweet":""}]}